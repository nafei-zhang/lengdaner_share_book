{"./":{"url":"./","title":"简介","keywords":"","body":"​ 本人，Lengdaner，经过一段时间的慎重考虑，决定将之前的博客关闭，原因如下：之前的博客采用前后短分离的模式来实现的，使用React做的博客管理系统，Vue实现的博客展示端，后端采用Java来实现，服务器采用案例云Ecs最便宜的那款服务器，维护者数据库等大量的工作，如果出现问题需要一定的时间排查，需要定期清理日志等等工作，占用了我大量的写作时间。 ​ 2021年5月份我决定讲博客转换为Gitbook来管理，之前是学习服务器前端，后端等知识来手把手搭建自己的博客，后面遇到服务器被攻击等等一系列的问题，不是不能解决，是因为解决这些问题占用了大量的学习思考写作时间。所以做了这个决定。那么改造就从这里开始吧，后面会定期分享我的资源与学习经历，以及工作的趟过的各种坑。 感谢大家的持续关注。一个热爱学习，热爱分享的小伙子。 ​ -------------------------------- 敬上各位读者 -------------------------------- 另外推荐一个可以领取 IT 最新资料的大佬，放上二维码吧！有需要的可以加一下～～～ 资源选择池： 更多资源请看语雀-高清IT清单 "},"Articles/Layout/Layout.html":{"url":"Articles/Layout/Layout.html","title":"页面布局","keywords":"","body":"本章节包括如下内容： 居中 多列布局 "},"Articles/Layout/Centered.html":{"url":"Articles/Layout/Centered.html","title":"居中","keywords":"","body":"页面居中，各种元素居中是我们开发是很常见的情况，下面就来讨论下水平居中，垂直居中以及水平加垂直居中都有哪些常见的方案。我们的目标是对齐下面这两个div: DEMO 为了看清楚，我们给父级一个浅灰的背景，子级一个深灰的背景，开始时我们什么样式都不写，是下面这样的，子级会默认给父级撑满： 水平居中 text-align + inline-block .parent{ /* text-align会对inline的子级生效，设置为center就会水平居中 */ text-align: center; } .child{ /* display设置为inline-block子级就不会撑满父级，而是自适应内容 */ display: inline-block; /* text-align会继承，child的子级也会水平居中，如果我们想恢复默认，手动写为左对齐就行了 */ text-align: left; } table + margin .parent2 { } .child2 { /* display设置为table，如果不指定宽度，宽度就是自适应内容 */ display: table; /* display如果是table，margin auto就可以生效 */ /* 如果没有设置display为table，margin auto不能生效*/ margin: 0 auto; } /* 如果知道子元素宽度，可以直接应用margin auto */ 上面这个方法适合父级元素宽度不固定，子级元素宽度也不固定的情况。如果知道子级元素的宽度就很简单了，直接应用margin auto即可： .parent2 { } .child2 { width: 100px; margin: 0 auto; } absoluate + transform .parent4 { /* 父级设置relative好让子级absolute相对于父级定位 */ position: relative; } .child4 { position: absolute; /* left 50%会让子级在正中稍微靠右一点 */ left: 50%; /* translateX百分比相对的是自身，因为前面靠右了，往左挪一点 */ /* 挪的位置刚好是自身宽的一半*/ transform: translateX(-50%); } flex + justify-content 这应该是最简单的一种方式了，直接在父级定义justify-content center就行了。 .parent5 { display: flex; justify-content: center; } .child5 { } flex + margin flex元素也可以支持margin auto, 所以可以这样写 .parent51 { display: flex; } .child51 { margin: 0 auto; } 垂直居中 table-cell + vertical-align vertical-align在table-cell里面生效，所以在给父级设置table-cell，然后vertical-align设置为middle就行了。 .parent6 { display: table-cell; vertical-align: middle; } .child6 { } absoluate + transform 与水平居中类似，父级设置为relative，子级设置为absolute，top设置为50%，这样会让位置稍微偏下一点，用transform往上挪一点。 .parent7 { position: relative; } .child7 { position: absolute; top: 50%; /* translateY百分比也是相对于元素自身计算的 */ transform: translateY(-50%); } flex + align-items 这个应该是最简单的了，直接在父级设置flex和align-items: center; .parent8 { display: flex; align-items: center; } .child8 { } 水平垂直居中 水平垂直居中直接将前面的水平居中和垂直居中结合起来就行了。 text-align + inline-block + table-cell + vertical-align .parent9 { text-align: center; display: table-cell; vertical-align: middle; } .child9 { display: inline-block; } absoluate + transform 前面水平居中，垂直居中都有absoluate + transform方案，结合起来就可以水平垂直居中了： .parent10 { position: relative; } .child10 { position: absolute; top: 50%; left: 50%; transform: translate(-50%, -50%); } flex 又看到了我们最喜欢的flex了，做居中不要太简单！ .parent11 { display: flex; justify-content: center; align-items: center; } .child11 { } "},"Articles/Layout/MultiColumns.html":{"url":"Articles/Layout/MultiColumns.html","title":"多列布局","keywords":"","body":"多列布局在一个网页设计中非常常见，不仅可以用来做外部容器的布局，在一些局部也经常出现多列布局，比如下面圈出来的都是多列布局： 定宽 + 自适应 定宽 | 自适应 我们先讲一个最简单的两列布局，左边列定宽，右边列自适应： 下面我们来看看有哪些方法可以解决这个问题： float + margin 我们有如下html代码： left right right 当我们没有给他设置样式的时候，它是这样子 我们要的是两列布局，所以我们给left加一个float:left;，然后它变成这样了： 我们看到right的内容环绕了left，这是浮动（float）的一个特性，那怎么解决呢? 因为右边环绕了左边，我们只需要将右边往右边移过去就行了: margin-left: 100px;如果左右两列还想要一点间距，margin-left设置大一点就行了。 float + overflow 这个方案和前面的float + margin的方案很像，只是解决右边环绕左边的思路不一样，我们先给左边写float:left;右边还是会环绕左边： 这次我们解决这个问题不用margin-left了，而是用overflow: 这种方案如果要间距，可以在left上设置一个margin-right: 20px;。为什么overflow:hidden可以决绝浮动环绕的问题呢，这其实用到了BFC的原理。下面我们来讲讲BFC: BFC BFC（Block Formatting Context）块级格式上下文，是Web页面中盒模型布局的CSS渲染模式，指一个独立的渲染区域或者说是一个隔离的独立容器。 下列情况都可以形成一个BFC: 1. 浮动元素，float 除 none 以外的值； 2. 定位元素，position（absolute，fixed）； 3. display 为以下其中之一的值 inline-block，table-cell，table-caption； 4. overflow 除了 visible 以外的值（hidden，auto，scroll）； BFC有如下特性： 1. 内部的Box会在垂直方向上一个接一个的放置。 2. 垂直方向上的距离由margin决定 3. bfc的区域不会与float的元素区域重叠。 4. 计算bfc的高度时，浮动元素也参与计算 5. bfc就是页面上的一个独立容器，容器里面的子元素不会影响外面元素。 上面几个特性怎么理解呢？ 如果垂直方向上有多个div，他们都有margin，那垂直的margin会合并 .child { margin-top: 10px; margin-bottom: 20px; } 上述代码两个child之间的间距是20px，而不是30px，因为垂直的margin会合并。但如果我给上面第一个child再套一个容器，使用overflow:hidden;他就成了一个BFC，根据BFC的特性，BFC的子元素不会影响外面的元素，margin就不会合并，两个child的间距就是30px; child4 child4 .child3 { margin-top: 10px; margin-bottom: 20px; } .overflow { overflow: hidden; } BFC是一个独立的容器，不会被浮动元素覆盖，里面的文字也不会环绕浮动元素，我们这里的两栏布局就是利用的这个特性。 计算BFC高度时，浮动元素的高度也会计算其中，这不就是我们用来清除浮动的一种做法吗? .parent { overflow: hidden; } table 我们还可以用table来实现，父级设置display为table，那他的宽度就是内容的宽度，所以我们需要手动指定宽度为100%。两个子级设置display为table-cell，这样他们其实就相当于table的两个单元格。由于我们要固定左边的宽度，父级table应该使用布局优先，即table-layout: fixed;。这时候如果左右两边要间距，是没法设置margin的，因为他们是单元格，但是我们可以在左边子级上设置padding-right. left4 right4 right4 .parent4 { display: table; width: 100%; table-layout: fixed; } .left4 { display: table-cell; width: 100px; padding-right: 20px } .right4 { display: table-cell; } table-layout table-layout有两个值： fixed： 是表格布局优先，列宽由表格宽度和列宽度设定，而与单元格的内容无关。这种模式下，浏览器在接收表格第一行后就可以渲染出来，速度更快。 auto: 这是默认值，表示表格内容优先，列的宽度是由列单元格中没有折行的最宽的内容设定的。此算法有时会较慢，这是由于它需要在确定最终的布局之前访问表格中所有的内容。 flex 又遇到flex了，用flex做这种布局太简单了，直接父级设置display: flex, 左子级定宽，右子级设置flex:1就行了，如果要间距，可以直接用margin。 .parent5 { display: flex; } .left5 { width: 100px; margin-right: 20px; } .right5 { flex: 1; } flex: 1 flex: 1是flex: 1 1 0的简写，对应的完全体是： { flex-grow: 1; flex-shrink: 1; flex-basis: 0; } flex-grow：设置元素的扩展比例。假如父级元素总宽度为500px, 子元素A, B, C三个元素的flex-grow分别为1, 2, 2，那他们的宽度比例为1:2:2，三个元素最终的宽度为100px, 200px, 200px; flex-shrink: 设置元素的收缩比例。假如父级元素总宽度为500px,现在有A, B, C, D, E五个子元素，他们的flex-shrink分别为1, 1, 1, 2, 2,他们的flex-basis都是120px。计算可知，五个子元素总宽度为120 * 5 = 600px，超出了父级100px，所以需要对子元素进行收缩。收缩的时候就要通过flex-shrink来计算，我们发现他们flex-shrink的总和为1 + 1 + 1 + 2 + 2 = 7。所以将超出的100px分成7份，每份约14px，然后按照flex-shrink进行收缩。A, B ,C的份数都是1，所以他们收缩14px，他们的最终宽度是120 - 14 = 106px；D, E的份数是2，所以他们应该收缩14 * 2 = 28px，最终宽度是120 - 28 = 92px。 flex-basis: 设置元素的初始值，扩展和收缩都以此为参照物。 定宽 | 定宽 | 自适应 三列布局，前面两列定宽，最后一列自适应，这个跟前面的一列定宽，一列自适应的很像，很多方案都可以直接用, 比如用float + overflow。 不定宽 + 自适应 两列布局，左边不定宽，宽度由内容决定，右边自适应的常见解决方案： 不定宽：float + overflow 跟前面定宽的写法很像，只是左边子级宽度不能写死了，要留给它的子元素决定。 不定宽：table 用table也可以实现，但是要注意，table-layout不能设置fixed了，因为左边宽度不定，我们可以不设置他，这样就是默认值auto。默认的table天生宽度就是内容决定的，左右两边如果内容一样长，那他们的长度可能是一样的，都有留白，像这样： 但是我们想要的是左边挤到内容区，留白都给右边，只需要给左边一个很小的宽度，比如width: 0.1%或者1px都行。 不定宽：flex 又是flex，跟之前定宽的很像，只需要把前面左边的宽度去掉就行了。 .parent5 { display: flex; } .left5 { margin-right: 20px; } .right5 { flex: 1; } 多列不定宽 + 自适应 多列不定宽+自适应前面几种方案都可以实现，以float + overflow为例： 等宽 等宽布局就是几个元素，每个元素的宽度是一样的，而且他们之间还可能有间距。如果没有间距，这个很好实现，每个元素宽度25%就行了，但是如果有间距，还设置25%，里面的内容就超出父容器了，就会掉下来。那应该怎么做呢？仔细看写，我们会发现他们有如下关系： C = W * N + G * (N -1); // 此处N为4 // 变换为 C = W * N + G * N - G； // 再变为 C = (W + G) * N - G; // 最后变为 C + G = (W + G) * N; C + G = (W + G) * N;对应的示意图为： 这次我们的html结构如下所示，间距是20px： 1 2 3 4 等宽：float 通过前面的公式可知，我们需要将父级拓宽一个间距，即20px，用margin-left: 20px即可实现。每个子元素左浮动，宽度为25%，同时padding-left: 20px，这个是间距，我们为了让间距是在宽度内部减出去，还需要设置box-sizing: border-box;。 .parent6 { margin-left: -20px; } .column { float: left; width: 25%; padding-left: 20px; box-sizing: border-box; } 用float的方式布局有一个不足之处，就是我们写死了25%，这个只适用于4列，如果不知道几列就不能这么写了，当然用JS动态计算不算。 等宽：table 用table就不用写死25%，因为在table-layout:fixed的情况下，列宽不是根据内容计算的，默认列宽是相等的，天生就是等宽。但是在实现的时候需要注意，我们需要在parent外面再套一个容器，因为用table肯定会把parent设置成table,宽度是100%，没办法进行拓宽，再套一个容器的目的就是给他拓宽用的。 我们思考一下，如果不在parent外面再套一层容器能不能解决？当然是能解决的，在外面再套一层容器的目的无非就是拓宽parent宽度，我们可以直接指定parent宽度为calc(100% + 20px)，这样实际的内容会靠右20px，我们再用相对定位左移20px就行了： .parent8 { display: table; width: calc(100% + 20px); table-layout: fixed; position: relative; left: -20px; } .column3 { display: table-cell; padding-left: 20px; } 等宽：flex 用flex实现这个太简单了，每个子元素都设置flex:1就行了。 等高 等高布局要实现的就是当一列高度被撑高时，另一列也会跟着被撑高。 等高：table 又是table，表格的一行里面不同的单元格天生就是等高的。 这个方案里面table-layut:fixed;可以不设置。间距用透明的border-right来做。background-clip是一个CSS3属性，表示背景要显示到的区域，有三个值： border-box: 背景被裁剪到边框盒。 padding-box: 背景被裁剪到内边距框。 content-box: 背景被裁剪到内容框。 等高：flex 万能的flex又来了，也很简单，跟前面定宽+自适应的解决方案是一样的。 这是因为flex默认的align-items就是stretch，就是拉伸到充满容器。 等高：float 前面的布局解决方案里面都有float，等高能用float解决吗？答案是可以的，但是稍微麻烦点。在前面定宽+自适应的基础上给左右子元素都写一个极大的padding-bottom，这样两个子元素的高度都很大了，然后我们用一个同样的大的负的margin-bottom和父级的overflow:hidden将高度减回来。 这样做虽然左右子元素看起来是一样高的，但是调试可以发现，他们的高度已经加了9999px，远远超过父容器了。这并不是真正意义上的等高，真正意义上的等高还是要用前面两种方案。 终极方案：Grid Grid是一个比flex还要强大的布局方案，所以我们这里把它单独拉出来讲，看看用grid怎么实现前面的需求。我们这里主要用到了grid布局的两个属性： grid-template-columns: 指定grid布局列的排列，支持绝对值（像素），百分比，auto。 grid-column-gap：列间距 定宽 | 自适应 left11 right11 right11 .parent11 { display: grid; grid-template-columns: 100px auto; grid-column-gap: 20px; } 定宽 | 定宽 | 自适应 只需要将上面的grid-template-columns改了就行了： grid-template-columns: 100px 100px auto; 等宽 还是改grid-template-columns： grid-template-columns: auto auto auto; 等高 上面的三个全部是等高的，不需要额外干什么。 总结 通过前面的几种布局，我们可以看到基本上都是用到了三个思路 float：float就是浮动，让左边元素浮动起来，但是这需要解决右边环绕左边的问题，我们用了margin和BFC两种方案来解决。在等高布局中，浮动元素的方案不是等高的，我们通过一个很大的内边距，然后一个负的外边距来进行补偿，这样虽然看起来解决了问题，但是元素的真是高度其实已经变了。 table：布局中我们用到了表格的两个特性，一个是通过table-layout来控制是布局优先还是内容优先，如果将其设置为fixed，可以将一列宽度固定，不受内容长度影响。不设置table-layout，或者设置为auto，这其实是一样的，因为他的默认值就是auto，那里面的列都是根据内容长度来自适应的，如果我们想让一列不留白，缩小到内容宽度，只需要给这一列一个很小的宽，比如0.1%或者1px就行了。我们用到的另一个特性是，表格同一列里面的单元格天生就是等高的，我们用这个来做了等高布局。 flex：flex本身就是为了布局而生的，所以他原生支持各种布局，一个flex:1就可以让他自适应剩下的空间，而且flex默认的align-items是stretch，这让他在纵轴（cross轴）上天生就是等高的。但是这是CSS3才引入的，一些老的浏览器可能不支持。 grid: grid比flex还要强大，而且可以直接做二维布局，我们这里用来做一维多列布局，也是杀鸡用牛刀了。它还有很多属性，可以参考阮一峰的教程。但是grid很新，如果需要兼容老浏览器，还是要用前面的方案。 "},"Articles/JavaScript/JavaScript.html":{"url":"Articles/JavaScript/JavaScript.html","title":"JavaScript","keywords":"","body":"本章节包括如下内容： JavaScript内存管理 函数式编程 compose函数和pipe函数 一些常用函数 浅拷贝和深拷贝 单元测试及原理 JS中的面向对象：prototype、__proto__与constructor this指向 异步和EventLoop 手写Promise/A+ Generator和async/await还有co源码 数据类型转换和检测 JS作用域 "},"Articles/JavaScript/MemoryManagement.html":{"url":"Articles/JavaScript/MemoryManagement.html","title":"JavaScript内存管理","keywords":"","body":"为什么要关注内存 如果我们有内存溢出，程序占用的内存会越来越大，最终引起客户端卡顿，甚至无响应。如果我们使用Node.js做后端应用，因为后端程序会长时间运行，如果有内存溢出，造成的后果会更严重，服务器内存可能会很快就消耗光，应用不能正常运行。 JS数据类型与JS内存机制 JS有如下数据类型 原始数据类型：String, Number, Boolean, Null, Undefined, Symbol 引用数据类型：Object 而存放这些数据的内存又可以分为两部分：栈内存（Stack）和堆内存（Heap）。原始数据类型存在栈中，引用类型存在堆中。 栈内存 栈是一种只能一端进出的数据结构，先进后出，后进先出。假如我们有如下三个变量： var a = 10; var b = 'hello'; var c = true; 根据我们的定义顺序，a会首先入栈，然后是b，最后是c。最终结构图如下所示： 我们定义一个变量是按照如下顺序进行的，以var a = 10; 为例，我们先将10放入内存，然后申明一个变量a，这时候a的值是undefined，最后进行赋值，就是将a与10关联起来。 从一个栈删除元素就是出栈，从栈顶删除，他相邻的元素成为新的栈顶元素。 堆内存 JS中原始数据类型的内存大小是固定的，由系统自动分配内存。但是引用数据类型，比如Object, Array，他们的大小不是固定的，所以是存在堆内存的。JS不允许直接操作堆内存，我们在操作对象时，操作的实际是对象的引用，而不是实际的对象。可以理解为对象在栈里面存了一个内存地址，这个地址指向了堆里面实际的对象。所以引用类型的值是一个指向堆内存的引用地址。 函数也是引用类型，当我们定义一个函数时，会在堆内存中开辟一块内存空间，将函数体代码以字符串的形式存进去。然后将这块内存的地址赋值给函数名，函数名和引用地址会存在栈上。 可以在Chrome调试工具中尝试一下，定义一个方法，然后不加括号调用，直接输出函数，可以看到，打印出来的是函数体字符串： 垃圾回收 垃圾回收就是找出那些不再继续使用的变量，然后释放其占用的内存，垃圾回收器会按照固定的时间间隔周期性执行这一操作。JS使用垃圾回收机制来自动管理内存，但是他是一把双刃剑： 优势： 可以大幅简化程序的内存管理代码，降低程序员负担，减少因为长时间运行而带来的内存泄漏问题。 劣势：程序员无法掌控内存，JS没有暴露任何关于内存的API，我们无法进行强制垃圾回收，更无法干预内存管理。 引用计数(reference counting) 引用计数是一种回收策略，它跟踪记录每个值被引用的次数，每次引用的时候加一，被释放时减一，如果一个值的引用次数变成0了，就可以将其内存空间回收。 const obj = {a: 10}; // 引用 +1 const obj1 = {a: 10}; // 引用 +1 const obj = {}; // 引用 -1 const obj1 = null; // 引用为 0 当声明了一个变量并将一个引用类型值赋值该变量时，则这个值的引用次数就是1.如果同一个值又被赋给另外一个变量，则该值得引用次数加1。相反，如果包含对这个值引用的变量又取 得了另外一个值，则这个值的引用次数减 1。当这个值的引用次数变成 0时，则说明没有办法再访问这个值了，因而就可以将其占用的内存空间回收回来。这样，当垃圾收集器下次再运行时，它就会释放那 些引用次数为零的值所占用的内存。 使用引用计数会有一个很严重的问题：循环引用。循环引用指的是对象A中包含一个指向对象B的指针，而对象B中也包含一个指向对象A的引用。 function problem(){ var objectA = {}; var objectB = {}; objectA.a = objectB; objectB.b = objectA; } 在这个例子中，objectA 和 objectB 通过各自的属性相互引用；也就是说，这两个对象的引用次数都是 2。当函数执行完毕后，objectA 和 objectB 还将继续存在，因为它们的引用次数永远不会是 0。 因为引用计数有这样的问题，现在浏览器已经不再使用这个算法了，这个算法主要存在于IE 8及以前的版本，现代浏览器更多的采用标记-清除算法。在老版的IE中一部分对象并不是原生 JavaScript 对象。例如，其 BOM 和 DOM 中的对象就是使用 C++以 COM（Component Object Model，组件对象模型）对象的形式实现的，而 COM对象的垃圾 收集机制采用的就是引用计数策略。 　　因此，即使 IE的 JavaScript引擎是使用标记清除策略来实现的，但 JavaScript访问的 COM对象依然是基于引用计数策略的。换句话说，只要在IE中涉及 COM对象，就会存在循环引用的问题。 　　下面这个简单的例子，展示了使用 COM对象导致的循环引用问题： var element = document.getElementById(\"some_element\"); var myObject = new Object(); myObject.element = element; element.someObject = myObject; 这个例子在一个 DOM元素（element）与一个原生 JavaScript对象（myObject）之间创建了循环引用。 其中，变量 myObject 有一个名为 element 的属性指向 element 对象；而变量 element 也有 一个属性名叫 someObject 回指 myObject。 由于存在这个循环引用，即使将例子中的 DOM从页面中移除，它也永远不会被回收。 为了避免类似这样的循环引用问题，最好是在不使用它们的时候手工断开原生 JavaScript 对象与 DOM元素之间的连接。例如，可以使用下面的代码消除前面例子创建的循环引用： myObject.element = null; element.someObject = null; 将变量设置为 null 意味着切断变量与它此前引用的值之间的连接。当垃圾收集器下次运行时，就会删除这些值并回收它们占用的内存。 为了解决上述问题，IE9把 BOM和 DOM对象都转换成了真正的 JavaScript对象。这样，就避免了两种垃圾收集算法并存导致的问题，也消除了常见的内存泄漏现象。 标记-清除算法 标记-清除算法就是当变量进入环境是，这个变量标记位“进入环境”；而当变量离开环境时，标记为“离开环境”，当垃圾回收时销毁那些带标记的值并回收他们的内存空间。这里说的环境就是执行环境，执行环境定义了变量或函数有权访问的数据。每个执行环境都有一个与之关联的变量对象（variable object），环境中所定义的所以变量和函数都保存在这个对象中。某个执行环境中所有代码执行完毕后，改环境被销毁，保存在其中的所有变量和函数也随之销毁。 全局执行环境 全局执行环境是最外围的一个执行环境，在浏览器中，全局环境是window，Node.js中是global对象。全局变量和函数都是作为window或者global的属性和方法创建的。全局环境只有当程序退出或者关闭网页或者浏览器的时候才会销毁。 局部执行环境(环境栈) 每个函数都有自己的执行环境。当执行流进入一个函数时，函数的环境会被推入一个环境栈中。当这个函数执行之后，栈将其环境弹出，把控制权返回给之前的环境。ECMAScript程序中的执行流就是这个机制控制的。 在一个环境中声明变量的时候，垃圾回收器将其标记为“进入环境”，当函数执行完毕时，将其标记为“离开环境”，内存被回收。 可能造成内存泄露的情况 上面我们提到了两种可能造成内存泄露的情况： 1. 对象之间的循环引用 2. 老版IE（IE8及以前）里面DOM与对象之间的循环引用 其他也可能造成循环引用的情况： 1. 全局变量会存在于整个应用生命周期，应用不退出不会回收，使用严格模式可以避免这种情况 2. 闭包因为自身特性，将函数内部变量暴露到了外部作用域，当其自身执行结束时，所暴露的变量并不会回收 3. 没有clear的定时器 V8的内存管理 V8是有内存限制的，因为它最开始是为浏览器设计的，不太可能遇到大量内存的使用场景。关键原因还是垃圾回收所导致的线程暂停执行的时间过长。根据官方说法，以1.5G内存为例，V8一次小的垃圾回收需要50ms，而一次非增量的，即全量的垃圾回收更需要一秒。这显然是不可接受的。因此V8限制了内存使用的大小，但是Node.js是可以通过配置修改的，更好的做法是使用Buffer对象，因为Buffer的内存是底层C++分配的，不占用JS内存，所以他也就不受V8限制。 V8采用了分代回收的策略，将内存分为两个生代：新生代和老生代 新生代 新生代内存中的垃圾回收主要通过 Scavenge 算法进行，具体实现时主要采用了 Cheney 算法。新生代的堆内存被分为多个Semispace，每个Semispace分为两部分from和to，只有from的空间是使用中的，分配对象空间时，只在from中进行分配，to是闲置的。进行垃圾回收时按照如下步骤进行： 1. 找出from中还在使用的对象，即存活的对象 2. 将这些活着的对象全部复制到to 3. 反转from和to，这时候from中全部是存活对象，to全部是死亡对象 4. 对to进行全部回收 可以看到在新生代中我们复制的是存活的对象，死亡对象都留在原地，最后被全部回收。这是因为对于大多数新增变量来说，可能只是用一下，很快就需要释放，那在新生代中每次回收会发现存活的是少数，死亡的是多数。那我们复制的就是少数对象，这样效率更高。如果一个变量在新生代中经过几次复制还活着，那他生命周期可能就比较长，会晋升到老生代。有两种情况会对对象进行晋升： 1. 新生代垃圾回收过程中，当一个对象经过多次复制后还存活，移动到老生代； 2. 在from和to进行反转的过程中，如果to空间的使用量超过了25%，那么from的对象全部晋升到老生代 老生代 老生代存放的是生命周期较长的对象，他的结构是一个连续的结构，不像新生代分为from和to两部分。老生代垃圾回收有两种方式，标记清除和标记合并。 标记清除 标记清除是标记死亡的对象，直接其空间释放掉。在标记清除方法清除掉死亡对象后，内存空间就变成不连续的了，所以出现了另一个方案：标记合并。 标记合并 这个方案有点像新生代的Cheney算法，将存活的对象移动到一边，将需要被回收的对象移动到另一边，然后对需要被回收的对象区域进行整体的垃圾回收。 与新生代算法相比，老生代主要操作死亡对象，因为老生代都是生命周期较长的对象，每次回收死亡的比较少；而新生代主要操作的存活对象，因为新生代都是生命周期较短的对象，每次回收存活的较少。这样无论新生代还是老生代，每次回收时都尽可能操作更少的对象，效率就提高了。 "},"Articles/JavaScript/FunctionalProgramming.html":{"url":"Articles/JavaScript/FunctionalProgramming.html","title":"函数式编程","keywords":"","body":"函数式编程 函数式编程是一种编程范式，是一种构建计算机程序结构和元素的风格，它把计算看作是对数学函数的评估，避免了状态的变化和数据的可变，与函数式编程相对的是命令式编程。我们有这样一个需求，给数组的每个数字加一： // 数组每个数字加一, 命令式编程 let arr = [1, 2, 3, 4]; let newArr = []; for(let i = 0; i 这段代码结果没有问题，但是没法重用。我们换一个思维，这里面包含的操作其实就两个，一个是遍历数组，一个是成员加一。我们把这两个方法拆出来： // 先拆加一出来 let add1 = x => x +1; // 然后拆遍历方法出来，通过遍历返回一个操作后的新数组 // fn是我们需要对每个数组想进行的操作 let createArr = (arr, fn) => { const newArr = []; for(let i = 0; i 这样拆分后，如果我们下次的需求是对数组每个元素乘以2，我们只需要写一个乘法的方法，然后复用之前的代码就行： let multiply2 = x => x * 2; // 调用之前的createArr const arr2 = [1, 2, 3, 4]; const newArr2 = createArr(arr2, multiply2); console.log(newArr2); // [2, 4, 6, 8], 结果是对的 事实上我们的加一函数只能加一，也不好复用，它还可以继续拆： // 先写一个通用加法，他接收第一个加数，返回一个方法 // 返回的这个方法接收第二个加数，第一个加数是上层方法的a // 这样当我们需要计算1+2是，就是add(1)(2) let add = (a) => { return (b) => { return a + b; } } // 我们也可以将返回的函数赋给一个变量，这个变量也就变成一个能特定加a的一个方法 let add1 = add(1); let res = add1(4); console.log(res); // 5 所以函数式编程就是将程序分解为一些更可重用、更可靠且更易于理解的部分，然后将他们组合起来，形成一个更易推理的程序整体。 纯函数 纯函数是指一个函数，如果它的调用参数相同，则永远返回相同的结果。它不依赖于程序执行期间函数外部任何状态或数据的变化，只依赖于其输入参数。同时函数的运行也不改变任何外部数据，它只通过它的返回值与外部通讯。 下面这个函数就不是纯函数，因为函数内部需要的discount需要从外部获取： let discount = 0.8; const calPrice = price => price * discount; let price = calPrice(200); // 160 // 当discount变了，calPrice传同样额参数，结果不一样，所以不纯 discount = 0.9; price = calPrice(200); // 180 要改为纯函数也很简单，将discount作为参数传递进去就行了 const calPrice = (price, discount) => price * discount; 纯函数可以保证代码的稳定性，因为相同的输入永远会得到相同结果。不纯的函数可能会带来副作用。 函数副作用 函数副作用是指调用函数时除了返回函数值之外，还对主调用函数产生附加的影响，比如修改全局变量或者外部变量，或者修改参数。这可能会带来难以查找的问题并降低代码的可读性。下面的foo就有副作用，当后面有其他地方需要使用a，可能就会拿到一个被污染的值 let a = 5; let foo = () => a = a * 10; foo(); console.log(a); // 50 除了我们自己写的函数有副作用外，一些原生API也可能有副作用，我们写代码时应该注意： 我们的目标是尽可能的减少副作用，将函数写为纯函数，下面这个不纯的函数使用了new Date，每次运行结果不一样，是不纯的： 要给为纯函数可以将依赖注入进去，所谓依赖注入就是将不纯的部分提取出来作为参数，这样我们可以让副作用代码集中在外部，远离核心代码，保证核心代码的稳定性 // 依赖注入 const foo = (d, log, something) => { const dt = d.toISOString(); return log(`${dt}: ${something}`); } const something = 'log content'; const d = new Date(); const log = console.log.bind(console); foo(d, log, something); 所以减少副作用一般的方法就是： 1. 函数使用参数进行运算，不要修改参数 2. 函数内部不修改外部变量 3. 运算结果通过返回值返回给外部 可变性和不可变性 可变性：指一个变量创建以后可以任意修改 不可变性： 指一个变量被创建后永远不会发生改变，不可变性是函数式编程的核心概念 下面是一个可变的例子： 如果我们一定要修改这个参数，我们应该将这个参数进行深拷贝后再操作，这样就不会修改参数了： "},"Articles/JavaScript/ComposePipe.html":{"url":"Articles/JavaScript/ComposePipe.html","title":"compose函数和pipe函数","keywords":"","body":"compose函数 compose函数可以将需要嵌套执行的函数平铺，嵌套执行就是一个函数的返回值将作为另一个函数的参数。我们考虑一个简单的需求： 给定一个输入值x，先给这个值加10，然后结果乘以10 这个需求很简单，直接一个计算函数就行： const calculate = x => (x + 10) * 10; let res = calculate(10); console.log(res); // 200 但是根据我们之前讲的函数式编程，我们可以将复杂的几个步骤拆成几个简单的可复用的简单步骤，于是我们拆出了一个加法函数和一个乘法函数: const add = x => x + 10; const multiply = x => x * 10; // 我们的计算改为两个函数的嵌套计算，add函数的返回值作为multiply函数的参数 let res = multiply(add(10)); console.log(res); // 结果还是200 上面的计算方法就是函数的嵌套执行，而我们compose的作用就是将嵌套执行的方法作为参数平铺，嵌套执行的时候，里面的方法也就是右边的方法最开始执行，然后往左边返回，我们的compose方法也是从右边的参数开始执行，所以我们的目标就很明确了，我们需要一个像这样的compose方法： // 参数从右往左执行，所以multiply在前，add在后 let res = compose(multiply, add)(10); 在讲这个之前我们先来看一个需要用到的函数Array.prototype.reduce Array.prototype.reduce 数组的reduce方法可以实现一个累加效果，它接收两个参数，第一个是一个累加器方法，第二个是初始化值。累加器接收四个参数，第一个是上次的计算值，第二个是数组的当前值，主要用的就是这两个参数，后面两个参数不常用，他们是当前index和当前迭代的数组： const arr = [[1, 2], [3, 4], [5, 6]]; // prevRes的初始值是传入的[]，以后会是每次迭代计算后的值 const flatArr = arr.reduce((prevRes, item) => prevRes.concat(item), []); console.log(flatArr); // [1, 2, 3, 4, 5, 6] Array.prototype.reduceRight Array.prototype.reduce会从左往右进行迭代，如果需要从右往左迭代，用Array.prototype.reduceRight就好了 const arr = [[1, 2], [3, 4], [5, 6]]; // prevRes的初始值是传入的[]，以后会是每次迭代计算后的值 const flatArr = arr.reduceRight((prevRes, item) => prevRes.concat(item), []); console.log(flatArr); // [5, 6, 3, 4, 1, 2] 那这个compose方法要怎么实现呢，这里需要借助Array.prototype.reduceRight: const compose = function(){ // 将接收的参数存到一个数组， args == [multiply, add] const args = [].slice.apply(arguments); return function(x) { return args.reduceRight((res, cb) => cb(res), x); } } // 我们来验证下这个方法 let calculate = compose(multiply, add); let res = calculate(10); console.log(res); // 结果还是200 上面的compose函数使用ES6的话会更加简洁： const compose = (...args) => x => args.reduceRight((res, cb) => cb(res), x); Redux的中间件就是用compose实现的，webpack中loader的加载顺序也是从右往左，这是因为他也是compose实现的。 pipe函数 pipe函数跟compose函数的左右是一样的，也是将参数平铺，只不过他的顺序是从左往右。我们来实现下，只需要将reduceRight改成reduce就行了： const pipe = function(){ const args = [].slice.apply(arguments); return function(x) { return args.reduce((res, cb) => cb(res), x); } } // 参数顺序改为从左往右 let calculate = pipe(add, multiply); let res = calculate(10); console.log(res); // 结果还是200 ES6写法： const pipe = (...args) => x => args.reduce((res, cb) => cb(res), x) "},"Articles/JavaScript/CommonFunctions.html":{"url":"Articles/JavaScript/CommonFunctions.html","title":"一些常用函数-数组扁平化，缓存函数，科里化函数，防抖函数，节流函数","keywords":"","body":"flat函数 - 数组扁平化 考虑我们有如下一个数组 const arr = [1, 2, [3, 4], [5, 6, [7, 8]]] 这个数组有很多层，我们现在需要将它变成一层的应该怎么做呢？结合我们前面讲过的reduce和递归我们很容易写出这个方法： const flat = (arr, initVal) => { const startVal = initVal || []; return arr.reduce((prevRes, item) => { // 如果里层还是数组，递归调用自身 if(Array.isArray(item)){ return flat(item, prevRes); }else{ return prevRes.concat(item); } }, startVal) } const arr = [1, 2, [3, 4], [5, 6, [7, 8]]]; const flatArr = flat(arr); console.log(flatArr); // [1, 2, 3, 4, 5, 6, 7, 8] 如果我们想对递归的层数进行限制，我们可以再加一个参数来进行控制： const flat = (arr, depth, initVal) => { const startVal = initVal || []; return arr.reduce((prevRes, item) => { // 如果里层还是数组，递归调用自身 if(Array.isArray(item) && depth > 1){ return flat(item, depth - 1, prevRes); }else{ return prevRes.concat(item); } }, startVal) } const arr = [1, 2, [3, 4], [5, 6, [7, 8]]]; const flatArr = flat(arr, 1); // 只扁平化一层 console.log(flatArr); 缓存函数 有时候一个复杂的计算函数需要反复运行，如果每次都对他进行计算，会浪费大量性能，我们可以用一个记忆函数来缓存计算过的值，比较典型的就是斐波拉契数列： const fibonacci = (x) => { if(x === 1 || x === 2){ return 1; } return fibonacci(x - 1) + fibonacci(x - 2); } 我们看下计算第40个数需要的时间： const startTime = new Date().getTime(); fibonacci(40); const needTime = new Date().getTime() - startTime; console.log(needTime); // 959毫秒 由于每次调fibonacci的计算过程都是一样的，所以每次用时也是一样，但算过一次后，其中很多数字我们已经计算过一次了，没有必要进行重复计算，我们可以用一个记忆方法来记住以前的结果，下次需要用的时候直接取出结果就好了： // 第一个参数是需要缓存的函数，第二个参数是用来生成缓存key的方法，如果不传就用第一个参数做key const memo = function(fn, hasher) { const memoFun = function(){ const cache = memoFun.cache; const args = [].slice.apply(arguments); const hashKey = hasher ? hasher.apply(this, arguments) : args[0]; if(!cache[hashKey]){ cache[hashKey] = fn.apply(this, arguments); } return cache[hashKey]; } memoFun.cache = {}; return memoFun; } 然后我们用memo方法包装一下fibonacci，让他具有缓存功能： const cachedfFibonacci = memo(fibonacci); // 然后看下效果 let startTime = new Date().getTime(); cachedfFibonacci(40); let needTime = new Date().getTime() - startTime; console.log(needTime); // 第一次运行时间还是959毫秒 // 再调一次 startTime = new Date().getTime(); cachedfFibonacci(40); needTime = new Date().getTime() - startTime; console.log(needTime); // 时间直接变为0了，直接取缓存，快到1毫秒都不要 柯里化函数 柯里化就是将一个接收多个参数的函数转化为一系列使用一个参数的函数的技术。实现的效果就是 const fun = (a, b, c) => {return [a, b, c]}; //上述函数经过科里化后就是 const curriedFun = curry(fun); // curriedFun的调用变为 curriedFun(a)(b)(c) 下面我们来看看curry函数应该怎么实现 // 观察上诉柯里化调用发现，它其实就是把参数都搜集起来了，每次调用搜集几个参数 // 当搜集的参数足够时执行主方法 const curry = (fn) => { // 先记录主方法原始的参数个数，fn.length就是函数接收的参数个数 const parmasLength = fn.length; return executeFun = (...args) => { // 如果接收参数够了，执行主方法 if(args.length >= parmasLength) { return fn(...args); } else { // 如果参数不够，继续接收参数 return (...args2) => { // 注意executeFun接收的参数是平铺的，需要将数组解构 return executeFun(...args.concat(args2)); } } } } // 现在看下结果 curriedFun(1)(2)(3); // [1, 2, 3] curriedFun(1, 2)(3); // [1, 2, 3] curriedFun(1, 2, 3); // [1, 2, 3] 防抖函数 我们有一个需求：实现一个搜索框，当用户连续输入的时候不发请求去搜索，只有当用户输入暂停超过500毫秒才发请求。实现这个需求就需要我们的防抖函数了，因为是等待500毫秒才发起请求，我们很容易就想到了setTimeout，如果timer存在，又触发了这个方法，就把timer清了继续等，知道方法不再触发，timer执行 // 发起请求的函数 const sendRequest = () => {}; // 防抖函数 const debounse = (fn, waitTime) => { let timer = null; return function() { const self = this; const args = [].slice.apply(arguments); if(timer){ clearTimeout(timer); } else { timer = setTimeout(() => { fn.apply(self, args); }, waitTime); } } } const debounsedSendRequest = debounse(sendRequest, 500); 节流函数 节流函数和防抖函数很像，但是针对的需求不一样，比如onScorll方法可能会触发的很频繁，我们不能每次触发的时候都去调回调，会浪费大量性能，我们可能需要每50ms调用一次，那就需要节流函数了： const scrollHandler = () => {}; const throttle = (fn, waitTime) => { let isRunnig = false; return (...args) => { if(!isRunnig) { isRunnig = true; setTimeout(() => { fn(...args); isRunnig = false; }, waitTime) } } } const throttledScrollHandler = throttle(scrollHandler, 50); "},"Articles/JavaScript/Copy.html":{"url":"Articles/JavaScript/Copy.html","title":"浅拷贝和深拷贝","keywords":"","body":"JS中有两种数据类型，值类型和引用类型，当我们需要把一个变量赋给另一个变量时，对于值类型很简单： let a = 1; let b = a; b = 10; console.log(a, b); // 1, 10 但是如果a是一个对象，这就有问题了 let a = {value: 1}; let b = a; b.value = 10; console.log(a.value, b.value); // 10, 10 我们发现改变b.value的时候，a.value的值也跟着变了，这是因为JS里面的对象是引用类型，我们在把变量a赋值给变量b的时候，赋值过去的其实是a的引用地址，b有了相同的引用地址，那a跟b指向的都是同一块内存空间，操作b的属性，其实就是操作了这块内存，因为a也指向这块内存，所以a的属性也变了。这其实就是一个浅拷贝。 浅拷贝 上面这样我们直接将一个引用变量赋值给另一个变量是一种浅拷贝，浅拷贝其实还有其他形式。这次我们需要拷贝的目标是 let target = { name: 'John', age: 20, friend: { name: 'Michel', age: 30 } } 我们可以直接遍历target对象，将它赋给一个新对象就行。 const shallowCopy = (obj) => { // 判断参数是数组还是对象 const result = Array.isArray(obj) ? [] : {}; for(let key in obj) { // 使用hasOwnProperty来判断是否是自身属性 // 只拷贝自身属性，不拷贝原型链上的属性，即继承属性 if(obj.hasOwnProperty(key)){ result[key] = obj[key]; } } return result; } 然后我们来用一下这个方法： let newObj = shallowCopy(target); newObj.age = 50; console.log(target.age, newObj.age); //20, 50 我们可以看到当我们改变newObj的属性时，原对象的属性并没有受影响，但是如果我们改变newObj.friend呢？ newObj.friend.age = 50; console.log(target.friend.age, newObj.friend.age); //50, 50 我们发现当我们改变newObj.friend的属性的时候，原对象的newObj.friend的属性也改变了，这是因为target.friend本身也是一个对象，我们拷贝的时候只拷贝了他的引用地址，所以我们通过newObj操作他的时候也改变了原来的target。 从上面可以看出我们的shallowCopy方法只拷贝了对象的一层，这也是一种浅拷贝。其实还有一些原生方法也是只拷贝一层的，比如Object.assign和...扩展运算符 let newObj = Object.assign({}, target); // 这是一层的浅拷贝 let newObj = {...target}; // 这也是一层的浅拷贝 那深拷贝应该怎么实现呢？ 深拷贝 JSON 最简单的实现方法就是用JSON.stringify先将对象转换为字符串，然后再用JSON.parse重新解析为JSON，这样新生成的对象与原对象就完全没有关系了，还是以前面的target为例： let newObj = JSON.parse(JSON.stringify(target)); newObj.friend.age = 50; console.log(target.friend.age, newObj.friend.age); //30, 50 但是我们换一个target再来试试： let target2 = { name: 'John', age: 20, drive: () => {}, girlFriend: undefined } let newObj = JSON.parse(JSON.stringify(target2)); console.log(newObj); 结果如下图，我们发现drive和girlFriend两个属性都丢了，这是因为JSON.stringify不能将方法和undefined属性转化为字符串，在转换为字符串过程中就丢了，再解析回来自然也没有了。 递归遍历 要解决上面的问题，我们还要自己动手，我们改造下上面的shallowCopy方法，让他能够递归复制。 const deepCopy = (obj) => { const result = Array.isArray(obj) ? [] : {}; for(let key in obj) { if(obj.hasOwnProperty(key)){ // 如果属性也是对象，递归调用自身 if(obj[key] && typeof obj[key] === 'object'){ result[key] = deepCopy(obj[key]) } else { result[key] = obj[key]; } } } return result; } 来看下结果： let newObj = deepCopy(target2); console.log(newObj); 这下我们的drive方法和girlFriend属性都复制过来了。 拷贝Symbol 那如果换一个带有Symbol属性的对象呢？ let target3 = { [Symbol('name')]: 'John', age: 20, drive: () => {}, girlFriend: undefined } 我们来看看结果： let newObj = deepCopy(target3); console.log(newObj); 我们发现Symbol属性丢了，那怎么办呢？这个原因是for...in...循环拿不到Symbol属性，如果要拿Symbol属性，我们可以用Object.getOwnPropertySymbols和Reflect.ownKeys。Object.getOwnPropertySymbols会返回对象的Symbol属性列表： Reflect.ownKeys会返回对象的所有自有属性，包括Symbol属性和不可枚举属性，但是不包括继承属性。所以我们的deepCopy方法改为： const deepCopy = (obj) => { const result = Array.isArray(obj) ? [] : {}; // 用 Reflect.ownKeys可以获取Symbol属性，用for...of来循环数组 for(let key of Reflect.ownKeys(obj)) { if(obj.hasOwnProperty(key)){ if(obj[key] && typeof obj[key] === 'object'){ result[key] = deepCopy(obj[key]) } else { result[key] = obj[key]; } } } return result; } 再来看看结果： let newObj = deepCopy(target3); console.log(newObj); 解决循环引用 我们来考虑一个新的目标对象 let target4 = { [Symbol('name')]: 'John', age: 20, drive: () => {}, girlFriend: undefined } target4.target = target4; 这个对象的target属性又引用了自身，所以有了循环引用，用我们之前的深拷贝方法直接会报错 要解决这个问题，我们需要每次都将引用类型的键和值都记录下来，由于Object的键不能是对象，所以我们不能用Object记录，这里采用了WeakMap来记录： const deepCopy2 = (originObj) => { // 全局只能有一个记录的map，所以里面又嵌了一个方法 const map = new WeakMap(); function dp(obj){ const result = Array.isArray(obj) ? [] : {}; const existObj = map.get(obj); // 检查map中是不是已经有这个对象了，有了就直接返回，不再递归 if(existObj){ return existObj; } // 没有就记录下来 map.set(obj, result); for(let key of Reflect.ownKeys(obj)) { if(obj.hasOwnProperty(key)){ if(obj[key] && typeof obj[key] === 'object'){ result[key] = dp(obj[key]) } else { result[key] = obj[key]; } } } return result; } return dp(originObj); } WeakMap的兼容性不是很好，如果是老浏览器不支持WeakMap，我们可以用两个数组来模拟，一个数组存键，一个数组存值，每次都只在两个数组末尾新增值，这样键和值在数组中的索引就是一样的，我们可以通过这个索引来进行键和值的匹配。 浅拷贝的应用：mixin--混合模式 直接看代码 const mixin = { // 注意：这里的say和run不能写成箭头函数，因为箭头函数拿不到正确的this say() { console.log(`${this.name}在说话`) }, run() { console.log(`${this.name}在跑步`) } } class Student{ constructor(name){ this.name = name } } Object.assign(Student.prototype, mixin); const student1 = new Student('Jhon'); student1.say(); 上面的代码我们没有用继承，而是用了拷贝的方式，让Student类具有了mixin的方法，我们直接将mixin里面的方法复制到了Student的原型链上。这种模式在很多地方都有应用，比如Vue： Vue.mixin({ data() { return { name: 'Jhon' } }, methods: { say() { console.log('hello'); } } }) new Vue({ el: '#app', data() { return { age: 16 } }, mounted() { this.say(); // hello } }) 深拷贝应用：pick函数 在underscore里面有一个pick函数，可以实现如下效果： const _ = require('underscore'); let obj = { name: 'Jhon', age: 25 } let age = _.pick(obj, 'age'); console.log(age); // {age: 25} 上述代码的输出是一个只包含age属性的新对象{age: 30}，下面让我们自己来实现一个pick函数，实现在原理很简单，把我们之前深拷贝的方法改一下就行，让他只拷贝我们需要的属性。 注意：underscore只会拷贝一层目标属性，下面我们实现的是递归的深拷贝 const pick = (originObj, property) => { const map = new WeakMap(); function dp(obj, skipEqual){ const result = Array.isArray(obj) ? [] : {}; const existObj = map.get(obj); if(existObj){ return existObj; } map.set(obj, result); for(let key of Reflect.ownKeys(obj)) { // 只需要加一个检测，看看key是不是我们需要的属性就行 if(obj.hasOwnProperty(key) && key === property || skipEqual){ // underscore不需要下面的递归，直接 result[key] = obj[key]; 就行 if(obj[key] && typeof obj[key] === 'object'){ result[key] = dp(obj[key], true) } else { result[key] = obj[key]; } } } return result; } return dp(originObj); } "},"Articles/JavaScript/UnitTest.html":{"url":"Articles/JavaScript/UnitTest.html","title":"单元测试及原理","keywords":"","body":"单元测试及原理 单元测试是指对软件中的最小可测试单元进行检查和验证，通过单元测试可以检测出潜在的bug，还可以快速反馈功能输出，验证代码是否达到预期，也可以保证代码重构的安全性。 有这样一个方法： let add = (a, b) => a + b; 这是一个很简单的计算两个数的和的方法，假如我们想看看他的逻辑对不对，我们可以调用一下，然后跟我们预期的一个值比较下，如果不符合就抛出一个错误： let add = (a, b) => a + b; let result = add(1, 2); let expect = 3; if(result !== expect){ throw new Error(`1+2应该等于${expect},实际等于${result}`) } 这其实就是单元测试的原理，但是这里写的方法太直白，而且不能复用，让我们改造下expect，把它变成一个通用方法： const expect = (res) => { return { toBe: (expectRes) => { if(res !== expectRes){ throw new Error(`期望值是${expectRes}，但实际上却是${res}!`) } } } } 我们前面期望1+2=3，这其实就是一个单元测试用例，当我们有多个用例的话，我们可以用一种更通用优雅的方式来写用例，我们来写一个通用用例方法： const test = (desc, fn) => { try{ fn(); console.log(`${desc} -> PASS`) }catch(e){ console.error(`${desc} -> FAIL`, e); } } 我们用这两个通用方法来改写下我们的单元测试： let add = (a, b) => a + b; const expect = (res) => { return { toBe: (expectRes) => { if(res !== expectRes){ throw new Error(`期望值是${expectRes}，但实际上却是${res}!`) } } } } const test = (desc, fn) => { try{ fn(); console.log(`${desc} -> PASS`) }catch(e){ console.error(`${desc} -> FAIL`, e); } } test('1+2=3', () => { expect(add(1,2)).toBe(3); // 1+2=3 -> PASS }); test('1+2=4', () => { expect(add(1,2)).toBe(4); // 1+2=4 -> FAIL Error: 期望值是4，但实际上却是3! }); 上面介绍的是单元测试的原理，事实上在我们写单元测试的时候并不需要自己写expect和test共用方法，需要用到的比对方法也远远不止toBe一个。我们可以直接用第三方库Jest，他包含了几乎所有我们需要的工具，使用方法官网都有，这里主要讲原理，使用方法不再赘述。 "},"Articles/JavaScript/myPrototype.html":{"url":"Articles/JavaScript/myPrototype.html","title":"JS中的面向对象：prototype、__proto__与constructor","keywords":"","body":"这篇文章主要讲一下JS中面向对象以及 __proto__，ptototype和constructor，这几个概念都是相关的，所以一起讲了。 在讲这个之前我们先来说说类，了解面向对象的朋友应该都知道，如果我要定义一个通用的类型我可以使用类(class)。比如在java中我们可以这样定义一个类： public class Puppy{ int puppyAge; public Puppy(age){ puppyAge = age; } public void say() { System.out.println(\"汪汪汪\"); } } 上述代码我们定义了一个Puppy类，这个类有一个属性是puppyAge，也就是小狗的年龄，然后有一个构造函数Puppy()，这个构造函数接收一个参数，可以设置小狗的年龄，另外还有一个说话的函数say。这是一个通用的类，当我们需要一个两岁的小狗实例是直接这样写，这个实例同时具有父类的方法: Puppy myPuppy = new Puppy( 2 ); myPuppy.say(); // 汪汪汪 但是早期的JS没有class关键字啊（以下说JS没有class关键字都是指ES6之前的JS，主要帮助大家理解概念），JS为了支持面向对象，使用了一种比较曲折的方式，这也是导致大家迷惑的地方，其实我们将这种方式跟一般的面向对象类比起来就很清晰了。下面我们来看看JS为了支持面向对象需要解决哪些问题，都用了什么曲折的方式来解决。 没有class，用函数代替 首先JS连class关键字都没有，怎么办呢？用函数代替，JS中最不缺的就是函数，函数不仅能够执行普通功能，还能当class使用。比如我们要用JS建一个小狗的类怎么写呢？直接写一个函数就行： function Puppy() {} 这个函数可以直接用new关键字生成实例： const myPuppy = new Puppy(); 这样我们也有了一个小狗实例，但是我们没有构造函数，不能设置小狗年龄啊。 函数本身就是构造函数 当做类用的函数本身也是一个函数，而且他就是默认的构造函数。我们想让Puppy函数能够设置实例的年龄，只要让他接收参数就行了。 function Puppy(age) { this.puppyAge = age; } // 实例化时可以传年龄参数了 const myPuppy = new Puppy(2); 注意上面代码的this，被作为类使用的函数里面this总是指向实例化对象，也就是myPuppy。这么设计的目的就是让使用者可以通过构造函数给实例对象设置属性，这时候console出来看myPuppy.puppyAge就是2。 console.log(myPuppy.puppyAge); // 输出是 2 实例方法用prototype 上面我们实现了类和构造函数，但是类方法呢？Java版小狗还可以“汪汪汪”叫呢，JS版怎么办呢？JS给出的解决方案是给方法添加一个prototype属性，挂载在这上面的方法，在实例化的时候会给到实例对象。我们想要myPuppy能说话，就需要往Puppy.prototype添加说话的方法。 Puppy.prototype.say = function() { console.log(\"汪汪汪\"); } 使用new关键字产生的实例都有类的prototype上的属性和方法，我们在Puppy.prototype上添加了say方法，myPuppy就可以说话了，我么来试一下: myPuppy.say(); // 汪汪汪 实例方法查找用__proto__ 那myPuppy怎么就能够调用say方法了呢，我们把他打印出来看下，这个对象上并没有say啊，这是从哪里来的呢？ 这就该__proto__上场了，当你访问一个对象上没有的属性时，比如myPuppy.say，对象会去__proto__查找。__proto__的值就等于父类的prototype, myPuppy.__proto__指向了Puppy.prototype。 如果你访问的属性在Puppy.prototype也不存在，那又会继续往Puppy.prototype.__proto__上找，这时候其实就找到了Object.prototype了，Object.prototype再往上找就没有了，也就是null，这其实就是原型链。 constructor 我们说的constructor一般指类的prototype.constructor。prototype.constructor是prototype上的一个保留属性，这个属性就指向类函数本身，用于指示当前类的构造函数。 既然prototype.constructor是指向构造函数的一个指针，那我们是不是可以通过它来修改构造函数呢？我们来试试就知道了。我们先修改下这个函数，然后新建一个实例看看效果： function Puppy(age) { this.puppyAge = age; } Puppy.prototype.constructor = function myConstructor(age) { this.puppyAge = age + 1; } const myPuppy2 = new Puppy(2); console.log(myPuppy2.puppyAge); // 输出是2 上例说明，我们修改prototype.constructor只是修改了这个指针而已，并没有修改真正的构造函数。 可能有的朋友会说我打印myPuppy2.constructor也有值啊，那constructor是不是也是对象本身的一个属性呢？其实不是的，之所以你能打印出这个值，是因为你打印的时候，发现myPuppy2本身并不具有这个属性，又去原型链上找了，找到了prototype.constructor。我们可以用hasOwnProperty看一下就知道了： 上面我们其实已经说清楚了prototype，__proto__，constructor几者之间的关系，下面画一张图来更直观的看下： 静态方法 我们知道很多面向对象有静态方法这个概念，比如Java直接是加一个static关键字就能将一个方法定义为静态方法。JS中定义一个静态方法更简单，直接将它作为类函数的属性就行： Puppy.statciFunc = function() { // statciFunc就是一个静态方法 console.log('我是静态方法，this拿不到实例对象'); } Puppy.statciFunc(); // 直接通过类名调用 静态方法和实例方法最主要的区别就是实例方法可以访问到实例，可以对实例进行操作，而静态方法一般用于跟实例无关的操作。这两种方法在jQuery中有大量应用，在jQuery中$(selector)其实拿到的就是实例对象，通过$(selector)进行操作的方法就是实例方法。比如$(selector).append()，这会往这个实例DOM添加新元素，他需要这个DOM实例才知道怎么操作，将append作为一个实例方法，他里面的this就会指向这个实例，就可以通过this操作DOM实例。那什么方法适合作为静态方法呢？比如$.ajax，这里的ajax跟DOM实例没关系，不需要这个this，可以直接挂载在$上作为静态方法。 继承 面向对象怎么能没有继承呢，根据前面所讲的知识，我们其实已经能够自己写一个继承了。所谓继承不就是子类能够继承父类的属性和方法吗？换句话说就是子类能够找到父类的prototype，最简单的方法就是子类原型的__proto__指向父类原型就行了。 function Parent() {} function Child() {} Child.prototype.__proto__ = Parent.prototype; const obj = new Child(); console.log(obj instanceof Child ); // true console.log(obj instanceof Parent ); // true 上述继承方法只是让Child访问到了Parent原型链，但是没有执行Parent的构造函数： function Parent() { this.parentAge = 50; } function Child() {} Child.prototype.__proto__ = Parent.prototype; const obj = new Child(); console.log(obj.parentAge); // undefined 为了解决这个问题，我们不能单纯的修改Child.prototype.__proto__指向，还需要用new执行下Parent的构造函数: function Parent() { this.parentAge = 50; } function Child() {} Child.prototype.__proto__ = new Parent(); const obj = new Child(); console.log(obj.parentAge); // 50 上述方法会多一个__proto__层级，可以换成修改Child.prototype的指向来解决，注意将Child.prototype.constructor重置回来： function Parent() { this.parentAge = 50; } function Child() {} Child.prototype = new Parent(); Child.prototype.constructor = Child; // 注意重置constructor const obj = new Child(); console.log(obj.parentAge); // 50 组合继承 上面的继承已经有了基本原理，但是并不能适合所有场景，比如构造函数接收参数的场景就不行了，所以我们改造下这个代码： function Parent(age) { this.age = age; // age从参数传进来 } function Child(age) { Parent.call(this, age); // 调用父级构造函数，设置age // 下面Child可以干自己想干的 } Child.prototype = new Parent(); Child.prototype.constructor = Child; const obj = new Child(50); console.log(obj.age); // 50 这段代码里面，我们在Child里面先调用了Parent的构造函数，让Parent的初始化也对Child生效。这个函数里面Parent的作用是设置age，因为在Child也运行了，所以Child实例上也有了age。现在我们看下obj长什么样子： 嗯，obj.age是50，符合我们的预期，但是obj.__proto__.age是从哪里来的，而且还有个值是undefined？ 寄生组合继承 上面的obj.__proto__.age其实是我们继承时运行下面这行代码来的： Child.prototype = new Parent(); 这行代码的作用是给Child.prototype设置值，但是设置的方式是执行了一次Parent的构造函数，执行Parent的构造函数构造函数自然就会运行this.age = age;，由于我们没给age传值，所以他就是undefined的。但是这种结果不是我们想要的！我们已经在Child构造函数里面调用过Parent构造函数了，已经设置了age到Child的实例上，我们不需要再来个age到实例的原型上！而且这会造成一种后果，即使我们delete obj.age，我们仍然能够在原型上访问到这个值，虽然这会儿他的值是undefined，但是仍然跟我们预期不一样。换句话说，Child继承Parent的时候，我只希望Child.prototype获取Parent.prototype上的值，而不需要Parent实例属性。要解决这个问题，我们就引入了寄生组合继承，这种继承方式跟上面的只有一行代码不一样： function Parent(age) { this.age = age; } Parent.prototype.instanceFunc = () => {} // 为了看清楚，我们给Parent加了一个实例方法，不影响继承方式 function Child(age) { Parent.call(this, age); } Child.prototype = Object.create(Parent.prototype); // 就这一行代码不一样 Child.prototype.constructor = Child; const obj = new Child(50); console.log(obj.age); // 50 上面代码就给Child.prototype赋值这一行不一样，从： Child.prototype = new Parent(); 变成了： Child.prototype = Object.create(Parent.prototype); 运行结果是一样的，但是我们把obj打印出来看看就不一样了： 我们发现obj.__proto__.age这个属性不存在了，但是Parent的实例方法instanceFunc我们还是能够访问的。这就符合我们的预期了，实现这个的关键是使用Object.create(proto)，这个方法会创建一个新的对象newObj，并让这个newObj的原型指向传入的参数proto，即： newObj.__proto__ = proto; 然后将newObj赋值给Child.prototype就实现了上述效果，这就是寄生组合继承，也是后面要说的Class关键字的实现方式。 自己实现一个new 结合上面讲的，我们知道new其实就是生成了一个对象，这个对象能够访问类的原型，知道了原理，我们就可以自己实现一个new了。 function myNew(func, ...args) { const obj = {}; // 新建一个空对象 const result = func.call(obj, ...args); // 执行构造函数 obj.__proto__ = func.prototype; // 设置原型链 // 注意如果原构造函数有Object类型的返回值，包括Functoin, Array, Date, RegExg, Error // 那么应该返回这个返回值 const isObject = typeof result === 'object' && result !== null; const isFunction = typeof result === 'function'; if(isObject || isFunction) { return result; } // 原构造函数没有Object类型的返回值，返回我们的新对象 return obj; } function Puppy(age) { this.puppyAge = age; } Puppy.prototype.say = function() { console.log(\"汪汪汪\"); } const myPuppy3 = myNew(Puppy, 2); console.log(myPuppy3.puppyAge); // 2 console.log(myPuppy3.say()); // 汪汪汪 自己实现一个instanceof 知道了原理，其实我们也知道了instanceof是干啥的。instanceof不就是检查一个对象是不是某个类的实例吗？换句话说就是检查一个对象的的原型链上有没有这个类的prototype，知道了这个我们就可以自己实现一个了： function myInstanceof(targetObj, targetClass) { // 参数检查 if(!targetObj || !targetClass || !targetObj.__proto__ || !targetClass.prototype){ return false; } let current = targetObj; while(current) { // 一直往原型链上面找 if(current.__proto__ === targetClass.prototype) { return true; // 找到了返回true } current = current.__proto__; } return false; // 没找到返回false } // 用我们前面的继承实验下 function Parent() {} function Child() {} Child.prototype.__proto__ = Parent.prototype; const obj = new Child(); console.log(myInstanceof(obj, Child) ); // true console.log(myInstanceof(obj, Parent) ); // true console.log(myInstanceof({}, Parent) ); // false ES6的class 最后还是提一嘴ES6的class，其实ES6的class就是前面说的函数类的语法糖，比如我们的Puppy用ES6的class写就是这样： class Puppy { // 构造函数 constructor(age) { this.puppyAge = age; } // 实例方法 say() { console.log(\"汪汪汪\") } // 静态方法 static statciFunc() { console.log('我是静态方法，this拿不到实例对象'); } } const myPuppy = new Puppy(2); console.log(myPuppy.puppyAge); // 2 console.log(myPuppy.say()); // 汪汪汪 console.log(Puppy.statciFunc()); // 我是静态方法，this拿不到实例对象 使用class可以让我们的代码看起来更像标准的面向对象，构造函数，实例方法，静态方法都有明确的标识。但是他本质只是改变了一种写法，所以可以看做是一种语法糖，如果你去看babel编译后的代码，你会发现他其实也是把class编译成了我们前面的函数类，extends关键字也是使用我们前面的寄生组合继承的方式实现的。 总结 最后来个总结，其实前面小节的标题就是核心了，我们再来总结下： JS中的函数可以作为函数使用，也可以作为类使用 作为类使用的函数实例化时需要使用new 为了让函数具有类的功能，函数都具有prototype属性。 为了让实例化出来的对象能够访问到prototype上的属性和方法，实例对象的__proto__指向了类的prototype。所以prototype是函数的属性，不是对象的。对象拥有的是__proto__，是用来查找prototype的。 prototype.constructor指向的是构造函数，也就是类函数本身。改变这个指针并不能改变构造函数。 对象本身并没有constructor属性，你访问到的是原型链上的prototype.constructor。 函数本身也是对象，也具有__proto__，他指向的是JS内置对象Function的原型Function.prototype。所以你才能调用func.call,func.apply这些方法，你调用的其实是Function.prototype.call和Function.prototype.apply。 prototype本身也是对象，所以他也有__proto__，指向了他父级的prototype。__proto__和prototype的这种链式指向构成了JS的原型链。原型链的最终指向是Object的原型。Object上面原型链是null，即Object.prototype.__proto__ === null。 另外要注意的是Function.__proto__ === Function.prototype，这是因为JS中所有函数的原型都是Function.prototype，也就是说所有函数都是Function的实例。Function本身也是可以作为函数使用的----Function()，所以他也是Function的一个实例。类似的还有Object，Array等，他们也可以作为函数使用:Object(), Array()。所以他们本身的原型也是Function.prototype，即Object.__proto__ === Function.prototype。换句话说，这些可以new的内置对象其实都是一个类，就像我们的Puppy类一样。 ES6的class其实是函数类的一种语法糖，书写起来更清晰，但原理是一样的。 再来看一下完整图： "},"Articles/JavaScript/this.html":{"url":"Articles/JavaScript/this.html","title":"this指向","keywords":"","body":"JS中的this是一个老生常谈的问题了，因为它并不是一个确定的值，在不同情况下有不同的指向，所以也经常使人困惑。本篇文章会谈谈我自己对this的理解。 this到底是啥 其实this就是一个指针，它指示的就是当前的一个执行环境，可以用来对当前执行环境进行一些操作。因为它指示的是执行环境，所以在定义这个变量时，其实是不知道它真正的值的，只有运行时才能确定他的值。同样一段代码，用不同的方式执行，他的this指向可能是不一样的。我们来看看如下代码： function func() { this.name = \"小小飞\"; console.log(this); // 看一下this是啥 } 这个方法很简单，只是给this添加了一个name属性，我们把这个方法复制到Chrome调试工具看下结果： 上图中我们直接调用了func()，发现this指向的是window，name属性添加到了window上。下面我们换一种调用方式，我们换成new func()来调用： 我们看到输出了两个func {name: \"小小飞\"}，一个是我们new返回的对象，另一个是方法里面的console。这两个值是一样的，说明这时候方法里面this就指向了new返回的对象，而不是前面例子的window了。这是因为当你使用new去调用一个方法时，这个方法其实就作为构造函数使用了，这时候的this指向的是new出来的对象。 下面我们分别讲解下几种情况 使用new调用时，this指向new出来的对象 这个规则其实是JS面向对象的一部分，JS使用了一种很曲折的方式来支持面向对象。当你用new来执行一个函数时，这个函数就变成了一个类，new关键字会返回一个类的实例给你，这个函数会充当构造函数的角色。作为面向对象的构造函数，必须要有能够给实例初始化属性的能力，所以构造函数里面必须要有某种机制来操作生成的实例，这种机制就是this。让this指向生成的实例就可以通过this来操作实例了。关于JS的面向对象更详细的解释可以看这篇文章。 this的这种特性还有一些妙用。一个函数可以直接调用，也可以用new调用，那假如我只想使用者通过new调用有没有办法呢？下图截取自Vue源码： Vue巧妙利用了this的特性，通过检查this是不是Vue的一个实例来检测使用者是通过new调用的还是直接调用的。 没有明确调用者时，this指向window 这个其实在最开始的例子就讲过了，那里没有明确调用者，this指向的是window。我们这里讲另外一个例子，函数里面的函数，this指向谁？ function func() { function func2() { console.log('this:', this); // 这里的this指向谁？ } func2(); } 我们执行一下看看： 直接执行： 使用new执行： 我们发现无论是直接执行，还是使用new执行，this的值都指向的window。直接执行时很好理解，因为没有明确调用者，那this自然就是window。需要注意的是使用new时，只有被new的func才是构造函数，他的this指向new出来的对象，他里面的函数的this还是指向window。 有明确调用者时，this指向调用者 看这个例子： var obj = { myName: \"小小飞\", func: function() { console.log(this.myName); } } obj.func(); // 小小飞 上述例子很好理解，因为调用者是obj，所以func里面的this就指向obj，this.myName就是obj.myName。其实这一条和上一条可以合在一起，没有明确调用者时其实隐含的调用者就是window，所以经常有人说this总是指向调用者。 下面我们将这个例子稍微改一下： var myName = \"大飞哥\"; var obj = { myName: \"小小飞\", func: function() { console.log(this.myName); } } var anotherFunc = obj.func; anotherFunc(); // 输出是啥？ 这里的输出应该是“大飞哥”，因为虽然anotherFunc的函数体跟obj.func一样，但是他的执行环境不一样，他其实没有明确的调用者，或者说调用者是window。这里的this.myName其实是window.myName，也就是“大飞哥”。 我们将这个例子再改一下： let myName = \"大飞哥\"; var obj = { myName: \"小小飞\", func: function() { console.log(this.myName); } } var anotherFunc = obj.func; anotherFunc(); // 注意这里输出是undefined 这次我们只是将第一个var改成了let，但是我们的输出却变成了undefined。这是因为let，const定义变量，即使在最外层也不会变成window的属性，只有var定义的变量才会成为window的属性。 箭头函数并不会绑定this 这句话的意思是箭头函数本身并不具有this，箭头函数在被申明确定this，这时候他会直接将当前作用域的this作为自己的this。还是之前的例子我们将函数改为箭头函数： var myName = \"大飞哥\"; var obj = { myName: \"小小飞\", func: () => { console.log(this.myName); } } var anotherFunc = obj.func; obj.func(); // 大飞哥 anotherFunc(); // 大飞哥 上述代码里面的obj.func()输出也是“大飞哥”，是因为obj在创建时申明了箭头函数，这时候箭头函数会去寻找当前作用域，因为obj是一个对象，并不是作用域，所以这里的作用域是window，this也就是window了。 再来看一个例子： var myName = \"大飞哥\"; var obj = { myName: \"小小飞\", func: function () { return { getName: () => { console.log(this.myName); } } } } var anotherFunc = obj.func().getName; obj.func().getName(); // 小小飞 anotherFunc(); // 小小飞 两个输出都是“小小飞”，obj.func().getName()输出“小小飞”很好理解，这里箭头函数是在obj.func()的返回值里申明的，这时他的this其实就是func()的this，因为他是被obj调用的，所以this指向obj。 那为什么anotherFunc()输出也是“小小飞”呢？这是因为anotherFunc()输出的this，其实在anotherFunc赋值时就确定了： var anotherFunc = obj.func().getName;其实是先执行了obj.func() 执行obj.func()的时候getName箭头函数被申明 这时候箭头函数的this应该是当前作用域的this，也就是func()里面的this func()因为是被obj调用，所以this指向obj 调用anotherFunc时，其实this早就确定了，也就是obj，最终输出的是obj.myName。 再来看一个构造函数里面的箭头函数，前面我们说了构造函数里面的函数，直接调用时，他的this指向window，但是如果这个函数时箭头函数呢： var myName = \"大飞哥\"; function func() { this.myName = \"小小飞\"; const getName = () => { console.log(this.myName); } getName(); } new func(); // 输出啥？ 这里输出的是“小小飞”，原理还是一样的，箭头函数在申明时this确定为当前作用域的this，在这里就是func的作用域，跟func的this一样指向new出来的实例。如果不用new，而是直接调用，这里的this就指向window。 DOM事件回调里面，this指向绑定事件的对象 function func(e) { console.log(this === e.currentTarget); // 总是true console.log(this === e.target); // 如果target等于currentTarget,这个就为true } const ele = document.getElementById('test'); ele.addEventListener('click', func); currentTarget指的是绑定事件的DOM对象，target指的是触发事件的对象。DOM事件回调里面this总是指向currentTarget，如果触发事件的对象刚好是绑定事件的对象，即target === currentTarget，this也会顺便指向target。如果回调是箭头函数，this是箭头函数申明时作用域的this。 严格模式下this是undefined function func() { \"use strict\" console.log(this); } func(); // 输出是undefined 注意这里说的严格模式下this是undefined是指在函数体内部，如果本身就在全局作用域，this还是指向window。 ... \"use strict\" console.log(this); // window ... this能改吗 this是能改的，call和apply都可以修改this，ES6里面还新增了一个bind函数。 使用call和apply修改this const obj = { myName: \"大飞哥\", func: function(age, gender) { console.log(`我的名字是${this.myName}, 我的年龄是${age}，我是一个${gender}`); } } const obj2 = { myName: \"小小飞\" } obj.func.call(obj2, 18, \"帅哥\"); // 我的名字是小小飞, 我的年龄是18，我是一个帅哥 注意上面输出的名字是\"小小飞\"，也就是obj2.myName。正常直接调用obj.func()输出的名字应该是obj.myName，也就是\"大飞哥\"。但是如果你使用call来调用，call的第一个参数就是手动指定的this。我们将它指定为obj2，那在函数里面的this.myName其实就是obj2.myName了。 apply方法跟call方法作用差不多，只是后面的函数参数形式不同，使用apply调用应该这样写，函数参数应该放到一个数组或者类数组里面： obj.func.apply(obj2, [18, \"帅哥\"]); // 我的名字是小小飞, 我的年龄是18，我是一个帅哥 之所以有call和apply两个方法实现了差不多的功能，是为了让大家使用方便，如果你拿到的参数是一个一个的，那就使用call吧，但是有时候拿到的参数是arguments，这是函数的一个内置变量，是一个类数组结构，表示当前函数的所有参数，那就可以直接用apply，而不用将它展开了。 使用bind修改this bind是ES5引入的一个方法，也可以修改this，但是调用它并不会立即执行方法本身，而是会返回一个修改了this的新方法： const obj = { myName: \"大飞哥\", func: function(age, gender) { console.log(`我的名字是${this.myName}, 我的年龄是${age}，我是一个${gender}`); } } const obj2 = { myName: \"小小飞\" } const func2 = obj.func.bind(obj2); // 返回一个this改为obj2的新方法 func2(18, \"帅哥\"); // 我的名字是小小飞, 我的年龄是18，我是一个帅哥 bind和call，apply最大的区别就是call，apply会立即执行方法，而bind并不会立即执行，而是会返回一个新方法供后面使用。 bind函数也可以接收多个参数，第二个及以后的参数会作为新函数的参数传递进去，比如前面的bind也可以这样写： const func3 = obj.func.bind(obj2, 18); // 注意我们这里已经传了一个年龄参数 func3(\"帅哥\"); //注意这里只传了性别参数，年龄参数已经在func3里面了，输出还是：我的名字是小小飞, 我的年龄是18，我是一个帅哥 自己写一个call 知道了call的作用，我们自己来写一个call： Function.prototype.myCall = function(...args) { // 参数检查 if(typeof this !== \"function\") { throw new Error('Must call with a function'); } const realThis = args[0] || window; const realArgs = args.slice(1); const funcSymbol = Symbol('func'); realThis[funcSymbol] = this; // 这里的this是原方法，保存到传入的第一个参数上 //用传入的参数来调方法，方法里面的this就是传入的参数了 const res = realThis[funcSymbol](...realArgs); delete realThis[funcSymbol]; // 最后删掉临时存储的原方法 return res; // 将执行的返回值返回 } 自己写一个apply apply方法跟call方法很像，区别只是在取调用参数上： Function.prototype.myApply = function(...args) { if(typeof this !== \"function\") { throw new Error('Must call with a function'); } const realThis = args[0] || window; // 直接取第二个参数，是一个数组 const realArgs = args[1]; const funcSymbol = Symbol('func'); realThis[funcSymbol] = this; const res = realThis[funcSymbol](...realArgs); delete realThis[funcSymbol]; return res; } 自己写一个bind 自己写一个bind需要用到前面的apply，注意他的返回值是一个方法 Function.prototype.myBind = function(...args) { if(typeof this !== \"function\") { throw new Error('Must call with a function'); } const _func = this; // 原方法 const realThis = args[0] || window; // 绑定的this const otherArgs = args.slice(1); // 取出后面的参数作为新函数的默认参数 return function(...args2) { // 返回一个方法 return _func.apply(realThis, [...otherArgs,...args2]); // 拼接存储参数和新参数，然后用apply执行 } } 总结 函数外面的this，即全局作用域的this指向window。 函数里面的this总是指向直接调用者。如果没有直接调用者，隐含的调用者是window。 使用new调用一个函数，这个函数即为构造函数。构造函数里面的this是和实例对象沟通的桥梁，他指向实例对象。 箭头函数里面的this在它申明时确定，跟他当前作用域的this一样。 DOM事件回调里面，this指向绑定事件的对象(currentTarget)，而不是触发事件的对象(target)。当然这两个可以是一样的。如果回调是箭头函数，请参考上一条，this是它申明时作用域的this。 严格模式下，函数里面的this指向undefined，函数外面(全局作用域)的this还是指向window。 call和apply可以改变this，这两个方法会立即执行原方法，他们的区别是参数形式不一样。 bind也可以修改this，但是他不会立即执行，而是返回一个修改了this的函数。 "},"Articles/JavaScript/AsyncAndEventLoop.html":{"url":"Articles/JavaScript/AsyncAndEventLoop.html","title":"异步和EventLoop","keywords":"","body":"笔者以前面试的时候经常遇到写一堆setTimeout,setImmediate来问哪个先执行。本文主要就是来讲这个问题的，但是不是简单的讲讲哪个先，哪个后。笼统的知道setImmediate比setTimeout(fn, 0)先执行是不够的，因为有些情况下setTimeout(fn, 0)是会比setImmediate先执行的。要彻底搞明白这个问题，我们需要系统的学习JS的异步机制和底层原理。本文就会从异步基本概念出发，一直讲到Event Loop的底层原理，让你彻底搞懂setTimeout,setImmediate，Promise, process.nextTick谁先谁后这一类问题。 同步和异步 同步异步简单理解就是，同步的代码都是按照书写顺序执行的，异步的代码可能跟书写顺序不一样，写在后面的可能先执行。下面来看个例子： const syncFunc = () => { const time = new Date().getTime(); while(true) { if(new Date().getTime() - time > 2000) { break; } } console.log(2); } console.log(1); syncFunc(); console.log(3); 上述代码会先打印出1，然后调用syncFunc，syncFunc里面while循环会运行2秒，然后打印出2，最后打印出3。所以这里代码的执行顺序跟我们的书写顺序是一致，他是同步代码： 再来看个异步例子： const asyncFunc = () => { setTimeout(() => { console.log(2); }, 2000); } console.log(1); asyncFunc(); console.log(3); 上述代码的输出是： 可以看到我们中间调用的asyncFunc里面的2却是最后输出的，这是因为setTimeout是一个异步方法。他的作用是设置一个定时器，等定时器时间到了再执行回调里面的代码。所以异步就相当于做一件事，但是并不是马上做，而是你先给别人打了个招呼，说xxx条件满足的时候就干什么什么。就像你晚上睡觉前在手机上设置了一个第二天早上7天的闹钟，就相当于给了手机一个异步事件，触发条件是时间到达早上7点。使用异步的好处是你只需要设置好异步的触发条件就可以去干别的事情了，所以异步不会阻塞主干上事件的执行。特别是对于JS这种只有一个线程的语言，如果都像我们第一个例子那样去while(true)，那浏览器就只有一直卡死了，只有等这个循环运行完才会有响应。 JS异步是怎么实现的 我们都知道JS是单线程的，那单线程是怎么实现异步的呢？事实上所谓的\"JS是单线程的\"只是指JS的主运行线程只有一个，而不是整个运行环境都是单线程。JS的运行环境主要是浏览器，以大家都很熟悉的Chrome的内核为例，他不仅是多线程的，而且是多进程的： 上图只是一个概括分类，意思是Chrome有这几类的进程和线程，并不是每种只有一个，比如渲染进程就有多个，每个选项卡都有自己的渲染进程。有时候我们使用Chrome会遇到某个选项卡崩溃或者没有响应的情况，这个选项卡对应的渲染进程可能就崩溃了，但是其他选项卡并没有用这个渲染进程，他们有自己的渲染进程，所以其他选项卡并不会受影响。这也是Chrome单个页面崩溃并不会导致浏览器崩溃的原因，而不是像老IE那样，一个页面卡了导致整个浏览器都卡。 对于前端工程师来说，主要关心的还是渲染进程，下面来分别看下里面每个线程是做什么的。 GUI线程 GUI线程就是渲染页面的，他解析HTML和CSS，然后将他们构建成DOM树和渲染树就是这个线程负责的。 JS引擎线程 这个线程就是负责执行JS的主线程，前面说的\"JS是单线程的\"就是指的这个线程。大名鼎鼎的Chrome V8引擎就是在这个线程运行的。需要注意的是，这个线程跟GUI线程是互斥的。互斥的原因是JS也可以操作DOM，如果JS线程和GUI线程同时操作DOM，结果就混乱了，不知道到底渲染哪个结果。这带来的后果就是如果JS长时间运行，GUI线程就不能执行，整个页面就感觉卡死了。所以我们最开始例子的while(true)这样长时间的同步代码在真正开发时是绝对不允许的。 定时器线程 前面异步例子的setTimeout其实就运行在这里，他跟JS主线程根本不在同一个地方，所以“单线程的JS”能够实现异步。JS的定时器方法还有setInterval，也是在这个线程。 事件触发线程 定时器线程其实只是一个计时的作用，他并不会真正执行时间到了的回调，真正执行这个回调的还是JS主线程。所以当时间到了定时器线程会将这个回调事件给到事件触发线程，然后事件触发线程将它加到事件队列里面去。最终JS主线程从事件队列取出这个回调执行。事件触发线程不仅会将定时器事件放入任务队列，其他满足条件的事件也是他负责放进任务队列。 异步HTTP请求线程 这个线程负责处理异步的ajax请求，当请求完成后，他也会通知事件触发线程，然后事件触发线程将这个事件放入事件队列给主线程执行。 所以JS异步的实现靠的就是浏览器的多线程，当他遇到异步API时，就将这个任务交给对应的线程，当这个异步API满足回调条件时，对应的线程又通过事件触发线程将这个事件放入任务队列，然后主线程从任务队列取出事件继续执行。这个流程我们多次提到了任务队列，这其实就是Event Loop，下面我们详细来讲解下。 Event Loop 所谓Event Loop，就是事件循环，其实就是JS管理事件执行的一个流程，具体的管理办法由他具体的运行环境确定。目前JS的主要运行环境有两个，浏览器和Node.js。这两个环境的Event Loop还有点区别，我们会分开来讲。 浏览器的Event Loop 事件循环就是一个循环，是各个异步线程用来通讯和协同执行的机制。各个线程为了交换消息，还有一个公用的数据区，这就是事件队列。各个异步线程执行完后，通过事件触发线程将回调事件放到事件队列，主线程每次干完手上的活儿就来看看这个队列有没有新活儿，有的话就取出来执行。画成一个流程图就是这样： 流程讲解如下: 主线程每次执行时，先看看要执行的是同步任务，还是异步的API 同步任务就继续执行，一直执行完 遇到异步API就将它交给对应的异步线程，自己继续执行同步任务 异步线程执行异步API，执行完后，将异步回调事件放入事件队列上 主线程手上的同步任务干完后就来事件队列看看有没有任务 主线程发现事件队列有任务，就取出里面的任务执行 主线程不断循环上述流程 定时器不准 Event Loop的这个流程里面其实还是隐藏了一些坑的，最典型的问题就是总是先执行同步任务，然后再执行事件队列里面的回调。这个特性就直接影响了定时器的执行，我们想想我们开始那个2秒定时器的执行流程： 主线程执行同步代码 遇到setTimeout，将它交给定时器线程 定时器线程开始计时，2秒到了通知事件触发线程 事件触发线程将定时器回调放入事件队列，异步流程到此结束 主线程如果有空，将定时器回调拿出来执行，如果没空这个回调就一直放在队列里。 上述流程我们可以看出，如果主线程长时间被阻塞，定时器回调就没机会执行，即使执行了，那时间也不准了，我们将开头那两个例子结合起来就可以看出这个效果： const syncFunc = (startTime) => { const time = new Date().getTime(); while(true) { if(new Date().getTime() - time > 5000) { break; } } const offset = new Date().getTime() - startTime; console.log(`syncFunc run, time offset: ${offset}`); } const asyncFunc = (startTime) => { setTimeout(() => { const offset = new Date().getTime() - startTime; console.log(`asyncFunc run, time offset: ${offset}`); }, 2000); } const startTime = new Date().getTime(); asyncFunc(startTime); syncFunc(startTime); 执行结果如下： 通过结果可以看出，虽然我们先调用的asyncFunc，虽然asyncFunc写的是2秒后执行，但是syncFunc的执行时间太长，达到了5秒，asyncFunc虽然在2秒的时候就已经进入了事件队列，但是主线程一直在执行同步代码，一直没空，所以也要等到5秒后，同步代码执行完毕才有机会执行这个定时器回调。所以再次强调，写代码时一定不要长时间占用主线程。 引入微任务 前面的流程图我为了便于理解，简化了事件队列，其实事件队列里面的事件还可以分两类：宏任务和微任务。微任务拥有更高的优先级，当事件循环遍历队列时，先检查微任务队列，如果里面有任务，就全部拿来执行，执行完之后再执行一个宏任务。执行每个宏任务之前都要检查下微任务队列是否有任务，如果有，优先执行微任务队列。所以完整的流程图如下： 上图需要注意以下几点： 一个Event Loop可以有一个或多个事件队列，但是只有一个微任务队列。 微任务队列全部执行完会重新渲染一次 每个宏任务执行完都会重新渲染一次 requestAnimationFrame处于渲染阶段，不在微任务队列，也不在宏任务队列 所以想要知道一个异步API在哪个阶段执行，我们得知道他是宏任务还是微任务。 常见宏任务有： script (可以理解为外层同步代码) setTimeout/setInterval setImmediate(Node.js) I/O UI事件 postMessage 常见微任务有： Promise process.nextTick(Node.js) Object.observe MutaionObserver 上面这些事件类型中要注意Promise，他是微任务，也就是说他会在定时器前面运行，我们来看个例子: console.log('1'); setTimeout(() => { console.log('2'); },0); Promise.resolve().then(() => { console.log('5'); }) new Promise((resolve) => { console.log('3'); resolve(); }).then(() => { console.log('4'); }) 上述代码的输出是1,3,5,4,2。因为： 先输出1，这个没什么说的，同步代码最先执行 console.log('2');在setTimeout里面，setTimeout是宏任务，“2”进入宏任务队列 console.log('5');在Promise.then里面，进入微任务队列 console.log('3');在Promise构造函数的参数里面，这其实是同步代码，直接输出 console.log('4');在then里面，他会进入微任务队列，检查事件队列时先执行微任务 同步代码运行结果是“1，3” 然后检查微任务队列，输出“5，4” 最后执行宏任务队列，输出“2” Node.js的Event Loop Node.js是运行在服务端的js，虽然他也用到了V8引擎，但是他的服务目的和环境不同，导致了他API与原生JS有些区别，他的Event Loop还要处理一些I/O，比如新的网络连接等，所以与浏览器Event Loop也是不一样的。Node的Event Loop是分阶段的，如下图所示： timers: 执行setTimeout和setInterval的回调 pending callbacks: 执行延迟到下一个循环迭代的 I/O 回调 idle, prepare: 仅系统内部使用 poll: 检索新的 I/O 事件;执行与 I/O 相关的回调。事实上除了其他几个阶段处理的事情，其他几乎所有的异步都在这个阶段处理。 check: setImmediate在这里执行 close callbacks: 一些关闭的回调函数，如：socket.on('close', ...) 每个阶段都有一个自己的先进先出的队列，只有当这个队列的事件执行完或者达到该阶段的上限时，才会进入下一个阶段。在每次事件循环之间，Node.js都会检查它是否在等待任何一个I/O或者定时器，如果没有的话，程序就关闭退出了。我们的直观感受就是，如果一个Node程序只有同步代码，你在控制台运行完后，他就自己退出了。 还有个需要注意的是poll阶段，他后面并不一定每次都是check阶段，poll队列执行完后，如果没有setImmediate但是有定时器到期，他会绕回去执行定时器阶段： setImmediate和setTimeout 上面的这个流程说简单点就是在一个异步流程里，setImmediate会比定时器先执行，我们写点代码来试试： console.log('outer'); setTimeout(() => { setTimeout(() => { console.log('setTimeout'); }, 0); setImmediate(() => { console.log('setImmediate'); }); }, 0); 上述代码运行如下: 和我们前面讲的一样，setImmediate先执行了。我们来理一下这个流程： 外层是一个setTimeout，所以执行他的回调的时候已经在timers阶段了 处理里面的setTimeout，因为本次循环的timers正在执行，所以他的回调其实加到了下个timers阶段 处理里面的setImmediate，将它的回调加入check阶段的队列 外层timers阶段执行完，进入pending callbacks，idle, prepare，poll，这几个队列都是空的，所以继续往下 到了check阶段，发现了setImmediate的回调，拿出来执行 然后是close callbacks，队列是空的，跳过 又是timers阶段，执行我们的console 但是请注意我们上面console.log('setTimeout')和console.log('setImmediate')都包在了一个setTimeout里面，如果直接写在最外层会怎么样呢？代码改写如下: console.log('outer'); setTimeout(() => { console.log('setTimeout'); }, 0); setImmediate(() => { console.log('setImmediate'); }); 我们来运行下看看效果： 好像是setTimeout先输出来，我们多运行几次看看: 怎么setImmediate又先出来了，这代码是见鬼了还是啥？这个世界上是没有鬼怪的，所以事情都有原因的，我们顺着之前的Event Loop再来理一下。在理之前，需要告诉大家一件事情，node.js里面setTimeout(fn, 0)会被强制改为setTimeout(fn, 1),这在官方文档中有说明。(说到这里顺便提下，HTML 5里面setTimeout最小的时间限制是4ms)。原理我们都有了，我们来理一下流程： 外层同步代码一次性全部执行完，遇到异步API就塞到对应的阶段 遇到setTimeout，虽然设置的是0毫秒触发，但是被node.js强制改为1毫秒，塞入times阶段 遇到setImmediate塞入check阶段 同步代码执行完毕，进入Event Loop 先进入times阶段，检查当前时间过去了1毫秒没有，如果过了1毫秒，满足setTimeout条件，执行回调，如果没过1毫秒，跳过 跳过空的阶段，进入check阶段，执行setImmediate回调 通过上述流程的梳理，我们发现关键就在这个1毫秒，如果同步代码执行时间较长，进入Event Loop的时候1毫秒已经过了，setTimeout执行，如果1毫秒还没到，就先执行了setImmediate。每次我们运行脚本时，机器状态可能不一样，导致运行时有1毫秒的差距，一会儿setTimeout先执行，一会儿setImmediate先执行。但是这种情况只会发生在还没进入timers阶段的时候。像我们第一个例子那样，因为已经在timers阶段，所以里面的setTimeout只能等下个循环了，所以setImmediate肯定先执行。同理的还有其他poll阶段的API也是这样的，比如： var fs = require('fs') fs.readFile(__filename, () => { setTimeout(() => { console.log('setTimeout'); }, 0); setImmediate(() => { console.log('setImmediate'); }); }); 这里setTimeout和setImmediate在readFile的回调里面，由于readFile回调是I/O操作，他本身就在poll阶段，所以他里面的定时器只能进入下个timers阶段，但是setImmediate却可以在接下来的check阶段运行，所以setImmediate肯定先运行，他运行完后，去检查timers，才会运行setTimeout。 类似的，我们再来看一段代码，如果他们两个不是在最外层，而是在setImmediate的回调里面，其实情况跟外层一样，结果也是随缘的，看下面代码: console.log('outer'); setImmediate(() => { setTimeout(() => { console.log('setTimeout'); }, 0); setImmediate(() => { console.log('setImmediate'); }); }); 原因跟写在最外层差不多，因为setImmediate已经在check阶段了，里面的循环会从timers阶段开始，会先看setTimeout的回调，如果这时候已经过了1毫秒，就执行他，如果没过就执行setImmediate。 process.nextTick() process.nextTick()是一个特殊的异步API，他不属于任何的Event Loop阶段。事实上Node在遇到这个API时，Event Loop根本就不会继续进行，会马上停下来执行process.nextTick()，这个执行完后才会继续Event Loop。我们写个例子来看下： var fs = require('fs') fs.readFile(__filename, () => { setTimeout(() => { console.log('setTimeout'); }, 0); setImmediate(() => { console.log('setImmediate'); process.nextTick(() => { console.log('nextTick 2'); }); }); process.nextTick(() => { console.log('nextTick 1'); }); }); 这段代码的打印如下： 我们还是来理一下流程: 我们代码基本都在readFile回调里面，他自己执行时，已经在poll阶段 遇到setTimeout(fn, 0)，其实是setTimeout(fn, 1)，塞入后面的timers阶段 遇到setImmediate，塞入后面的check阶段 遇到nextTick，立马执行，输出'nextTick 1' 到了check阶段，输出'setImmediate',又遇到个nextTick,立马输出'nextTick 2' 到了下个timers阶段，输出'setTimeout' 这种机制其实类似于我们前面讲的微任务，但是并不完全一样,比如同时有nextTick和Promise的时候，肯定是nextTick先执行，原因是nextTick的队列比Promise队列优先级更高。来看个例子: const promise = Promise.resolve() setImmediate(() => { console.log('setImmediate'); }); promise.then(()=>{ console.log('promise') }) process.nextTick(()=>{ console.log('nextTick') }) 代码运行结果如下： 总结 本文从异步基本概念出发一直讲到了浏览器和Node.js的Event Loop，现在我们再来总结一下： JS所谓的“单线程”只是指主线程只有一个，并不是整个运行环境都是单线程 JS的异步靠底层的多线程实现 不同的异步API对应不同的实现线程 异步线程与主线程通讯靠的是Event Loop 异步线程完成任务后将其放入任务队列 主线程不断轮询任务队列，拿出任务执行 任务队列有宏任务队列和微任务队列的区别 微任务队列的优先级更高，所有微任务处理完后才会处理宏任务 Promise是微任务 Node.js的Event Loop跟浏览器的Event Loop不一样，他是分阶段的 setImmediate和setTimeout(fn, 0)哪个回调先执行，需要看他们本身在哪个阶段注册的，如果在定时器回调或者I/O回调里面，setImmediate肯定先执行。如果在最外层或者setImmediate回调里面，哪个先执行取决于当时机器状况。 process.nextTick不在Event Loop的任何阶段，他是一个特殊API，他会立即执行，然后才会继续执行Event Loop "},"Articles/JavaScript/Promise.html":{"url":"Articles/JavaScript/Promise.html","title":"手写Promise/A+","keywords":"","body":"前段时间我用两篇文章深入讲解了异步的概念和Event Loop的底层原理，然后还讲了一种自己实现异步的发布订阅模式： setTimeout和setImmediate到底谁先执行，本文让你彻底理解Event Loop 从发布订阅模式入手读懂Node.js的EventEmitter源码 本文会讲解另一种更现代的异步实现方案：Promise。Promise几乎是面试必考点，所以我们不能仅仅会用，还得知道他的底层原理，学习他原理的最好方法就是自己也实现一个Promise。所以本文会自己实现一个遵循Promise/A+规范的Promise。实现之后，我们还要用Promise/A+官方的测试工具来测试下我们的实现是否正确，这个工具总共有872个测试用例，全部通过才算是符合Promise/A+规范，下面是他们的链接： Promise/A+规范: https://github.com/promises-aplus/promises-spec Promise/A+测试工具: https://github.com/promises-aplus/promises-tests Promise用法 Promise的基本用法，网上有很多，我这里简单提一下，我还是用三个相互依赖的网络请求做例子，假如我们有三个网络请求，请求2必须依赖请求1的结果，请求3必须依赖请求2的结果，如果用回调的话会有三层，会陷入“回调地狱”，用Promise就清晰多了: const request = require(\"request\"); // 我们先用Promise包装下三个网络请求 // 请求成功时resolve这个Promise const request1 = function() { const promise = new Promise((resolve) => { request('https://www.baidu.com', function (error, response) { if (!error && response.statusCode == 200) { resolve('request1 success'); } }); }); return promise; } const request2 = function() { const promise = new Promise((resolve) => { request('https://www.baidu.com', function (error, response) { if (!error && response.statusCode == 200) { resolve('request2 success'); } }); }); return promise; } const request3 = function() { const promise = new Promise((resolve) => { request('https://www.baidu.com', function (error, response) { if (!error && response.statusCode == 200) { resolve('request3 success'); } }); }); return promise; } // 先发起request1，等他resolve后再发起request2， // 然后是request3 request1().then((data) => { console.log(data); return request2(); }) .then((data) => { console.log(data); return request3(); }) .then((data) => { console.log(data); }) 上面的例子里面，then是可以链式调用的，后面的then可以拿到前面resolve出来的数据，我们控制台可以看到三个success依次打出来: Promises/A+规范 通过上面的例子，其实我们已经知道了一个promise长什么样子，Promises/A+规范其实就是对这个长相进一步进行了规范。下面我会对这个规范进行一些讲解。 术语 promise：是一个拥有 then 方法的对象或函数，其行为符合本规范 thenable：是一个定义了 then 方法的对象或函数。这个主要是用来兼容一些老的Promise实现，只要一个Promise实现是thenable，也就是拥有then方法的，就可以跟Promises/A+兼容。 value：指reslove出来的值，可以是任何合法的JS值(包括 undefined , thenable 和 promise等) exception：异常，在Promise里面用throw抛出来的值 reason：拒绝原因，是reject里面传的参数，表示reject的原因 Promise状态 Promise总共有三个状态: pending: 一个promise在resolve或者reject前就处于这个状态。 fulfilled: 一个promise被resolve后就处于fulfilled状态，这个状态不能再改变，而且必须拥有一个不可变的值(value)。 rejected: 一个promise被reject后就处于rejected状态，这个状态也不能再改变，而且必须拥有一个不可变的拒绝原因(reason)。 注意这里的不可变指的是===，也就是说，如果value或者reason是对象，只要保证引用不变就行，规范没有强制要求里面的属性也不变。Promise状态其实很简单，画张图就是: then方法 一个promise必须拥有一个then方法来访问他的值或者拒绝原因。then方法有两个参数： promise.then(onFulfilled, onRejected) 参数可选 onFulfilled 和 onRejected 都是可选参数。 如果 onFulfilled 不是函数，其必须被忽略 如果 onRejected 不是函数，其必须被忽略 onFulfilled 特性 如果 onFulfilled 是函数： 当 promise 执行结束后其必须被调用，其第一个参数为 promise 的终值value 在 promise 执行结束前其不可被调用 其调用次数不可超过一次 onRejected 特性 如果 onRejected 是函数： 当 promise 被拒绝执行后其必须被调用，其第一个参数为 promise 的据因reason 在 promise 被拒绝执行前其不可被调用 其调用次数不可超过一次 多次调用 then 方法可以被同一个 promise 调用多次 当 promise 成功执行时，所有 onFulfilled 需按照其注册顺序依次回调 当 promise 被拒绝执行时，所有的 onRejected 需按照其注册顺序依次回调 返回 then 方法必须返回一个 promise 对象。 promise2 = promise1.then(onFulfilled, onRejected); 如果 onFulfilled 或者 onRejected 返回一个值 x ，则运行 Promise 解决过程：[[Resolve]](promise2, x) 如果 onFulfilled 或者 onRejected 抛出一个异常 e ，则 promise2 必须拒绝执行，并返回拒因 e 如果 onFulfilled 不是函数且 promise1 成功执行， promise2 必须成功执行并返回相同的值 如果 onRejected 不是函数且 promise1 拒绝执行， promise2 必须拒绝执行并返回相同的据因 规范里面还有很大一部分是讲解Promise 解决过程的，光看规范，很空洞，前面这些规范已经可以指导我们开始写一个自己的Promise了，Promise 解决过程会在我们后面写到了再详细讲解。 自己写一个Promise 我们自己要写一个Promise，肯定需要知道有哪些工作需要做，我们先从Promise的使用来窥探下需要做啥: 新建Promise需要使用new关键字，那他肯定是作为面向对象的方式调用的，Promise是一个类。关于JS的面向对象更详细的解释可以看这篇文章。 我们new Promise(fn)的时候需要传一个函数进去，说明Promise的参数是一个函数 构造函数传进去的fn会收到resolve和reject两个函数，用来表示Promise成功和失败，说明构造函数里面还需要resolve和reject这两个函数，这两个函数的作用是改变Promise的状态。 根据规范，promise有pending，fulfilled，rejected三个状态，初始状态为pending，调用resolve会将其改为fulfilled，调用reject会改为rejected。 promise实例对象建好后可以调用then方法，而且是可以链式调用then方法，说明then是一个实例方法。链式调用的实现这篇有详细解释，我这里不再赘述。简单的说就是then方法也必须返回一个带then方法的对象，可以是this或者新的promise实例。 构造函数 为了更好的兼容性，本文就不用ES6了。 // 先定义三个常量表示状态 var PENDING = 'pending'; var FULFILLED = 'fulfilled'; var REJECTED = 'rejected'; function MyPromise(fn) { this.status = PENDING; // 初始状态为pending this.value = null; // 初始化value this.reason = null; // 初始化reason } resolve和reject方法 根据规范，resolve方法是将状态改为fulfilled，reject是将状态改为rejected。 // 这两个方法直接写在构造函数里面 function MyPromise(fn) { // ...省略前面代码... // 存一下this,以便resolve和reject里面访问 var that = this; // resolve方法参数是value function resolve(value) { if(that.status === PENDING) { that.status = FULFILLED; that.value = value; } } // reject方法参数是reason function reject(reason) { if(that.status === PENDING) { that.status = REJECTED; that.reason = reason; } } } 调用构造函数参数 最后将resolve和reject作为参数调用传进来的参数，记得加上try，如果捕获到错误就reject。 function MyPromise(fn) { // ...省略前面代码... try { fn(resolve, reject); } catch (error) { reject(error); } } then方法 根据我们前面的分析，then方法可以链式调用，所以他是实例方法，而且规范中的API是promise.then(onFulfilled, onRejected)，我们先把架子搭出来： MyPromise.prototype.then = function(onFulfilled, onRejected) {} 那then方法里面应该干什么呢，其实规范也告诉我们了，先检查onFulfilled和onRejected是不是函数，如果不是函数就忽略他们，所谓“忽略”并不是什么都不干，对于onFulfilled来说“忽略”就是将value原封不动的返回，对于onRejected来说就是返回reason，onRejected因为是错误分支，我们返回reason应该throw一个Error: MyPromise.prototype.then = function(onFulfilled, onRejected) { // 如果onFulfilled不是函数，给一个默认函数，返回value var realOnFulfilled = onFulfilled; if(typeof realOnFulfilled !== 'function') { realOnFulfilled = function (value) { return value; } } // 如果onRejected不是函数，给一个默认函数，返回reason的Error var realOnRejected = onRejected; if(typeof realOnRejected !== 'function') { realOnRejected = function (reason) { if(reason instanceof Error) { throw reason; } else { throw new Error(reason) } } } } 参数检查完后就该干点真正的事情了，想想我们使用Promise的时候，如果promise操作成功了就会调用then里面的onFulfilled，如果他失败了，就会调用onRejected。对应我们的代码就应该检查下promise的status，如果是FULFILLED，就调用onFulfilled，如果是REJECTED，就调用onRejected: MyPromise.prototype.then = function(onFulfilled, onRejected) { // ...省略前面代码... if(this.status === FULFILLED) { onFulfilled(this.value) } if(this.status === REJECTED) { onRejected(this.reason); } } 再想一下，我们新建一个promise的时候可能是直接这样用的: new Promise(fn).then(onFulfilled, onRejected); 上面代码then是在实例对象一创建好就调用了，这时候fn里面的异步操作可能还没结束呢，也就是说他的status还是PENDING，这怎么办呢，这时候我们肯定不能立即调onFulfilled或者onRejected的，因为fn到底成功还是失败还不知道呢。那什么时候知道fn成功还是失败呢？答案是fn里面主动调resolve或者reject的时候。所以如果这时候status状态还是PENDING，我们应该将onFulfilled和onRejected两个回调存起来，等到fn有了结论，resolve或者reject的时候再来调用对应的代码。因为后面then还有链式调用，会有多个onFulfilled和onRejected，我这里用两个数组将他们存起来，等resolve或者reject的时候将数组里面的全部方法拿出来执行一遍： // 构造函数 function MyPromise(fn) { // ...省略其他代码... // 构造函数里面添加两个数组存储成功和失败的回调 this.onFulfilledCallbacks = []; this.onRejectedCallbacks = []; function resolve(value) { if(that.status === PENDING) { // ...省略其他代码... // resolve里面将所有成功的回调拿出来执行 that.onFulfilledCallbacks.forEach(callback => { callback(that.value); }); } } function reject(reason) { if(that.status === PENDING) { // ...省略其他代码... // resolve里面将所有失败的回调拿出来执行 that.onRejectedCallbacks.forEach(callback => { callback(that.reason); }); } } } // then方法 MyPromise.prototype.then = function(onFulfilled, onRejected) { // ...省略其他代码... // 如果还是PENDING状态，将回调保存下来 if(this.status === PENDING) { this.onFulfilledCallbacks.push(realOnFulfilled); this.onRejectedCallbacks.push(realOnRejected); } } 上面这种暂时将回调保存下来，等条件满足的时候再拿出来运行让我想起了一种模式：订阅发布模式。我们往回调数组里面push回调函数，其实就相当于往事件中心注册事件了，resolve就相当于发布了一个成功事件，所有注册了的事件，即onFulfilledCallbacks里面的所有方法都会拿出来执行，同理reject就相当于发布了一个失败事件。更多订阅发布模式的原理可以看这里。 完成了一小步 到这里为止，其实我们已经可以实现异步调用了，只是then的返回值还没实现，还不能实现链式调用，我们先来玩一下： var request = require(\"request\"); var MyPromise = require('./MyPromise'); var promise1 = new MyPromise((resolve) => { request('https://www.baidu.com', function (error, response) { if (!error && response.statusCode == 200) { resolve('request1 success'); } }); }); promise1.then(function(value) { console.log(value); }); var promise2 = new MyPromise((resolve, reject) => { request('https://www.baidu.com', function (error, response) { if (!error && response.statusCode == 200) { reject('request2 failed'); } }); }); promise2.then(function(value) { console.log(value); }, function(reason) { console.log(reason); }); 上述代码输出如下图，符合我们的预期，说明到目前为止，我们的代码都没问题: then的返回值 根据规范then的返回值必须是一个promise，规范还定义了不同情况应该怎么处理，我们先来处理几种比较简单的情况: 如果 onFulfilled 或者 onRejected 抛出一个异常 e ，则 promise2 必须拒绝执行，并返回拒因 e。 MyPromise.prototype.then = function(onFulfilled, onRejected) { // ... 省略其他代码 ... // 有了这个要求，在RESOLVED和REJECTED的时候就不能简单的运行onFulfilled和onRejected了。 // 我们需要将他们用try...catch...包起来，如果有错就reject。 if(this.status === FULFILLED) { var promise2 = new MyPromise(function(resolve, reject) { try { realOnFulfilled(that.value); } catch (error) { reject(error); } }); return promise2; } if(this.status === REJECTED) { var promise2 = new MyPromise(function(resolve, reject) { try { realOnRejected(that.reason); } catch (error) { reject(error); } }); return promise2; } // 如果还是PENDING状态，也不能直接保存回调方法了，需要包一层来捕获错误 if(this.status === PENDING) { var promise2 = new MyPromise(function(resolve, reject) { that.onFulfilledCallbacks.push(function() { try { realOnFulfilled(that.value); } catch (error) { reject(error); } }); that.onRejectedCallbacks.push(function() { try { realOnRejected(that.reason); } catch (error) { reject(error); } }); }); return promise2; } } 如果 onFulfilled 不是函数且 promise1 成功执行， promise2 必须成功执行并返回相同的值 // 我们就根据要求加个判断，注意else里面是正常执行流程，需要resolve // 这是个例子，每个realOnFulfilled后面都要这样写 if(this.status === FULFILLED) { var promise2 = new MyPromise(function(resolve, reject) { try { if (typeof onFulfilled !== 'function') { resolve(that.value); } else { realOnFulfilled(that.value); resolve(that.value); } } catch (error) { reject(error); } }); return promise2; } 如果 onRejected 不是函数且 promise1 拒绝执行， promise2 必须拒绝执行并返回相同的据因。这个要求其实在我们检测 onRejected 不是函数的时候已经做到了，因为我们默认给的onRejected里面会throw一个Error，所以代码肯定会走到catch里面去。但是我们为了更直观，代码还是跟规范一一对应吧。需要注意的是，如果promise1的onRejected执行成功了，promise2应该被resolve。改造代码如下: if(this.status === REJECTED) { var promise2 = new MyPromise(function(resolve, reject) { try { if(typeof onRejected !== 'function') { reject(that.reason); } else { realOnRejected(that.reason); resolve(); } } catch (error) { reject(error); } }); return promise2; } 如果 onFulfilled 或者 onRejected 返回一个值 x ，则运行下面的 Promise 解决过程：[[Resolve]](promise2, x)。这条其实才是规范的第一条，因为他比较麻烦，所以我将它放到了最后。前面我们代码的实现，其实只要onRejected或者onFulfilled成功执行了，我们都要resolve promise2。多了这条，我们还需要对onRejected或者onFulfilled的返回值进行判断，如果有返回值就要进行 Promise 解决过程。我们专门写一个方法来进行Promise 解决过程。前面我们代码的实现，其实只要onRejected或者onFulfilled成功执行了，我们都要resolve promise2，这个过程我们也放到这个方法里面去吧，所以代码变为下面这样，其他地方类似： if(this.status === FULFILLED) { var promise2 = new MyPromise(function(resolve, reject) { try { if (typeof onFulfilled !== 'function') { resolve(that.value); } else { var x = realOnFulfilled(that.value); resolvePromise(promise2, x, resolve, reject); // 调用Promise 解决过程 } } catch (error) { reject(error); } }); return promise2; } Promise 解决过程 现在我们该来实现resolvePromise方法了，规范中这一部分较长，我就直接把规范作为注释写在代码里面了。 function resolvePromise(promise, x, resolve, reject) { // 如果 promise 和 x 指向同一对象，以 TypeError 为据因拒绝执行 promise // 这是为了防止死循环 if (promise === x) { return reject(new TypeError('The promise and the return value are the same')); } if (x instanceof MyPromise) { // 如果 x 为 Promise ，则使 promise 接受 x 的状态 // 也就是继续执行x，如果执行的时候拿到一个y，还要继续解析y // 这个if跟下面判断then然后拿到执行其实重复了，可有可无 x.then(function (y) { resolvePromise(promise, y, resolve, reject); }, reject); } // 如果 x 为对象或者函数 else if (typeof x === 'object' || typeof x === 'function') { // 这个坑是跑测试的时候发现的，如果x是null，应该直接resolve if (x === null) { return resolve(x); } try { // 把 x.then 赋值给 then var then = x.then; } catch (error) { // 如果取 x.then 的值时抛出错误 e ，则以 e 为据因拒绝 promise return reject(error); } // 如果 then 是函数 if (typeof then === 'function') { var called = false; // 将 x 作为函数的作用域 this 调用之 // 传递两个回调函数作为参数，第一个参数叫做 resolvePromise ，第二个参数叫做 rejectPromise // 名字重名了，我直接用匿名函数了 try { then.call( x, // 如果 resolvePromise 以值 y 为参数被调用，则运行 [[Resolve]](promise, y) function (y) { // 如果 resolvePromise 和 rejectPromise 均被调用， // 或者被同一参数调用了多次，则优先采用首次调用并忽略剩下的调用 // 实现这条需要前面加一个变量called if (called) return; called = true; resolvePromise(promise, y, resolve, reject); }, // 如果 rejectPromise 以据因 r 为参数被调用，则以据因 r 拒绝 promise function (r) { if (called) return; called = true; reject(r); }); } catch (error) { // 如果调用 then 方法抛出了异常 e： // 如果 resolvePromise 或 rejectPromise 已经被调用，则忽略之 if (called) return; // 否则以 e 为据因拒绝 promise reject(error); } } else { // 如果 then 不是函数，以 x 为参数执行 promise resolve(x); } } else { // 如果 x 不为对象或者函数，以 x 为参数执行 promise resolve(x); } } onFulfilled 和 onRejected 的执行时机 在规范中还有一条：onFulfilled 和 onRejected 只有在执行环境堆栈仅包含平台代码时才可被调用。这一条的意思是实践中要确保 onFulfilled 和 onRejected 方法异步执行，且应该在 then 方法被调用的那一轮事件循环之后的新执行栈中执行。所以在我们执行onFulfilled 和 onRejected的时候都应该包到setTimeout里面去。 // 这块代码在then里面 if(this.status === FULFILLED) { var promise2 = new MyPromise(function(resolve, reject) { // 这里加setTimeout setTimeout(function() { try { if (typeof onFulfilled !== 'function') { resolve(that.value); } else { var x = realOnFulfilled(that.value); resolvePromise(promise2, x, resolve, reject); } } catch (error) { reject(error); } }, 0); }); return promise2; } if(this.status === REJECTED) { var promise2 = new MyPromise(function(resolve, reject) { // 这里加setTimeout setTimeout(function() { try { if(typeof onRejected !== 'function') { reject(that.reason); } else { var x = realOnRejected(that.reason); resolvePromise(promise2, x, resolve, reject); } } catch (error) { reject(error); } }, 0); }); return promise2; } if (this.status === PENDING) { var promise2 = new MyPromise(function (resolve, reject) { that.onFulfilledCallbacks.push(function () { // 这里加setTimeout setTimeout(function () { try { if (typeof onFulfilled !== 'function') { resolve(that.value); } else { var x = realOnFulfilled(that.value); resolvePromise(promise2, x, resolve, reject); } } catch (error) { reject(error); } }, 0); }); that.onRejectedCallbacks.push(function () { // 这里加setTimeout setTimeout(function () { try { if (typeof onRejected !== 'function') { reject(that.reason); } else { var x = realOnRejected(that.reason); resolvePromise(promise2, x, resolve, reject); } } catch (error) { reject(error); } }, 0) }); }); return promise2; } 测试我们的Promise 我们使用Promise/A+官方的测试工具promises-aplus-tests来对我们的MyPromise进行测试，要使用这个工具我们必须实现一个静态方法deferred，官方对这个方法的定义如下: deferred: 返回一个包含{ promise, resolve, reject }的对象 ​ promise 是一个处于pending状态的promise ​ resolve(value) 用value解决上面那个promise ​ reject(reason) 用reason拒绝上面那个promise 我们实现代码如下： MyPromise.deferred = function() { var result = {}; result.promise = new MyPromise(function(resolve, reject){ result.resolve = resolve; result.reject = reject; }); return result; } 然后用npm将promises-aplus-tests下载下来，再配置下package.json就可以跑测试了: { \"devDependencies\": { \"promises-aplus-tests\": \"^2.1.2\" }, \"scripts\": { \"test\": \"promises-aplus-tests MyPromise\" } } 在跑测试的时候发现一个坑，在resolvePromise的时候，如果x是null，他的类型也是object，是应该直接用x来resolve的，之前的代码会走到catch然后reject，所以需要检测下null： // 这个坑是跑测试的时候发现的，如果x是null，应该直接resolve if(x === null) { return resolve(x); } 这个测试总共872用例，我们写的Promise完美通过了所有用例: 其他Promise方法 在ES6的官方Promise还有很多API，比如： Promise.resolve Promise.reject Promise.all Promise.race Promise.prototype.catch Promise.prototype.finally Promise.allSettled 虽然这些都不在Promise/A+里面，但是我们也来实现一下吧，加深理解。其实我们前面实现了Promise/A+再来实现这些已经是小菜一碟了，因为这个API全部是前面的封装而已。 Promise.resolve 将现有对象转为Promise对象，如果 Promise.resolve 方法的参数，不是具有 then 方法的对象（又称 thenable 对象），则返回一个新的 Promise 对象，且它的状态为fulfilled。 MyPromise.resolve = function(parameter) { if(parameter instanceof MyPromise) { return parameter; } return new MyPromise(function(resolve) { resolve(parameter); }); } Promise.reject 返回一个新的Promise实例，该实例的状态为rejected。Promise.reject方法的参数reason，会被传递给实例的回调函数。 MyPromise.reject = function(reason) { return new MyPromise(function(resolve, reject) { reject(reason); }); } Promise.all 该方法用于将多个 Promise 实例，包装成一个新的 Promise 实例。 const p = Promise.all([p1, p2, p3]); Promise.all()方法接受一个数组作为参数，p1、p2、p3都是 Promise 实例，如果不是，就会先调用Promise.resolve`方法，将参数转为 Promise 实例，再进一步处理。当p1, p2, p3全部resolve，大的promise才resolve，有任何一个reject，大的promise都reject。 MyPromise.all = function(promiseList) { var resPromise = new MyPromise(function(resolve, reject) { var count = 0; var result = []; var length = promiseList.length; if(length === 0) { return resolve(result); } promiseList.forEach(function(promise, index) { MyPromise.resolve(promise).then(function(value){ count++; result[index] = value; if(count === length) { resolve(result); } }, function(reason){ reject(reason); }); }); }); return resPromise; } Promise.race 用法: const p = Promise.race([p1, p2, p3]); 该方法同样是将多个 Promise 实例，包装成一个新的 Promise 实例。上面代码中，只要p1、p2、p3之中有一个实例率先改变状态，p的状态就跟着改变。那个率先改变的 Promise 实例的返回值，就传递给p的回调函数。 MyPromise.race = function(promiseList) { var resPromise = new MyPromise(function(resolve, reject) { var length = promiseList.length; if(length === 0) { return resolve(); } else { for(var i = 0; i Promise.prototype.catch Promise.prototype.catch方法是.then(null, rejection)或.then(undefined, rejection)的别名，用于指定发生错误时的回调函数。 MyPromise.prototype.catch = function(onRejected) { this.then(null, onRejected); } Promise.prototype.finally finally方法用于指定不管 Promise 对象最后状态如何，都会执行的操作。该方法是 ES2018 引入标准的。 MyPromise.prototype.finally = function(fn) { return this.then(function(value){ return MyPromise.resolve(value).then(function(){ return value; }); }, function(error){ return MyPromise.resolve(reason).then(function() { throw error }); }); } Promise.allSettled 该方法接受一组 Promise 实例作为参数，包装成一个新的 Promise 实例。只有等到所有这些参数实例都返回结果，不管是fulfilled还是rejected，包装实例才会结束。该方法由 ES2020 引入。该方法返回的新的 Promise 实例，一旦结束，状态总是fulfilled，不会变成rejected。状态变成fulfilled后，Promise 的监听函数接收到的参数是一个数组，每个成员对应一个传入Promise.allSettled()的 Promise 实例的执行结果。 MyPromise.allSettled = function(promiseList) { return new MyPromise(function(resolve){ var length = promiseList.length; var result = []; var count = 0; if(length === 0) { return resolve(result); } else { for(var i = 0; i 完整代码 // 先定义三个常量表示状态 var PENDING = 'pending'; var FULFILLED = 'fulfilled'; var REJECTED = 'rejected'; function MyPromise(fn) { this.status = PENDING; // 初始状态为pending this.value = null; // 初始化value this.reason = null; // 初始化reason // 构造函数里面添加两个数组存储成功和失败的回调 this.onFulfilledCallbacks = []; this.onRejectedCallbacks = []; // 存一下this,以便resolve和reject里面访问 var that = this; // resolve方法参数是value function resolve(value) { if (that.status === PENDING) { that.status = FULFILLED; that.value = value; // resolve里面将所有成功的回调拿出来执行 that.onFulfilledCallbacks.forEach(callback => { callback(that.value); }); } } // reject方法参数是reason function reject(reason) { if (that.status === PENDING) { that.status = REJECTED; that.reason = reason; // resolve里面将所有失败的回调拿出来执行 that.onRejectedCallbacks.forEach(callback => { callback(that.reason); }); } } try { fn(resolve, reject); } catch (error) { reject(error); } } function resolvePromise(promise, x, resolve, reject) { // 如果 promise 和 x 指向同一对象，以 TypeError 为据因拒绝执行 promise // 这是为了防止死循环 if (promise === x) { return reject(new TypeError('The promise and the return value are the same')); } if (x instanceof MyPromise) { // 如果 x 为 Promise ，则使 promise 接受 x 的状态 // 也就是继续执行x，如果执行的时候拿到一个y，还要继续解析y // 这个if跟下面判断then然后拿到执行其实重复了，可有可无 x.then(function (y) { resolvePromise(promise, y, resolve, reject); }, reject); } // 如果 x 为对象或者函数 else if (typeof x === 'object' || typeof x === 'function') { // 这个坑是跑测试的时候发现的，如果x是null，应该直接resolve if (x === null) { return resolve(x); } try { // 把 x.then 赋值给 then var then = x.then; } catch (error) { // 如果取 x.then 的值时抛出错误 e ，则以 e 为据因拒绝 promise return reject(error); } // 如果 then 是函数 if (typeof then === 'function') { var called = false; // 将 x 作为函数的作用域 this 调用之 // 传递两个回调函数作为参数，第一个参数叫做 resolvePromise ，第二个参数叫做 rejectPromise // 名字重名了，我直接用匿名函数了 try { then.call( x, // 如果 resolvePromise 以值 y 为参数被调用，则运行 [[Resolve]](promise, y) function (y) { // 如果 resolvePromise 和 rejectPromise 均被调用， // 或者被同一参数调用了多次，则优先采用首次调用并忽略剩下的调用 // 实现这条需要前面加一个变量called if (called) return; called = true; resolvePromise(promise, y, resolve, reject); }, // 如果 rejectPromise 以据因 r 为参数被调用，则以据因 r 拒绝 promise function (r) { if (called) return; called = true; reject(r); }); } catch (error) { // 如果调用 then 方法抛出了异常 e： // 如果 resolvePromise 或 rejectPromise 已经被调用，则忽略之 if (called) return; // 否则以 e 为据因拒绝 promise reject(error); } } else { // 如果 then 不是函数，以 x 为参数执行 promise resolve(x); } } else { // 如果 x 不为对象或者函数，以 x 为参数执行 promise resolve(x); } } MyPromise.prototype.then = function (onFulfilled, onRejected) { // 如果onFulfilled不是函数，给一个默认函数，返回value // 后面返回新promise的时候也做了onFulfilled的参数检查，这里可以删除，暂时保留是为了跟规范一一对应，看得更直观 var realOnFulfilled = onFulfilled; if (typeof realOnFulfilled !== 'function') { realOnFulfilled = function (value) { return value; } } // 如果onRejected不是函数，给一个默认函数，返回reason的Error // 后面返回新promise的时候也做了onRejected的参数检查，这里可以删除，暂时保留是为了跟规范一一对应，看得更直观 var realOnRejected = onRejected; if (typeof realOnRejected !== 'function') { realOnRejected = function (reason) { throw reason; } } var that = this; // 保存一下this if (this.status === FULFILLED) { var promise2 = new MyPromise(function (resolve, reject) { setTimeout(function () { try { if (typeof onFulfilled !== 'function') { resolve(that.value); } else { var x = realOnFulfilled(that.value); resolvePromise(promise2, x, resolve, reject); } } catch (error) { reject(error); } }, 0); }); return promise2; } if (this.status === REJECTED) { var promise2 = new MyPromise(function (resolve, reject) { setTimeout(function () { try { if (typeof onRejected !== 'function') { reject(that.reason); } else { var x = realOnRejected(that.reason); resolvePromise(promise2, x, resolve, reject); } } catch (error) { reject(error); } }, 0); }); return promise2; } // 如果还是PENDING状态，将回调保存下来 if (this.status === PENDING) { var promise2 = new MyPromise(function (resolve, reject) { that.onFulfilledCallbacks.push(function () { setTimeout(function () { try { if (typeof onFulfilled !== 'function') { resolve(that.value); } else { var x = realOnFulfilled(that.value); resolvePromise(promise2, x, resolve, reject); } } catch (error) { reject(error); } }, 0); }); that.onRejectedCallbacks.push(function () { setTimeout(function () { try { if (typeof onRejected !== 'function') { reject(that.reason); } else { var x = realOnRejected(that.reason); resolvePromise(promise2, x, resolve, reject); } } catch (error) { reject(error); } }, 0) }); }); return promise2; } } MyPromise.deferred = function () { var result = {}; result.promise = new MyPromise(function (resolve, reject) { result.resolve = resolve; result.reject = reject; }); return result; } MyPromise.resolve = function (parameter) { if (parameter instanceof MyPromise) { return parameter; } return new MyPromise(function (resolve) { resolve(parameter); }); } MyPromise.reject = function (reason) { return new MyPromise(function (resolve, reject) { reject(reason); }); } MyPromise.all = function (promiseList) { var resPromise = new MyPromise(function (resolve, reject) { var count = 0; var result = []; var length = promiseList.length; if (length === 0) { return resolve(result); } promiseList.forEach(function (promise, index) { MyPromise.resolve(promise).then(function (value) { count++; result[index] = value; if (count === length) { resolve(result); } }, function (reason) { reject(reason); }); }); }); return resPromise; } MyPromise.race = function (promiseList) { var resPromise = new MyPromise(function (resolve, reject) { var length = promiseList.length; if (length === 0) { return resolve(); } else { for (var i = 0; i 总结 至此，我们的Promise就简单实现了，只是我们不是原生代码，不能做成微任务，如果一定要做成微任务的话，只能用其他微任务API模拟，比如MutaionObserver或者process.nextTick。下面再回顾下几个要点: Promise其实是一个发布订阅模式 then方法对于还在pending的任务，其实是将回调函数onFilfilled和onRejected塞入了两个数组 Promise构造函数里面的resolve方法会将数组onFilfilledCallbacks里面的方法全部拿出来执行，这里面是之前then方法塞进去的成功回调 同理，Promise构造函数里面的reject方法会将数组onRejectedCallbacks里面的方法全部拿出来执行，这里面是之前then方法塞进去的失败回调 then方法会返回一个新的Promise以便执行链式调用 catch和finally这些实例方法都必须返回一个新的Promise实例以便实现链式调用 "},"Articles/JavaScript/Generator.html":{"url":"Articles/JavaScript/Generator.html","title":"Generator和async/await还有co源码","keywords":"","body":"这篇文章是讲JS异步原理和实现方式的第四篇文章，前面三篇是： setTimeout和setImmediate到底谁先执行，本文让你彻底理解Event Loop 从发布订阅模式入手读懂Node.js的EventEmitter源码 手写一个Promise/A+,完美通过官方872个测试用例 本文主要会讲Generator的运用和实现原理，然后我们会去读一下co模块的源码，最后还会提一下async/await。 Generator 异步编程一直是JS的核心之一，业界也是一直在探索不同的解决方法，从“回调地狱”到发布订阅模式，再到Promise，都是在优化异步编程。尽管Promise已经很优秀了，也不会陷入“回调地狱”，但是嵌套层数多了也会有一连串的then，始终不能像同步代码那样直接往下写就行了。Generator是ES6引入的进一步改善异步编程的方案，下面我们先来看看基本用法。 基本用法 Generator的中文翻译是“生成器”，其实他要干的事情也是一个生成器，一个函数如果加了*，他就会变成一个生成器函数，他的运行结果会返回一个迭代器对象，比如下面的代码： // gen是一个生成器函数 function* gen() { let a = yield 1; let b = yield a + 2; yield b + 3; } let itor = gen(); // 生成器函数运行后会返回一个迭代器对象，即itor。 next ES6规范中规定迭代器必须有一个next方法，这个方法会返回一个对象，这个对象具有done和value两个属性，done表示当前迭代器内容是否已经执行完，执行完为true，否则为false，value表示当前步骤返回的值。在generator具体运用中，每次遇到yield关键字都会暂停执行，当调用迭代器的next时，会将yield后面表达式的值作为返回对象的value，比如上面生成器的执行结果如下: 我们可以看到第一次调next返回的就是第一个yeild后面表达式的值，也就是1。需要注意的是，整个迭代器目前暂停在了第一个yield这里，给变量a赋值都没执行，要调用下一个next的时候才会给变量a赋值，然后一直执行到第二个yield。那应该给a赋什么值呢？从代码来看，a的值应该是yield语句的返回值，但是yield本身是没有返回值的，或者说返回值是undefined，如果要给a赋值需要下次调next的时候手动传进去，我们这里传一个4，4就会作为上次yield的返回值赋给a: 可以看到第二个yield后面的表达式a + 2的值是6，这是因为我们传进去的4被作为上一个yield的返回值了，然后计算a + 2自然就是6了。 我们继续next，把这个迭代器走完： 上图是接着前面运行的，图中第一个next返回的value是NaN是因为我们调next的时候没有传参数，也就是说b为undefined，undefined + 3就为NaN了 。最后一个next其实是把函数体执行完了，这时候的value应该是这个函数return的值，但是因为我们没有写return，默认就是return undefined了，执行完后done会被置为true。 throw 迭代器还有个方法是throw，这个方法可以在函数体外部抛出错误，然后在函数里面捕获，还是上面那个例子: function* gen() { let a = yield 1; let b = yield a + 2; yield b + 3; } let itor = gen(); 我们这次不用next执行了，直接throw错误出来: 这个错误因为我们没有捕获，所以直接抛到最外层来了，我们可以在函数体里面捕获他，稍微改下: function* gen() { try { let a = yield 1; let b = yield a + 2; yield b + 3; } catch (e) { console.log(e); } } let itor = gen(); 然后再来throw下： 这个图可以看出来，错误在函数里里面捕获了，走到了catch里面，这里面只有一个console同步代码，整个函数直接就运行结束了，所以done变成true了，当然catch里面可以继续写yield然后用next来执行。 return 迭代器还有个return方法，这个方法就很简单了，他会直接终止当前迭代器，将done置为true，这个方法的参数就是迭代器的value，还是上面的例子： function* gen() { let a = yield 1; let b = yield a + 2; yield b + 3; } let itor = gen(); 这次我们直接调用return: yield* 简单理解，yield*就是在生成器里面调用另一个生成器，但是他并不会占用一个next，而是直接进入被调用的生成器去运行。 function* gen() { let a = yield 1; let b = yield a + 2; } function* gen2() { yield 10 + 5; yield* gen(); } let itor = gen2(); 上面代码我们第一次调用next，值自然是10 + 5，即15，然后第二次调用next，其实就走到了yield*了，这其实就相当于调用了gen，然后执行他的第一个yield，值就是1。 协程 其实Generator就是实现了协程，协程是一个比线程还小的概念。一个进程可以有多个线程，一个线程可以有多个协程，但是一个线程同时只能有一个协程在运行。这个意思就是说如果当前协程可以执行，比如同步代码，那就执行他，如果当前协程暂时不能继续执行，比如他是一个异步读文件的操作，那就将它挂起，然后去执行其他协程，等这个协程结果回来了，可以继续了再来执行他。yield其实就相当于将当前任务挂起了，下次调用再从这里开始。协程这个概念其实很多年前就已经被提出来了，其他很多语言也有自己的实现。Generator相当于JS实现的协程。 异步应用 前面讲了Generator的基本用法，我们用它来处理一个异步事件看看。我还是使用前面文章用到过的例子，三个网络请求，请求3依赖请求2的结果，请求2依赖请求1的结果，如果使用回调是这样的: const request = require(\"request\"); function* requestGen() { function sendRequest(url) { request(url, function (error, response) { if (!error && response.statusCode == 200) { console.log(response.body); // 注意这里，引用了外部的迭代器itor itor.next(response.body); } }) } const url = 'https://www.baidu.com'; // 使用yield发起三个请求，每个请求成功后再继续调next const r1 = yield sendRequest(url); console.log('r1', r1); const r2 = yield sendRequest(url); console.log('r2', r2); const r3 = yield sendRequest(url); console.log('r3', r3); } const itor = requestGen(); // 手动调第一个next itor.next(); 我们这次使用Generator来解决“回调地狱”： const request = require(\"request\"); function* requestGen() { function sendRequest(url) { request(url, function (error, response) { if (!error && response.statusCode == 200) { console.log(response.body); // 注意这里，引用了外部的迭代器itor itor.next(response.body); } }) } const url = 'https://www.baidu.com'; // 使用yield发起三个请求，每个请求成功后再继续调next yield sendRequest(url); yield sendRequest(url); yield sendRequest(url); } const itor = requestGen(); // 手动调第一个next itor.next(); 这个例子中我们在生成器里面写了一个请求方法，这个方法会去发起网络请求，每次网络请求成功后又继续调用next执行后面的yield，最后是在外层手动调一个next触发这个流程。这其实就类似一个尾调用，这样写可以达到效果，但是在requestGen里面引用了外面的迭代器itor，耦合很高，而且不好复用。 简易实现 一下简易实现来自于异步编程二三事 | Promise/async/Generator实现原理解析 | 9k字，这个实现可以帮我们理清Generator的yield返回值用ES5怎么模拟，但是因为next不能接收参数，还是做不到后面要讲的thunk函数自动执行： // 生成器函数根据yield语句将代码分割为switch-case块，后续通过切换_context.prev和_context.next来分别执行各个case function gen$(_context) { while (1) { switch (_context.prev = _context.next) { case 0: _context.next = 2; return 'result1'; case 2: _context.next = 4; return 'result2'; case 4: _context.next = 6; return 'result3'; case 6: case \"end\": return _context.stop(); } } } // 低配版context var context = { next:0, prev: 0, done: false, stop: function stop () { this.done = true } } // 低配版invoke let gen = function() { return { next: function() { value = context.done ? undefined: gen$(context) done = context.done return { value, done } } } } // 测试使用 var g = gen() g.next() // {value: \"result1\", done: false} g.next() // {value: \"result2\", done: false} g.next() // {value: \"result3\", done: false} g.next() // {value: undefined, done: true} thunk函数 为了解决前面说的耦合高，不好复用的问题，就有了thunk函数。thunk函数理解起来有点绕，我先把代码写出来，然后再一步一步来分析它的执行顺序： function Thunk(fn) { return function(...args) { return function(callback) { return fn.call(this, ...args, callback) } } } function run(fn) { let gen = fn(); function next(err, data) { let result = gen.next(data); if(result.done) return; result.value(next); } next(); } // 使用thunk方法 const request = require(\"request\"); const requestThunk = Thunk(request); function* requestGen() { const url = 'https://www.baidu.com'; let r1 = yield requestThunk(url); console.log(r1.body); let r2 = yield requestThunk(url); console.log(r2.body); let r3 = yield requestThunk(url); console.log(r3.body); } // 启动运行 run(requestGen); 这段代码里面的Thunk函数返回了好几层函数，我们从他的使用入手一层一层剥开看： requestThunk是Thunk运行的返回值，也就是第一层返回值，参数是request，也就是: function(...args) { return function(callback) { return request.call(this, ...args, callback); // 注意这里调用的是request } } run函数的参数是生成器，我们看看他到底干了啥: run里面先调用生成器，拿到迭代器gen，然后自定义了一个next方法，并调用这个next方法，为了便于区分，我这里称这个自定义的next为局部next 局部next会调用生成器的next，生成器的next其实就是yield requestThunk(url)，参数是我们传进去的url，这就调到我们前面的那个方法，这个yield返回的value其实是： function(callback) { return request.call(this, url, callback); } 检测迭代器是否已经迭代完毕，如果没有，就继续调用第二步的这个函数，这个函数其实才真正的去request，这时候传进去的参数是局部next，局部next也作为了request的回调函数。 这个回调函数在执行时又会调gen.next，这样生成器就可以继续往下执行了，同时gen.next的参数是回调函数的data，这样，生成器里面的r1其实就拿到了请求的返回值。 Thunk函数就是这样一种可以自动执行Generator的函数，因为Thunk函数的包装，我们在Generator里面可以像同步代码那样直接拿到yield异步代码的返回值。 co模块 co模块是一个很受欢迎的模块，他也可以自动执行Generator，他的yield后面支持thunk和Promise，我们先来看看他的基本使用，然后再去分析下他的源码。 官方GitHub：https://github.com/tj/co 基本使用 支持thunk 前面我们讲了thunk函数，我们还是从thunk函数开始。代码还是用我们前面写的thunk函数，但是因为co支持的thunk是只接收回调函数的函数形式，我们使用时需要调整下: // 还是之前的thunk函数 function Thunk(fn) { return function(...args) { return function(callback) { return fn.call(this, ...args, callback) } } } // 将我们需要的request转换成thunk const request = require('request'); const requestThunk = Thunk(request); // 转换后的requestThunk其实可以直接用了 // 用法就是 requestThunk(url)(callback) // 但是我们co接收的thunk是 fn(callback)形式 // 我们转换一下 // 这时候的baiduRequest也是一个函数，url已经传好了，他只需要一个回调函数做参数就行 // 使用就是这样：baiduRequest(callback) const baiduRequest = requestThunk('https://www.baidu.com'); // 引入co执行, co的参数是一个Generator // co的返回值是一个Promise，我们可以用then拿到他的结果 const co = require('co'); co(function* () { const r1 = yield baiduRequest; const r2 = yield baiduRequest; const r3 = yield baiduRequest; return { r1, r2, r3, } }).then((res) => { // then里面就可以直接拿到前面返回的{r1, r2, r3} console.log(res); }); 支持Promise 其实co官方是建议yield后面跟Promise的，虽然支持thunk，但是未来可能会移除。使用Promise，我们代码写起来其实更简单，直接用fetch就行，不用包装Thunk。 const fetch = require('node-fetch'); const co = require('co'); co(function* () { // 直接用fetch，简单多了，fetch返回的就是Promise const r1 = yield fetch('https://www.baidu.com'); const r2 = yield fetch('https://www.baidu.com'); const r3 = yield fetch('https://www.baidu.com'); return { r1, r2, r3, } }).then((res) => { // 这里同样可以拿到{r1, r2, r3} console.log(res); }); 源码分析 本文的源码分析基于co模块4.6.0版本，源码：https://github.com/tj/co/blob/master/index.js 仔细看源码会发现他代码并不多，总共两百多行，一半都是在进行yield后面的参数检测和处理，检测他是不是Promise，如果不是就转换为Promise，所以即使你yield后面传的thunk，他还是会转换成Promise处理。转换Promise的代码相对比较独立和简单，我这里不详细展开了，这里主要还是讲一讲核心方法co(gen)。下面是我复制的去掉了注释的简化代码: function co(gen) { var ctx = this; var args = slice.call(arguments, 1); return new Promise(function(resolve, reject) { if (typeof gen === 'function') gen = gen.apply(ctx, args); if (!gen || typeof gen.next !== 'function') return resolve(gen); onFulfilled(); function onFulfilled(res) { var ret; try { ret = gen.next(res); } catch (e) { return reject(e); } next(ret); return null; } function onRejected(err) { var ret; try { ret = gen.throw(err); } catch (e) { return reject(e); } next(ret); } function next(ret) { if (ret.done) return resolve(ret.value); var value = toPromise.call(ctx, ret.value); if (value && isPromise(value)) return value.then(onFulfilled, onRejected); return onRejected(new TypeError('You may only yield a function, promise, generator, array, or object, ' + 'but the following object was passed: \"' + String(ret.value) + '\"')); } }); } 从整体结构看，co的参数是一个Generator，返回值是一个Promise，几乎所有逻辑代码都在这个Promise里面，这也是我们使用时用then拿结果的原因。 Promise里面先把Generator拿出来执行，得到一个迭代器gen 手动调用一次onFulfilled，开启迭代 onFulfilled接收一个参数res，第一次调用是没有传这个参数，这个参数主要是用来接收后面的then返回的结果。 然后调用gen.next，注意这个的返回值ret的形式是{value, done}，然后将这个ret传给局部的next 然后执行局部next，他接收的参数是yield返回值{value, done} 这里先检测迭代是否完成，如果完成了，就直接将整个promise resolve。 这里的value是yield后面表达式的值，可能是thunk，也可能是promise 将value转换成promise 将转换后的promise拿出来执行，成功的回调是前面的onFulfilled 我们再来看下onFulfilled，这是第二次执行onFulfilled了。这次执行的时候传入的参数res是上次异步promise的执行结果，对应我们的fetch就是拿回来的数据，这个数据传给第二个gen.next，效果就是我们代码里面的赋值给了第一个yield前面的变量r1。然后继续局部next，这个next其实就是执行第二个异步Promise了。这个promise的成功回调又继续调用gen.next，这样就不断的执行下去，直到done变成true为止。 最后看一眼onRejected方法，这个方法其实作为了异步promise的错误分支，这个函数里面直接调用了gen.throw，这样我们在Generator里面可以直接用try...catch...拿到错误。需要注意的是gen.throw后面还继续调用了next(ret)，这是因为在Generator的catch分支里面还可能继续有yield，比如错误上报的网络请求，这时候的迭代器并不一定结束了。 async/await 最后提一下async/await，先来看一下用法: const fetch = require('node-fetch'); async function sendRequest () { const r1 = await fetch('https://www.baidu.com'); const r2 = await fetch('https://www.baidu.com'); const r3 = await fetch('https://www.baidu.com'); return { r1, r2, r3, } } // 注意async返回的也是一个promise sendRequest().then((res) => { console.log('res', res); }); 咋一看这个跟前面promise版的co是不是很像，返回值都是一个promise，只是Generator换成了一个async函数，函数里面的yield换成了await，而且外层不需要co来包裹也可以自动执行了。其实async函数就是Generator加自动执行器的语法糖，可以理解为从语言层面支持了Generator的自动执行。上面这段代码跟co版的promise其实就是等价的。 总结 Generator是一种更现代的异步解决方案，在JS语言层面支持了协程 Generator的返回值是一个迭代器 这个迭代器需要手动调next才能一条一条执行yield next的返回值是{value, done}，value是yield后面表达式的值 yield语句本身并没有返回值，下次调next的参数会作为上一个yield语句的返回值 Generator自己不能自动执行，要自动执行需要引入其他方案，前面讲thunk的时候提供了一种方案，co模块也是一个很受欢迎的自动执行方案 这两个方案的思路有点类似，都是先写一个局部的方法，这个方法会去调用gen.next，同时这个方法本身又会传到回调函数或者promise的成功分支里面，异步结束后又继续调用这个局部方法，这个局部方法又调用gen.next，这样一直迭代，直到迭代器执行完毕。 async/await其实是Generator和自动执行器的语法糖，写法和实现原理都类似co模块的promise模式。 "},"Articles/JavaScript/Types.html":{"url":"Articles/JavaScript/Types.html","title":"数据类型转换和检测","keywords":"","body":"JS有很多数据类型，对于不同数据类型的识别和相互转换也是面试中的一个常考点，本文主要讲的就是类型转换和类型检测。 数据类型 JS中的数据类型主要分为两大类：原始类型(值类型)和引用类型。常见的数据类型如下图所示： 原始数据类型存在栈中，引用类型在栈中存的是一个引用地址，这个地址指向的是堆中的一个数据对象。需要注意的是null在这里我们算在原始类型里面，但是你用typeof的时候会发现他是object，原因是就算他是一个对象，那他应该在栈中存一个引用地址，但是他是一个空对象，所以这个地址为空，也就是不对应堆中的任意一个数据，他在堆中没有数据，只存在于栈中，所以这里算为了原始类型。引用类型其实主要就是Object，Array和Function这些其实也都是Object派生出来的。关于这两种类型在内存中的更详细的知识可以看这篇文章。 下面我们来看看这两种类型的区别： 原始类型 原始类型的值无法更改，要更改只能重新赋值。像下面这样尝试去修改是不行的，但是整个重新赋值可以。 原始类型的比较就是比较值，值相等，他们就相等 引用类型 引用类型的值是可以修改的，注意这个时候我们虽然修改了a里面的属性，但是a在栈上的引用地址并没有变化，变化的是堆中的数据。 引用类型的比较是比较他们的索引地址，而不是他们的值。比如下面两个对象，看着是一样的，但是他们的引用地址不一样，其实是不等的： 要想让他们相等，得直接将b赋值为a，这样他们的引用地址一样，就是相等的。 类型转换 JS中当不同类型的数据进行计算的时候会进行类型转换，比如下面的例子： 上面的例子中，我们用了加减来操作几个非数字的类型，这时候JS会进行隐式的类型转换，然后再进行加减运算。除了JS本身的隐式转换外，有时候我们还会主动进行类型转换，这就算是显示类型转换了。 隐式类型转换 转为字符串 经常出现在+运算中，并且其中有一个操作数不是数值类型 let s = 4 + 'px' + 5; console.log(s); // 4px5 s = 123e-2 + 'a'; console.log(s); // 1.23a 转为数值 经常出现在数学运算中，表示连接字符串的+运算除外 let s = 'abc'; console.log(+s, -s); // NaN, NaN s = ' 123 '; console.log(+s, -s); // 123 -123 s = new Date(); console.log(+s, -s); // 1588675647421 -1588675647421 (这个操作相当于取毫秒数) 转为bool的场景 经常出现在if或者逻辑运算中 let s = 'abc'; if(s) { console.log(s); // abc } console.log(!!s); // true 下面的值在进行bool转换时会转换为false，除此以外都是true: 0 NaN ''(空字符串) null undefined ==运算符 当我们使用==进行比较时，如果两边的类型不同，JS会进行类型转换，然后再比较，===则不会进行类型转换，如果===两边的数据类型不同，直接返回false。 上面只是列举了其中几种情况，更多的情况可以参考下面这种表，这个表来自于MDN。这个表的内容比较多，有些是规范直接定义的，比如null == undefined，也没有太多逻辑可言。我们不确定时可以来查下这个表，但是实际开发中其实是不建议使用==的，因为如果你把这个转换关系记错了的话可能就会引入比较难排查的bug，一般推荐直接使用===。 转换规则 下面这几张表是一些转换规则，来自于《JS权威指南》: 显式类型转换 显式类型转换是我们自己写代码明确转换的类型，可以使代码看起来更清晰，是实际开发时推荐的做法。 转字符串 显式转换为字符串可以使用toString方法，它的执行结果通常和String()方法一致。Number类型的toString方法还支持参数，可以指定需要转换的进制。下面的图是一些原始类型的toString()，null和undefined没有toString方法，调用会报错: Number类型的toString方法支持进制: 转数值 转为数值就很简单了，经常在用，就是这两个全局方法：parseInt和parseFloat。 对象转字符串 对象转换为字符串和数值会稍微麻烦点，下面我们单独来探究下。对象转为字符串主要有三种方法: value.toString() 这个前面讲过了 '' + value。这个是前面提到过的隐式转换，但是value是对象的话会按照下面的顺序进行转换： 先调用value.valueOf方法，如果值是原始值，则返回 否则调用value.toString方法，如果值是原始值，则返回 否则报错TypeError String(value)。这个是前面提到的显式转换，流程跟前面类似，但是调用toString和valueOf的顺序不一样。 先调用value.toString方法，如果值是原始值，则返回 否则调用value.valueOf方法，如果值是原始值，则返回 否则报错TypeError 需要注意的是，Date对象有点特殊，他始终调用toString方法。 下面我们写一段代码来验证下: Object.prototype.valueOf = function() { return 'aaa'; } Object.prototype.toString = function() { return 'bbb'; } let a = {}; let b = '' + a; let c = String(a); console.log(b); console.log(c); 上述代码输出是，跟我们预期一样: 对象转数值 对象类型转为数值主要有两种方法: +value Number(value) 这两种的执行逻辑是一样的: 先调用valueOf方法，如果值是原始值，就返回 否则，调用toString方法，然后将toString的返回值转换为数值 照例写个例子看下: Object.prototype.valueOf = function() { return {}; } Object.prototype.toString = function() { return 'bbb'; } let a = {}; let b = +a; let c = Number(a); console.log(b); console.log(c); 上述代码的输出都是NaN，这是因为我们toString方法返回的bbb没办法转化为正常数值，强行转就是NaN: 类型检测 类型检测是我们经常遇到的问题，面试时也经常问到各种类型检测的方法，下面是几种常用的类型检测的方法。 typeof 做类型检测最常用的就是typeof了: let a; typeof a; // undefined let b = true; typeof b; // boolean let c = 123; typeof c; // number let d = 'abc'; typeof d; // string let e = () => {}; typeof e; // function let f = {}; typeof f; // object let g = Symbol(); typeof g; // symbol instanceof typeof最简单，但是他只能判断基本的类型，如果是对象的话，没法判断具体是哪个对象。instanceof可以检测一个对象是不是某个类的实例，这种检测其实基于面向对象和原型链的，更多关于instanceof原理的可以看这篇文章。下面来看个例子: let a = new Date(); a instanceof Date; // true constructor constructor的原理其实跟前面的instanceof有点像，也是基于面向对象和原型链的。一个对象如果是一个类的实例的话，那他原型上的constructor其实也就指向了这个类，我们可以通过判断他的constructor来判断他是不是某个类的实例。具体的原理在前面提到的文章也有详细说明。还是用上面那个例子: let a = new Date(); a.constructor === Date; // true 使用constructor判断的时候要注意，如果原型上的constructor被修改了，这种检测可能就失效了，比如: function a() {} a.prototype = { x: 1 } let b = new a(); b.constructor === a; // 注意这时候是 false 上面为false的原因是，constructor这个属性其实是挂在a.prototype下面的，我们在给a.prototype赋值的时候其实覆盖了之前的整个prototype，也覆盖了a.prototype.constructor,这时候他其实压根就没有这个属性，如果我们非要访问这个属性，只能去原型链上找，这时候会找到Object: 要避免这个问题，我们在给原型添加属性时，最好不要整个覆盖，而是只添加我们需要的属性，上面的改为: a.prototype.x = 1; 如果一定要整个覆盖，记得把constructor加回来: a.prototype = { constructor: a, x: 1 } duck-typing duck-typing翻译叫“鸭子类型”，名字比较奇怪，意思是指一个动物，如果看起来像鸭子，走起路来像鸭子，叫起来也像鸭子，那我们就认为他是只鸭子。就是说我们通过他的外观和行为来判断他是不是鸭子，而不是准确的去检测他的基因是不是鸭子。这种方式在科学上当然是不严谨的，但是在部分场景下却是有效的。用编程语言来说，就是看某个对象是不是具有某些特定的属性和方法，来确定他是不是我们要的对象。比如有些开源库判断一个对象是不是数组会有下面的写法: function isArray(object) { return object !== null && typeof object === 'object' && 'splice' in object && 'join' in object } isArray([]); // true 这就是通过检测目标对象是不是包含Array应该有的方法来判断他是不是一个Array。这就是所谓的看着像鸭子，那就是鸭子。但是一个具有splice和join方法的对象也能通过这个检测，所以这样是不准确的，只是部分场景适用。 Object.prototype.toString.call Object.prototype.toString.call是比较准确的，可以用来判断原生对象具体是哪个类型: Object.prototype.toString.call(new Array()); // [object Array] Object.prototype.toString.call(new Date()); // [object Date] 这个方法返回的是[object XXX]，这个XXX是对应的构造函数名字。但是他只能检测原生对象，对于自定义类型是没有用的: function a() {} let b = new a(); Object.prototype.toString.call(b); // [object Object] 可以看到对于自定义类a的实例b，我们得到仍然是[object Object]，而不是我们预期的[object a]。 一些原生方法: Array.isArray，Number.isInteger JS为了解决类型检测的问题，也引入了一些原生方法来提供支持，比如Array.isArray和Number.isInteger等。Array.isArray可以用来检测一个对象是不是数组: Array.isArray([]); // true Array.isArray(123); // false Number.isInteger可以用来检测一个对象是不是整数: Number.isInteger(1); // true Number.isInteger(-1); // true Number.isInteger(-1.1); // false Number.isInteger('aaa'); // false 如果有原生检测的方法我们当然推荐使用原生方法了，但是目前原生方法并没有那么多和全面，很多时候还是要用前面的方法来检测类型。 小节 JS其实没有一种完美的方法来检测所有的类型，具体的检测方法需要我们根据实际情况来进行选择和取舍。下面是几种方法的总结： 总结 JS有两种数据类型，原始类型和引用类型，引用类型主要就是对象。 当我们使用+，逻辑判断或者==时会有隐式的类型转换。 有时候隐式的类型转换会出现我们不想要的结果，如果我们确定要进行判断或者类型转换，最好使用显式的，比如使用===，而不是==。 对象转为字符串和数值可能需要调valueOf和toString方法，调用顺序需要看具体场景。 JS没有一个完美的类型检测方法，我们最好根据需要选择具体的检测方法。 "},"Articles/JavaScript/Scope.html":{"url":"Articles/JavaScript/Scope.html","title":"JS作用域","keywords":"","body":"作用域是JS中一个很基础但是很重要的概念，面试中也经常出现，本文会详细深入的讲解这个概念及其他相关的概念，包括声明提升，块级作用域，作用域链及作用域链延长等问题。 什么是作用域 第一个问题就是我们要弄清楚什么是作用域，这不是JS独有的概念，而是编程领域中通用的一个概念。我们以下面这个语句为例: let x = 1; 这一个简单的语句其实包含了几个基本的概念: 变量(variable)：这里x就是一个变量，是用来指代一个值的符号。 值(value)：就是具体的数据，可以是数字，字符串，对象等。这里1就是一个值。 变量绑定(name binding)：就是变量和值之间建立对应关系，x = 1就是将变量x和1联系起来了。 作用域(scope)：作用域就是变量绑定(name binding)的有效范围。就是说在这个作用域中，这个变量绑定是有效的，出了这个作用域变量绑定就无效了。 就整个编程领域而言的话，作用域又分为静态作用域和动态作用域两类。 静态作用域 静态作用域又叫词法作用域，JS就是静态作用域，比如如下代码: let x = 10; function f() { return x; } function g() { let x = 20; return f(); } console.log(g()); // 10 上述代码中，函数f返回的x是外层定义的x，也就是10，我们调用g的时候，虽然g里面也有个变量x，但是在这里我们并没有用它，用的是f里面的x。也就是说我们调用一个函数时，如果这个函数的变量没有在函数中定义，就去定义该函数的地方查找，这种查找关系在我们代码写出来的时候其实就确定了，所以叫静态作用域。这是一段很简单的代码，大家都知道输出是10，难道还能输出20？还真有输出20的，那就是动态作用域了！ 动态作用域 Perl语言就采用的动态作用域，还是上面那个代码逻辑，换成Perl语言是这样: $x = 10; sub f { return $x; } sub g { local $x = 20; return f(); } print g(); 上述代码的输出就是20，大家可以用Perl跑下看看，这就是动态作用域。所谓动态作用域就是我们调用一个函数时，如果这个函数的变量没有在函数中定义，就去调用该函数的地方查找。因为一个函数可能会在多个地方被调用，每次调用的时候变量的值可能都不一样，所以叫动态作用域。动态作用域的变量值在运行前难以确定，复杂度更高，所以目前主流的都是静态作用域，比如JS,C,C++,Java这些都是静态作用域。 声明提前 变量声明提前 在ES6之前，我们申明变量都是使用var，使用var申明的变量都是函数作用域，即在函数体内可见，这会带来的一个问题就是申明提前。 var x = 1; function f() { console.log(x); var x = 2; } f(); 上述代码的输出是undefined，因为函数f里面的变量x使用var申明，所以他其实在整个函数f可见，也就是说，他的声明相当于提前到了f的最顶部，但是赋值还是在运行的x = 2时进行，所以在var x = 2;上面打印x就是undefined，上面的代码其实等价于: var x = 1; function f() { var x console.log(x); x = 2; } f(); 函数声明提前 看下面这个代码： function f() { x(); function x() { console.log(1); } } f(); 上述代码x()调用是可以成功的，因为函数的声明也会提前到当前函数的最前面，也就是说，上面函数x会提前到f的最顶部执行，上面代码等价于: function f() { function x() { console.log(1); } x(); } f(); 但是有一点需要注意，上面的x函数如果换成函数表达式就不行了: function f() { x(); var x = function() { console.log(1); } } f(); 这样写会报错Uncaught TypeError: x is not a function。因为这里的x其实就是一个普通变量，只是它的值是一个函数，它虽然会提前到当前函数的最顶部申明，但是就像前面讲的，这时候他的值是undefined，将undefined当成函数调用，肯定就是TypeError。 变量申明和函数申明提前的优先级 既然变量申明和函数申明都会提前，那谁的优先级更高呢？答案是函数申明的优先级更高！看如下代码: var x = 1; function x() {} console.log(typeof x); // number 上述代码我们申明了一个变量x和一个函数x，他们拥有同样的名字。最终输出来的typeof是number，说明函数申明的优先级更高，x变量先被申明为一个函数，然后当我们再用var申明x的时候，这个var会被忽略，但是x=1的赋值语句会运行，最后x就是1，类型是number。 块级作用域 前面的申明提前不太符合人们正常的思维习惯，对JS不太熟悉的初学者如果不了解这个机制，可能会经常遇到各种TypeError，写出来的代码也可能隐含各种BUG。为了解决这个问题，ES6引入了块级作用域。块级作用域就是指变量在指定的代码块里面才能访问，也就是一对{}中可以访问，在外面无法访问。为了区分之前的var，块级作用域使用let和const声明，let申明变量，const申明常量。看如下代码: function f() { let y = 1; if(true) { var x = 2; let y = 2; } console.log(x); // 2 console.log(y); // 1 } f(); 上述代码我们在函数体里面用let申明了一个y，这时候他的作用域就是整个函数，然后又有了一个if，这个if里面用var申明了一个x，用let又申明了一个y，因为var是函数作用域，所以在if外面也可以访问到这个x，打印出来就是2，if里面的那个y因为是let申明的，所以他是块级作用域，也就是只在if里面生效，如果在外面打印y，会拿到最开始那个y，也就是1. 不允许重复申明 块级作用域在同一个块中是不允许重复申明的，比如: var a = 1; let a = 2; 这个会直接报错Uncaught SyntaxError: Identifier 'a' has already been declared。 但是如果你都用var申明就不会报错: var a = 1; var a = 2; 不会变量提升？ 经常看到有文章说: 用let和const申明的变量不会提升。其实这种说法是不准确的，比如下面代码: var x = 1; if(true) { console.log(x); let x = 2; } 上述代码会报错Uncaught ReferenceError: Cannot access 'x' before initialization。如果let申明的x没有变量提升，那我们在他前面console应该拿到外层var定义的x才对。但是现在却报错了，说明执行器在if这个块里面其实是提前知道了下面有一个let申明的x的，所以说变量完全不提升是不准确的。只是提升后的行为跟var不一样，var是读到一个undefined，而块级作用域的提升行为是会制造一个暂时性死区(temporal dead zone, TDZ)。暂时性死区的现象就是在块级顶部到变量正式申明这块区域去访问这个变量的话，直接报错，这个是ES6规范规定的。 循环语句中的应用 下面这种问题我们也经常遇到，在一个循环中调用异步函数，期望是每次调用都拿到对应的循环变量，但是最终拿到的却是最后的循环变量: for(var i = 0; i { console.log(i) }) } 上述代码我们期望的是输出0,1,2，但是最终输出的却是三个3，这是因为setTimeout是异步代码，会在下次事件循环执行，而i++却是同步代码，而全部执行完，等到setTimeout执行时，i++已经执行完了，此时i已经是3了。以前为了解决这个问题，我们一般采用自执行函数: for(var i = 0; i { console.log(i) }) })(i) } 现在有了let我们直接将var改成let就可以了： for(let i = 0; i { console.log(i) }) } 这种写法也适用于for...in和for...of循环: let obj = { x: 1, y: 2, z: 3 } for(let k in obj){ setTimeout(() => { console.log(obj[k]) }) } 那能不能使用const来申明循环变量呢？对于for(const i = 0; i 来说，const i = 0是没问题的，但是i++肯定就报错了，所以这个循环会运行一次，然后就报错了。对于for...in和for...of循环，使用const声明是没问题的。 let obj = { x: 1, y: 2, z: 3 } for(const k in obj){ setTimeout(() => { console.log(obj[k]) }) } 不影响全局对象 在最外层(全局作用域)使用var申明变量，该变量会成为全局对象的属性，如果全局对象刚好有同名属性，就会被覆盖。 var JSON = 'json'; console.log(window.JSON); // JSON被覆盖了，输出'json' 而使用let申明变量则没有这个问题: let JSON = 'json'; console.log(window.JSON); // JSON没有被覆盖，还是之前那个对象 上面这么多点其实都是let和const对以前的var进行的改进，如果我们的开发环境支持ES6，我们就应该使用let和const，而不是var。 作用域链 作用域链其实是一个很简单的概念，当我们使用一个变量时，先在当前作用域查找，如果没找到就去他外层作用域查找，如果还没有，就再继续往外找，一直找到全局作用域，如果最终都没找到，就报错。比如如下代码: let x = 1; function f() { function f1() { console.log(x); } f1(); } f(); 这段代码在f1中输出了x，所以他会在f1中查找这个变量，当然没找到，然后去f中找，还是没找到，再往上去全局作用域找，这下找到了。这个查找链条就是作用域链。 作用域链延长 前面那个例子的作用域链上其实有三个对象： f1作用域 -> f作用域 -> 全局作用域 大部分情况都是这样的，作用域链有多长主要看它当前嵌套的层数，但是有些语句可以在作用域链的前端临时增加一个变量对象，这个变量对象在代码执行完后移除，这就是作用域延长了。能够导致作用域延长的语句有两种:try...catch的catch块和with语句。 try...catch 这其实是我们一直在用的一个特殊情况: let x = 1; try { x = x + y; } catch(e) { console.log(e); } 上述代码try里面我们用到了一个没有申明的变量y，所以会报错，然后走到catch，catch会往作用域链最前面添加一个变量e，这是当前的错误对象，我们可以通过这个变量来访问到错误对象，这其实就相当于作用域链延长了。这个变量e会在catch块执行完后被销毁。 with with语句可以操作作用域链，可以手动将某个对象添加到作用域链最前面，查找变量时，优先去这个对象查找，with块执行完后，作用域链会恢复到正常状态。 function f(obj, x) { with(obj) { console.log(x); // 1 } console.log(x); // 2 } f({x: 1}, 2); 上述代码，with里面输出的x优先去obj找，相当于手动在作用域链最前面添加了obj这个对象，所以输出的x是1。with外面还是正常的作用域链，所以输出的x仍然是2。需要注意的是with语句里面的作用域链要执行时才能确定，引擎没办法优化，所以严格模式下是禁止使用with的。 总结 作用域其实就是一个变量绑定的有效范围。 JS使用的是静态作用域，即一个函数使用的变量如果没在自己里面，会去定义的地方查找，而不是去调用的地方查找。去调用的地方找到的是动态作用域。 var变量会进行申明提前，在赋值前可以访问到这个变量，值是undefined。 函数申明也会被提前，而且优先级比var高。 使用var的函数表达式其实就是一个var变量，在赋值前调用相当于undefined()，会直接报错。 let和const是块级作用域，有效范围是一对{}。 同一个块级作用域里面不能重复申明，会报错。 块级作用域也有“变量提升”，但是行为跟var不一样，块级作用域里面的“变量提升”会形成“暂时性死区”，在申明前访问会直接报错。 使用let和const可以很方便的解决循环中异步调用参数不对的问题。 let和const在全局作用域申明的变量不会成为全局对象的属性，var会。 访问变量时，如果当前作用域没有，会一级一级往上找，一直到全局作用域，这就是作用域链。 try...catch的catch块会延长作用域链，往最前面添加一个错误对象。 with语句可以手动往作用域链最前面添加一个对象，但是严格模式下不可用。 如果开发环境支持ES6，就应该使用let和const，不要用var。 "},"Articles/Vue/Vue.html":{"url":"Articles/Vue/Vue.html","title":"Vue.js","keywords":"","body":"本章节包括如下内容： 此目录主要分享Vue的源码知识与资源分享以及项目实战经验 Vue响应式原理 Vue-Router原理 "},"Articles/Vue/reactive.html":{"url":"Articles/Vue/reactive.html","title":"Vue响应式原理","keywords":"","body":"VUE响应式原理 这里的响应式(Reactive)不同于CSS布局的响应式(Responsive), 这里的响应式是指数据和视图的绑定，数据一旦更新，视图会自动更新。下面让我们来看看Vue是怎么实现响应式的，Vue 2.0和Vue 3.0的实现原理还不一样，我们来分开讲。 Vue 2.0的响应式 Object.defineProperty Vue 2.0的响应式主要用到了Object.defineProperty,我们先来说说这个方法。Object.defineProperty(obj, prop, descriptor)是用来定义属性描述符的，它接收三个参数，第一个参数目标对象，第二个参数是目标对象里面的属性，第三个参数是想要设置的属性描述符，包含如下几个值及默认值 { value: undefined, // 属性的值 get: undefined, // 获取属性值时触发的方法 set: undefined, // 设置属性值时触发的方法 writable: false, // 属性值是否可修改，false不可改 enumerable: false, // 属性是否可以用for...in 和 Object.keys()枚举 configurable: false // 该属性是否可以用delete删除，false不可删除，为false时也不能再修改该参数 } 对于一个普通的对象 var a = {b: 1} 我们可以使用Object.getOwnPropertyDescriptor来获取一个属性的描述符 你会发现a.b这个属性的writable, enumerable, configurable这三个描述符都是true，但是我们前面说他们的默认值是false啊，这是怎么回事呢？这是因为我们定义属性的方法不一样，我们最开始的定义这个属性的时候已经给他赋值了，所以他已经是可写的了。我们换一种声明方式，用Object.defineProperty直接声明a.c，再看看他的属性描述符 我们定义的时候只指定了值为2，没有指定其他描述符，那么writable, enumerable, configurable都是默认值false，也就意味着a.c不能修改，不能枚举，也不能再配置。即使你显式a.c=3也没有用，他的值还是2，而且这样写在严格模式还会报错。因为configurable是false，也不能通过Object.defineProperty再修改描述符，会直接报错： set 和 get 这才是重头戏，Vue就是通过set和get来实现的响应式，我们通过自己实现一个简单版的Vue来讲解这个问题。首先我们先定义一个vue: function vue(){ this.$data = {a: 1}; this.el = document.getElementById('app'); this.virtualDom = ''; this.observer(this.$data); this.render(); } 我们需要在observer方法里面来实现set和get，因为我们要监听的是值属性，要是属性本身又是一个对象，比如 { a: { b: { c: 1 } } } 我们需要递归的设置set和get来监听里面的值。我们简单版的get就直接返回值了，其实这里可以进行优化，后面再讲。set方法接收一个参数newValue，我们直接赋值给value，然后调用render方法更新界面 vue.prototype.observer = function(obj){ var value; var self = this; for(var key in obj){ // 递归设置set和get value = obj[key]; if(typeof value === 'object'){ this.observer(value); } else { Object.defineProperty(this.$data, key, { get: function(){ return value; }, set: function(newValue){ value = newValue; self.render(); } }); } } } 下面是render方法： vue.prototype.render = function(){ this.virtualDom = `I am ${this.$data.a}`; this.el.innerHTML = this.virtualDom; } 这样你每次修改$data.a的时候，界面就会自动更新。需要注意的是，如果你设置了get方法，但是没有写返回值，会默认返回undefined，你每次读这个属性都是undefined，如果设置了set方法，值的更新就必须自己全部实现，不实现去赋值也不会成功。事实上，get和set需要优化的地方还很多，我们现在是一旦触发set就更新了整个DOM，但实际上我们可能有100个组件，其中只有一个组件使用了set的值，这会造成很大的资源浪费。我们需要找出一个变量到底被哪些组件使用了，当变量更新的时候只去更新那些用到了的组件。这才是Vue真正的做法： 这样我们的get和set就变成了这样： Object.defineProperty(this.$data, key, { get: function(){ dep.depend(); // 这里进行依赖收集 return value; }, set: function(newValue){ value = newValue; // self.render(); dep.notify(); // 这里进行virtualDom更新，通知需要更新的组件render } }); dep是Vue负责管理依赖的一个类，后面单独开一篇文章讲。 数组的处理 数组不能用Object.defineProperty来处理，应该怎么办呢？Vue里面操作数组，直接用下标更改，是没有用的，必须使用push, shift等方法来操作，为什么呢？ var a = [1, 2, 3]; a[0] = 10; // 这样不能更新视图 其实Vue用装饰者模式来重写了数组这些方法，在讲这个之前我们先讲讲Object.create Object.create 这个方法创建一个新对象，使用现有的对象来提供新创建的对象的__proto__,接收两个参数Object.create(proto[, propertiesObject])。第一个参数是新创建对象的原型对象，第二个参数可选，如果没有指定为 undefined，则是要添加到新创建对象的不可枚举（默认）属性（即其自身定义的属性，而不是其原型链上的枚举属性）对象的属性描述符以及相应的属性名称。这些属性对应Object.defineProperties()的第二个参数。看实现类式继承的例子： // Shape - 父类(superclass) function Shape() { this.x = 0; this.y = 0; } // 父类的方法 Shape.prototype.move = function(x, y) { this.x += x; this.y += y; console.info('Shape moved.'); }; // Rectangle - 子类(subclass) function Rectangle() { Shape.call(this); // call super constructor. } // 子类续承父类 Rectangle.prototype = Object.create(Shape.prototype); // 此时 Rectangle.prototype !== Shape.prototype // 但是 Rectangle.prototype.__prpto__ === Shape.prototype Rectangle.prototype.constructor = Rectangle; // 前面会改掉构造函数，重新设置构造函数 var rect = new Rectangle(); console.log('Is rect an instance of Rectangle?', rect instanceof Rectangle); // true console.log('Is rect an instance of Shape?', rect instanceof Shape); // true rect.move(1, 1); // Outputs, 'Shape moved.' 多继承例子： function MyClass() { SuperClass.call(this); OtherSuperClass.call(this); } // 继承一个类 MyClass.prototype = Object.create(SuperClass.prototype); // 混合其它 Object.assign(MyClass.prototype, OtherSuperClass.prototype); // 重新指定constructor MyClass.prototype.constructor = MyClass; MyClass.prototype.myMethod = function() { // do a thing }; 我们回到Vue, 看看它数组的装饰者模式： var arraypro = Array.prototype; // 获取Array的原型 var arrob = Object.create(arraypro); // 用Array的原型创建一个新对象，arrob.__proto__ === arraypro，免得污染原生Array; var arr=['push', 'pop', 'shift']; // 需要重写的方法 arr.forEach(function(method){ arrob[method] = function(){ arraypro[method].apply(this, arguments); // 重写时先调用原生方法 dep.notify(); // 并且同时更新 } }); // 对于用户定义的数组，手动将数组的__proto__指向我们修改过的原型 var a = [1, 2, 3]; a.__proto__ = arrob; 上面对于新对象arrob的方法，我们是直接赋值的，这样会有一个问题，就是用户可能会不小心改掉我们的对象，所以我们可以用到我们前面讲到的Object.defineProperty来规避这个问题，我们创建一个公用方法def专门来设置不能修改值的属性 function def (obj, key, value) { Object.defineProperty(obj, key, { // 这里我们没有指定writeable，默认为false，即不可修改 enumerable: true, configurable: true, value: value, }); } // 数组方法重写改为 arr.forEach(function(method){ def(arrob, method, function(){ arraypro[method].apply(this, arguments); // 重写时先调用原生方法 dep.notify(); // 并且同时更新 }); }); Vue 3.0的响应式 3.0的响应式原理跟2.0类似，也是在get的时候收集依赖，在set的时候更新视图。但是3.0使用了ES6的新API Proxy和Reflect，使用Proxy相对于Object.defineProperty有如下好处： 1. Object.defineProperty需要指定对象和属性，对于多层嵌套的对象需要递归监听，Proxy可以直接监听整个对象，不需要递归； 2. Object.defineProperty的get方法没有传入参数，如果我们需要返回原值，需要在外部缓存一遍之前的值，Proxy的get方法会传入对象和属性，可以直接在函数内部操作，不需要外部变量； 3. set方法也有类似的问题，Object.defineProperty的set方法传入参数只有newValue，也需要手动将newValue赋给外部变量，Proxy的set也会传入对象和属性，可以直接在函数内部操作； 4. new Proxy()会返回一个新对象，不会污染源原对象 5. Proxy可以监听数组，不用单独处理数组 上面的vue.prototype.observer可以改为： vue.prototype.observer = function(obj){ var self = this; this.$data = new Proxy(this.$data, { get: function(target, key){ return target[key]; }, set: function(target, key, newValue){ target[key] = newValue; self.render(); } }); } Proxy还可以做数据校验 // 需求，校验一个人名字必须是中文，年龄必须大于18岁 var validator = { name: function(value){ var reg = /^[\\u4E00-\\u9FA5]+$/; if(typeof value === \"string\" && reg.test(value)){ return true; } return false; }, age: function(value){ if(typeof value==='number' && value >= 18){ return true; } return false; } } function person(age, name){ this.age = age; this.name = name; // 使用Proxy的set校验，每次给对象属性赋值或修改都会校验 return new Proxy(this, { get: function(target, key){ return target[key]; }, set: function(target, key, newValue){ // set的时候调用前面定义好的验证规则，这其实就是策略模式 if(validator[key](newValue)){ return Reflect.set(target, key, newValue); }else{ throw new Error(`${key} is wrong.`) } } }); } let p = new Proxy(target, handler);的第二个参数handler不仅可以在get和set时触发，还可以在下列方法时触发： getPrototypeOf() setPrototypeOf() isExtensible() preventExtensions() getOwnPropertyDescriptor() defineProperty() has() get() set() deleteProperty() ownKeys() apply() construct() 浅谈虚拟DOM和diff算法 我们有这样一个模板： 111 123 456 这一段模板转化为虚拟DOM的伪代码，以第一个div为例的伪代码： { dom: 'div', props: { id: 123 }, children: [ { dom: 'p', children: [ dom: 'span', text: \"111\" ] }, { dom: 'p', text: \"123\" } ] } 每个节点都可以有多个children，每个child都是一个单独的节点，结构是一样的，也可以有自己的children。 在进行节点比对的时候，Vue只会进行同层的比较，比如有一个节点之前是： 123 后面变成了 456 比对是只会比对第一层的div, 第二层是p和span比对，不会拿div和span进行比对，如下图： 从数据改变的set方法开始的diff算法如下图所示： 如果新旧两个节点完全不一样了isSameVnode返回false，则整个节点更新，如果节点本身是一样的，就比较他们的子节点，下面是伪代码： patchVnode(oldVnode, vnode){ const el = vnode.el = oldVnode; let i, oldCh = oldVnode.children, ch = vnode.children; if(oldVnode === vnode) return; if(oldVnode.text !== null && vnode.text !== null && oldVnode.text !== vnode.text){ // 仅仅是文字改变，更新文字 setTextContext(el, vnode.text); }else{ updateEle(); if(oldCh&&ch&&oldCh!==ch){ // 都有子元素，但是变化了 updateChildren(); }else if(ch){ // 新的有子元素, 老的没有，创建新元素 createEl(vnode); }else if(oldCh){ // 老的有子元素，新的没有，删除老元素 removeChildren(el); } } } "},"Articles/Vue/vueRouter.html":{"url":"Articles/Vue/vueRouter.html","title":"Vue-Router原理","keywords":"","body":"前端路由和后端路由 以前的很多技术，比如PHP，路由是直接发给后端，然后由后端根据路由返回对应的页面。但是现在的前端技术，比如Vue, React都用的前端路由了，就是用户输入的路由跟后端并不是对应的了，而是前端来处理路由了，然后由前端来发起对应的请求。前端路由，后端路由具体流程如下： 后端路由 1. 输入url 2. 请求发送到服务器 3. 服务器解析请求的地址 4. 拿到对应的页面 5. 返回页面 前端路由 1. 输入url 2. js解析地址 3. 找到地址对应的页面 4. 执行页面的js 5. 渲染页面 Vue-Router工作流程 vue-router的工作流程有如下几步 1. url改变 2. 触发监听事件 3. 改变vue-router里面的current变量 4. 监视current变量（变量的监视者） 5. 获取对应的组件 6. render新组件 Vue-Router的路由模式有两种：hash和history，这两种模式的监听方法不一样 监听url改变事件 hash模式的值可以通过location.hash拿到，监听改变可以使用onhashchange事件；history的值可以用location.pathname拿到，可以用onpopstate事件来监听改变。 Vue插件 在使用Vue-Router之前我们都会调用下Vue.use，那Vue.use方法究竟是干嘛的呢？Vue.use方法接收一个对象作为参数，并且会运行这个对象的install方法，如果没有install方法会检查这个参数是不是方法，如果是方法就执行这个方法： function pluginA() { console.log(1); } pluginA.install = function() { console.log('install'); } // pluginA如果没有install属性，执行本身，输出1 // 如果有install属性，执行install属性对应的方法，输出install Vue.use(pluginA); // console: install 要实现插件功能，关键是Vue.use在执行install方法的时候，会传一个参数vue进去，这个参数是Vue的类，可以通过这个参数调用vue的API： pluginA.install = function(vue) { console.log(vue); } 我们要实现路由插件功能的关键是使用vue.mixinAPI，这个API可以将一些变量和方法全局混入Vue的实例，下面我们混入一个测试数据，并渲染到跟路由上： pluginA.install = function(vue) { vue.mixin({ data() { return {globalData: 'this is mixin data'} } }) } 然后在所有路由上都可以直接使用这个变量了，跟路由也是，而不需要导入。 vue.mixin不仅可以混入变量和方法，还可以混入生命周期，在这里混入的生命周期在每个组件的这个生命周期的这个阶段都会调用： pluginA.install = function(vue) { vue.mixin({ data() { return {globalData: 'this is mixin data'} }, // 混入生命周期 created() { console.log('I am global created'); } }) } 需要注意的是，new Vue和App.vue也算两个组件，也会运行一次生命周期，在/test下只有一个Test组件的情况下，I am global created会打印三次，分别对应new Vue，App.vue和Test组件。在混入的方法或者生命周期里面可以拿到this，这个this分别指向对应的组件实例，很多插件特性都是靠这个实现的 为了实现我们的route插件，除了需要vue.mixin外，还需要vue.util，这是个工具类，里面主要有四个方法： 1. warn： 抛出警告 2. extend：类似于Object.assign，一层拷贝，Object.assign有兼容问题，这个方法是一个for...in循环 3. mergeOptions:合并选项 4. defineReactive：这就是Vue实现响应式的核心代码，可以看看之前我讲Vue响应式的文章，里面会实现对对象get，set的监听，现在Vue通过util类将这个方法暴露出来了，我们可以用它来监听外部变量，这里主要是监听router的current变量。 vue.util.extend不同于vue.extend，vue.extend可以继承单个组件，然后渲染单个组件，可以用于单元测试 实现自己的Vue Router 前置知识都讲完了，下面正式开始写一个自己的vue router。第一步我们需要建一个history类，这个类很简单，只有一个属性，用来存储current。 class HistoryRoute { constructor() { this.current = null; } } 然后建一个主要的vueRouter类，这个类会有mode，history，routes三个属性，mode用来接收是hash模式还是history模式，history就是上面HistoryRoute的一个实例，routes是路由列表。构造函数里面还需要调用一个init方法，这个方法根据mode不同，注册不同的事件来监听路由变化，并将变化的路由存到history.current上。 class vueRouter { constructor(options) { this.mode = options.mode || 'hash'; this.routes = options.routes || []; this.history = new HistoryRoute(); // 将数组结构的routes转化成一个更好查找的对象 this.routesMap = this.mapRoutes(this.routes); this.init(); } // 加载事件监听 init() { if(this.mode === 'hash'){ // 如果url没有hash，给一个默认的根目录hash location.hash ? '' : location.hash = '/'; window.addEventListener('load', () => { // 页面加载的时候初始化，存储hash值到history的current上，并且去掉开头的# this.history.current = location.hash.slice('1'); }); window.addEventListener('hashchange', () => { // hash改变的时候更新history的current this.history.current = location.hash.slice('1'); }) } else { // else处理history模式 // 如果url没有pathname，给一个默认的根目录pathname location.pathname ? '' : location.pathname = '/'; window.addEventListener('load', () => { // 页面加载的时候初始化，存储pathname值到history的current上 this.history.current = location.pathname; }); window.addEventListener('popstate', () => { // pathname改变的时候更新history的current this.history.current = location.pathname; }) } } /* 将 [{path: '/', component: Hello}] 转化为 {'/': Hello} */ mapRoutes(routes) { return routes.reduce((res, current) => { res[current.path] = current.component; return res; }, {}) } } 最后需要给vueRouter一个install方法，这个方法是vue.use会调用的插件方法，这个方法里面需要将路由相关信息注入到vue里面去 // 添加install属性，用来执行插件 vueRouter.install = function(vue) { vue.mixin({ beforeCreate() { // 获取new Vue时传入的参数 if(this.$options && this.$options.router) { this._root = this; this._router = this.$options.router; // 监听current, defineReactive(obj, key, val)不传第三个参数，第三个参数默认是obj[key] // 第三个参数传了也会被监听，效果相当于，第一个参数的子级 vue.util.defineReactive(this, 'current', this._router.history); } else { // 如果不是根组件，就往上找 this._root = this.$parent._root; } // 暴露一个只读的$router Object.defineProperty(this, '$router', { get() { return this._root._router; } }) } }); // 新建一个router-view组件，这个组件根据current不同会render不同的组件 // 最终实现路由功能 vue.component('router-view', { render(h){ const current = this._self._root._router.history.current; const routesMap = this._self._root._router.routesMap; const component = routesMap[current]; return h(component); } }) } 总结 其实上面的基础版vue router主要包括两部分，一部分是浏览器地址的监听，将url改变监听到并存入vueRouter类中，另一部分是将vueRouter与vue连接起来，这部分主要是靠vue的插件机制实现的。 "},"Articles/React/React.html":{"url":"Articles/React/React.html","title":"React.js","keywords":"","body":"本章节包括如下内容： 手写React的Fiber和Hooks 手写Redux 手写React-Redux Redux-Thunk原理及源码 手写Redux-Saga源码 React-Router实现前端路由鉴权 手写React-Router源码 Calendar性能优化几十倍 "},"Articles/React/FiberAndHooks.html":{"url":"Articles/React/FiberAndHooks.html","title":"手写React的Fiber和Hooks","keywords":"","body":"熟悉React的朋友都知道，React支持jsx语法，我们可以直接将HTML代码写到JS中间，然后渲染到页面上，我们写的HTML如果有更新的话，React还有虚拟DOM的对比，只更新变化的部分，而不重新渲染整个页面，大大提高渲染效率。到了16.x，React更是使用了一个被称为Fiber的架构，提升了用户体验，同时还引入了hooks等特性。那隐藏在React背后的原理是怎样的呢，Fiber和hooks又是怎么实现的呢？本文会从jsx入手，手写一个简易版的React，从而深入理解React的原理。 本文主要实现了这些功能: 简易版Fiber架构 简易版DIFF算法 简易版函数组件 简易版Hook: useState 娱乐版Class组件 本文程序跑起来效果如下： JSX和creatElement 以前我们写React要支持JSX还需要一个库叫JSXTransformer.js，后来JSX的转换工作都集成到了babel里面了，babel还提供了在线预览的功能，可以看到转换后的效果，比如下面这段简单的代码: const App = ( Title Jump Article ); 经过babel转换后就变成了这样： 上面的截图可以看出我们写的HTML被转换成了React.createElement，我们将上面代码稍微格式化来看下： var App = React.createElement( 'div', null, React.createElement( 'h1', { id: 'title', }, 'Title', ), React.createElement( 'a', { href: 'xxx', }, 'Jump', ), React.createElement( 'section', null, React.createElement('p', null, 'Article'), ), ); 从转换后的代码我们可以看出React.createElement支持多个参数: type，也就是节点类型 config, 这是节点上的属性，比如id和href children, 从第三个参数开始就全部是children也就是子元素了，子元素可以有多个，类型可以是简单的文本，也可以还是React.createElement，如果是React.createElement，其实就是子节点了，子节点下面还可以有子节点。这样就用React.createElement的嵌套关系实现了HTML节点的树形结构。 让我们来完整看下这个简单的React页面代码： 渲染在页面上是这样： 这里面用到了React的地方其实就两个，一个是JSX，也就是React.createElement，另一个就是ReactDOM.render，所以我们手写的第一个目标就有了，就是createElement和render这两个方法。 手写createElement 对于Title这样一个简单的节点，原生DOM也会附加一大堆属性和方法在上面，所以我们在createElement的时候最好能将它转换为一种比较简单的数据结构，只包含我们需要的元素，比如这样： { type: 'h1', props: { id: 'title', children: 'Title' } } 有了这个数据结构后，我们对于DOM的操作其实可以转化为对这个数据结构的操作，新老DOM的对比其实也可以转化为这个数据结构的对比，这样我们就不需要每次操作都去渲染页面，而是等到需要渲染的时候才将这个数据结构渲染到页面上。这其实就是虚拟DOM！而我们createElement就是负责来构建这个虚拟DOM的方法，下面我们来实现下： function createElement(type, props, ...children) { // 核心逻辑不复杂，将参数都塞到一个对象上返回就行 // children也要放到props里面去，这样我们在组件里面就能通过this.props.children拿到子元素 return { type, props: { ...props, children } } } 上述代码是React的createElement简化版，对源码感兴趣的朋友可以看这里：https://github.com/facebook/react/blob/60016c448bb7d19fc989acd05dda5aca2e124381/packages/react/src/ReactElement.js#L348 手写render 上述代码我们用createElement将JSX代码转换成了虚拟DOM，那真正将它渲染到页面的函数是render，所以我们还需要实现下这个方法，通过我们一般的用法ReactDOM.render( ,document.getElementById('root'));可以知道他接收两个参数： 根组件，其实是一个JSX组件，也就是一个createElement返回的虚拟DOM 父节点，也就是我们要将这个虚拟DOM渲染的位置 有了这两个参数，我们来实现下render方法： function render(vDom, container) { let dom; // 检查当前节点是文本还是对象 if(typeof vDom !== 'object') { dom = document.createTextNode(vDom) } else { dom = document.createElement(vDom.type); } // 将vDom上除了children外的属性都挂载到真正的DOM上去 if(vDom.props) { Object.keys(vDom.props) .filter(key => key != 'children') .forEach(item => { dom[item] = vDom.props[item]; }) } // 如果还有子元素，递归调用 if(vDom.props && vDom.props.children && vDom.props.children.length) { vDom.props.children.forEach(child => render(child, dom)); } container.appendChild(dom); } 上述代码是简化版的render方法，对源码感兴趣的朋友可以看这里：https://github.com/facebook/react/blob/3e94bce765d355d74f6a60feb4addb6d196e3482/packages/react-dom/src/client/ReactDOMLegacy.js#L287 现在我们可以用自己写的createElement和render来替换原生的方法了： 可以得到一样的渲染结果： 为什么需要Fiber 上面我们简单的实现了虚拟DOM渲染到页面上的代码，这部分工作被React官方称为renderer，renderer是第三方可以自己实现的一个模块，还有个核心模块叫做reconciler，reconciler的一大功能就是大家熟知的diff，他会计算出应该更新哪些页面节点，然后将需要更新的节点虚拟DOM传递给renderer，renderer负责将这些节点渲染到页面上。但是这个流程有个问题，虽然React的diff算法是经过优化的，但是他却是同步的，renderer负责操作DOM的appendChild等API也是同步的，也就是说如果有大量节点需要更新，JS线程的运行时间可能会比较长，在这段时间浏览器是不会响应其他事件的，因为JS线程和GUI线程是互斥的，JS运行时页面就不会响应，这个时间太长了，用户就可能看到卡顿，特别是动画的卡顿会很明显。在React的官方演讲中有个例子，可以很明显的看到这种同步计算造成的卡顿： 而Fiber就是用来解决这个问题的，Fiber可以将长时间的同步任务拆分成多个小任务，从而让浏览器能够抽身去响应其他事件，等他空了再回来继续计算，这样整个计算流程就显得平滑很多。下面是使用Fiber后的效果： 怎么来拆分 上面我们自己实现的render方法直接递归遍历了整个vDom树，如果我们在中途某一步停下来，下次再调用时其实并不知道上次在哪里停下来的，不知道从哪里开始，所以vDom的树形结构并不满足中途暂停，下次继续的需求，需要改造数据结构。另一个需要解决的问题是，拆分下来的小任务什么时候执行？我们的目的是让用户有更流畅的体验，所以我们最好不要阻塞高优先级的任务，比如用户输入，动画之类，等他们执行完了我们再计算。那我怎么知道现在有没有高优先级任务，浏览器是不是空闲呢？总结下来，Fiber要想达到目的，需要解决两个问题： 新的任务调度，有高优先级任务的时候将浏览器让出来，等浏览器空了再继续执行 新的数据结构，可以随时中断，下次进来可以接着执行 requestIdleCallback requestIdleCallback是一个实验中的新API，这个API调用方式如下: // 开启调用 var handle = window.requestIdleCallback(callback[, options]) // 结束调用 Window.cancelIdleCallback(handle) requestIdleCallback接收一个回调，这个回调会在浏览器空闲时调用，每次调用会传入一个IdleDeadline，可以拿到当前还空余多久，options可以传入参数最多等多久，等到了时间浏览器还不空就强制执行了。使用这个API可以解决任务调度的问题，让浏览器在空闲时才计算diff并渲染。更多关于requestIdleCallback的使用可以查看MDN的文档。但是这个API还在实验中，兼容性不好，所以React官方自己实现了一套。本文会继续使用requestIdleCallback来进行任务调度，我们进行任务调度的思想是将任务拆分成多个小任务，requestIdleCallback里面不断的把小任务拿出来执行，当所有任务都执行完或者超时了就结束本次执行，同时要注册下次执行，代码架子就是这样： function workLoop(deadline) { while(nextUnitOfWork && deadline.timeRemaining() > 1) { // 这个while循环会在任务执行完或者时间到了的时候结束 nextUnitOfWork = performUnitOfWork(nextUnitOfWork); } // 如果任务还没完，但是时间到了，我们需要继续注册requestIdleCallback requestIdleCallback(workLoop); } // performUnitOfWork用来执行任务，参数是我们的当前fiber任务，返回值是下一个任务 function performUnitOfWork(fiber) { } requestIdleCallback(workLoop); 上述workLoop对应React源码看这里。 Fiber可中断数据结构 上面我们的performUnitOfWork并没有实现，但是从上面的结构可以看出来，他接收的参数是一个小任务，同时通过这个小任务还可以找到他的下一个小任务，Fiber构建的就是这样一个数据结构。Fiber之前的数据结构是一棵树，父节点的children指向了子节点，但是只有这一个指针是不能实现中断继续的。比如我现在有一个父节点A，A有三个子节点B,C,D，当我遍历到C的时候中断了，重新开始的时候，其实我是不知道C下面该执行哪个的，因为只知道C，并没有指针指向他的父节点，也没有指针指向他的兄弟。Fiber就是改造了这样一个结构，加上了指向父节点和兄弟节点的指针： 上面的图片还是来自于官方的演讲，可以看到和之前父节点指向所有子节点不同，这里有三个指针： child: 父节点指向第一个子元素的指针。 sibling：从第一个子元素往后，指向下一个兄弟元素。 return：所有子元素都有的指向父元素的指针。 有了这几个指针后，我们可以在任意一个元素中断遍历并恢复，比如在上图List处中断了，恢复的时候可以通过child找到他的子元素，也可以通过return找到他的父元素，如果他还有兄弟节点也可以用sibling找到。Fiber这个结构外形看着还是棵树，但是没有了指向所有子元素的指针，父节点只指向第一个子节点，然后子节点有指向其他子节点的指针，这其实是个链表。 实现Fiber 现在我们可以自己来实现一下Fiber了，我们需要将之前的vDom结构转换为Fiber的数据结构，同时需要能够通过其中任意一个节点返回下一个节点，其实就是遍历这个链表。遍历的时候从根节点出发，先找子元素，如果子元素存在，直接返回，如果没有子元素了就找兄弟元素，找完所有的兄弟元素后再返回父元素，然后再找这个父元素的兄弟元素。整个遍历过程其实是个深度优先遍历，从上到下，然后最后一行开始从左到右遍历。比如下图从div1开始遍历的话，遍历的顺序就应该是div1 -> div2 -> h1 -> a -> div2 -> p -> div1。可以看到这个序列中，当我们return父节点时，这些父节点会被第二次遍历，所以我们写代码时，return的父节点不会作为下一个任务返回，只有sibling和child才会作为下一个任务返回。 // performUnitOfWork用来执行任务，参数是我们的当前fiber任务，返回值是下一个任务 function performUnitOfWork(fiber) { // 根节点的dom就是container，如果没有这个属性，说明当前fiber不是根节点 if(!fiber.dom) { fiber.dom = createDom(fiber); // 创建一个DOM挂载上去 } // 如果有父节点，将当前节点挂载到父节点上 if(fiber.return) { fiber.return.dom.appendChild(fiber.dom); } // 将我们前面的vDom结构转换为fiber结构 const elements = fiber.children; let prevSibling = null; if(elements && elements.length) { for(let i = 0; i React源码中的performUnitOfWork看这里，当然比我们这个复杂很多。 统一commit DOM操作 上面我们的performUnitOfWork一边构建Fiber结构一边操作DOMappendChild，这样如果某次更新好几个节点，操作了第一个节点之后就中断了，那我们可能只看到第一个节点渲染到了页面，后续几个节点等浏览器空了才陆续渲染。为了避免这种情况，我们应该将DOM操作都搜集起来，最后统一执行，这就是commit。为了能够记录位置，我们还需要一个全局变量workInProgressRoot来记录根节点，然后在workLoop检测如果任务执行完了，就commit: function workLoop(deadline) { while(nextUnitOfWork && deadline.timeRemaining() > 1) { // 这个while循环会在任务执行完或者时间到了的时候结束 nextUnitOfWork = performUnitOfWork(nextUnitOfWork); } // 任务做完后统一渲染 if(!nextUnitOfWork && workInProgressRoot) { commitRoot(); } // 如果任务还没完，但是时间到了，我们需要继续注册requestIdleCallback requestIdleCallback(workLoop); } 因为我们是在Fiber树完全构建后再执行的commit，而且有一个变量workInProgressRoot指向了Fiber的根节点，所以我们可以直接把workInProgressRoot拿过来递归渲染就行了： // 统一操作DOM function commitRoot() { commitRootImpl(workInProgressRoot.child); // 开启递归 workInProgressRoot = null; // 操作完后将workInProgressRoot重置 } function commitRootImpl(fiber) { if(!fiber) { return; } const parentDom = fiber.return.dom; parentDom.appendChild(fiber.dom); // 递归操作子元素和兄弟元素 commitRootImpl(fiber.child); commitRootImpl(fiber.sibling); } reconcile调和 reconcile其实就是虚拟DOM树的diff操作，需要删除不需要的节点，更新修改过的节点，添加新的节点。为了在中断后能回到工作位置，我们还需要一个变量currentRoot，然后在fiber节点里面添加一个属性alternate，这个属性指向上一次运行的根节点，也就是currentRoot。currentRoot会在第一次render后的commit阶段赋值，也就是每次计算完后都会把当次状态记录在alternate上，后面更新了就可以把alternate拿出来跟新的状态做diff。然后performUnitOfWork里面需要添加调和子元素的代码，可以新增一个函数reconcileChildren。这个函数里面不能简单的创建新节点了，而是要将老节点跟新节点拿来对比，对比逻辑如下: 如果新老节点类型一样，复用老节点DOM，更新props 如果类型不一样，而且新的节点存在，创建新节点替换老节点 如果类型不一样，没有新节点，有老节点，删除老节点 注意删除老节点的操作是直接将oldFiber加上一个删除标记就行，同时用一个全局变量deletions记录所有需要删除的节点： // 对比oldFiber和当前element const sameType = oldFiber && element && oldFiber.type === element.type; //检测类型是不是一样 // 先比较元素类型 if(sameType) { // 如果类型一样，复用节点，更新props newFiber = { type: oldFiber.type, props: element.props, dom: oldFiber.dom, return: workInProgressFiber, alternate: oldFiber, // 记录下上次状态 effectTag: 'UPDATE' // 添加一个操作标记 } } else if(!sameType && element) { // 如果类型不一样，有新的节点，创建新节点替换老节点 newFiber = { type: element.type, props: element.props, dom: null, // 构建fiber时没有dom，下次perform这个节点是才创建dom return: workInProgressFiber, alternate: null, // 新增的没有老状态 effectTag: 'REPLACEMENT' // 添加一个操作标记 } } else if(!sameType && oldFiber) { // 如果类型不一样，没有新节点，有老节点，删除老节点 oldFiber.effectTag = 'DELETION'; // 添加删除标记 deletions.push(oldFiber); // 一个数组收集所有需要删除的节点 } 然后就是在commit阶段处理真正的DOM操作，具体的操作是根据我们的effectTag来判断的: function commitRootImpl(fiber) { if(!fiber) { return; } const parentDom = fiber.return.dom; if(fiber.effectTag === 'REPLACEMENT' && fiber.dom) { parentDom.appendChild(fiber.dom); } else if(fiber.effectTag === 'DELETION') { parentDom.removeChild(fiber.dom); } else if(fiber.effectTag === 'UPDATE' && fiber.dom) { // 更新DOM属性 updateDom(fiber.dom, fiber.alternate.props, fiber.props); } // 递归操作子元素和兄弟元素 commitRootImpl(fiber.child); commitRootImpl(fiber.sibling); } 替换和删除的DOM操作都比较简单，更新属性的会稍微麻烦点，需要再写一个辅助函数updateDom来实现: // 更新DOM的操作 function updateDom(dom, prevProps, nextProps) { // 1. 过滤children属性 // 2. 老的存在，新的没了，取消 // 3. 新的存在，老的没有，新增 Object.keys(prevProps) .filter(name => name !== 'children') .filter(name => !(name in nextProps)) .forEach(name => { if(name.indexOf('on') === 0) { dom.removeEventListener(name.substr(2).toLowerCase(), prevProps[name], false); } else { dom[name] = ''; } }); Object.keys(nextProps) .filter(name => name !== 'children') .forEach(name => { if(name.indexOf('on') === 0) { dom.addEventListener(name.substr(2).toLowerCase(), nextProps[name], false); } else { dom[name] = nextProps[name]; } }); } updateDom的代码写的比较简单，事件只处理了简单的on开头的，兼容性也有问题，prevProps和nextProps可能会遍历到相同的属性，有重复赋值，但是总体原理还是没错的。要想把这个处理写全，代码量还是不少的。 函数组件 函数组件是React里面很常见的一种组件，我们前面的React架构其实已经写好了，我们这里来支持下函数组件。我们之前的fiber节点上的type都是DOM节点的类型，比如h1什么的，但是函数组件的节点type其实就是一个函数了，我们需要对这种节点进行单独处理。 首先需要在更新的时候检测当前节点是不是函数组件，如果是，children的处理逻辑会稍微不一样: // performUnitOfWork里面 // 检测函数组件 function performUnitOfWork(fiber) { const isFunctionComponent = fiber.type instanceof Function; if(isFunctionComponent) { updateFunctionComponent(fiber); } else { updateHostComponent(fiber); } // ...下面省略n行代码... } function updateFunctionComponent(fiber) { // 函数组件的type就是个函数，直接拿来执行可以获得DOM元素 const children = [fiber.type(fiber.props)]; reconcileChildren(fiber, elements); } // updateHostComponent就是之前的操作，只是单独抽取了一个方法 function updateHostComponent(fiber) { if(!fiber.dom) { fiber.dom = createDom(fiber); // 创建一个DOM挂载上去 } // 将我们前面的vDom结构转换为fiber结构 const elements = fiber.props.children; // 调和子元素 reconcileChildren(fiber, elements); } 然后在我们提交DOM操作的时候因为函数组件没有DOM元素，所以需要注意两点： 获取父级DOM元素的时候需要递归网上找真正的DOM 删除节点的时候需要递归往下找真正的节点 我们来修改下commitRootImpl: function commitRootImpl() { // const parentDom = fiber.return.dom; // 向上查找真正的DOM let parentFiber = fiber.return; while(!parentFiber.dom) { parentFiber = parentFiber.return; } const parentDom = parentFiber.dom; // ...这里省略n行代码... if{fiber.effectTag === 'DELETION'} { commitDeletion(fiber, parentDom); } } function commitDeletion(fiber, domParent) { if(fiber.dom) { // dom存在，是普通节点 domParent.removeChild(fiber.dom); } else { // dom不存在，是函数组件,向下递归查找真实DOM commitDeletion(fiber.child, domParent); } } 现在我们可以传入函数组件了: import React from './myReact'; const ReactDOM = React; function App(props) { return ( {props.title} Jump Article ); } ReactDOM.render( , document.getElementById('root') ); 实现useState useState是React Hooks里面的一个API，相当于之前Class Component里面的state，用来管理组件内部状态，现在我们已经有一个简化版的React了，我们也可以尝试下来实现这个API。 简单版 我们还是从用法入手来实现最简单的功能，我们一般使用useState是这样的： function App(props) { const [count, setCount] = React.useState(1); const onClickHandler = () => { setCount(count + 1); } return ( Count: {count} Count+1 ); } ReactDOM.render( , document.getElementById('root') ); 上述代码可以看出，我们的useState接收一个初始值，返回一个数组，里面有这个state的当前值和改变state的方法，需要注意的是App作为一个函数组件，每次render的时候都会运行，也就是说里面的局部变量每次render的时候都会重置，那我们的state就不能作为一个局部变量，而是应该作为一个全部变量存储： let state = null; function useState(init) { state = state === null ? init : state; // 修改state的方法 const setState = value => { state = value; // 只要修改了state，我们就需要重新处理节点 workInProgressRoot = { dom: currentRoot.dom, props: currentRoot.props, alternate: currentRoot } // 修改nextUnitOfWork指向workInProgressRoot，这样下次就会处理这个节点了 nextUnitOfWork = workInProgressRoot; deletions = []; } return [state, setState] } 这样其实我们就可以使用了： 支持多个state 上面的代码只有一个state变量，如果我们有多个useState怎么办呢？为了能支持多个useState，我们的state就不能是一个简单的值了，我们可以考虑把他改成一个数组，多个useState按照调用顺序放进这个数组里面，访问的时候通过下标来访问: let state = []; let hookIndex = 0; function useState(init) { const currentIndex = hookIndex; state[currentIndex] = state[currentIndex] === undefined ? init : state[currentIndex]; // 修改state的方法 const setState = value => { state[currentIndex] = value; // 只要修改了state，我们就需要重新处理这个节点 workInProgressRoot = { dom: currentRoot.dom, props: currentRoot.props, alternate: currentRoot } // 修改nextUnitOfWork指向workInProgressRoot，这样下次就会处理这个节点了 nextUnitOfWork = workInProgressRoot; deletions = []; } hookIndex++; return [state[currentIndex], setState] } 来看看多个useState的效果： 支持多个组件 上面的代码虽然我们支持了多个useState，但是仍然只有一套全局变量，如果有多个函数组件，每个组件都来操作这个全局变量，那相互之间不就是污染了数据了吗？所以我们数据还不能都存在全局变量上面，而是应该存在每个fiber节点上，处理这个节点的时候再将状态放到全局变量用来通讯: // 申明两个全局变量，用来处理useState // wipFiber是当前的函数组件fiber节点 // hookIndex是当前函数组件内部useState状态计数 let wipFiber = null; let hookIndex = null; 因为useState只在函数组件里面可以用，所以我们之前的updateFunctionComponent里面需要初始化处理useState变量: function updateFunctionComponent(fiber) { // 支持useState，初始化变量 wipFiber = fiber; hookIndex = 0; wipFiber.hooks = []; // hooks用来存储具体的state序列 // ......下面代码省略...... } 因为hooks队列放到fiber节点上去了，所以我们在useState取之前的值时需要从fiber.alternate上取，完整代码如下： function useState(init) { // 取出上次的Hook const oldHook = wipFiber.alternate && wipFiber.alternate.hooks && wipFiber.alternate.hooks[hookIndex]; // hook数据结构 const hook = { state: oldHook ? oldHook.state : init // state是每个具体的值 } // 将所有useState调用按照顺序存到fiber节点上 wipFiber.hooks.push(hook); hookIndex++; // 修改state的方法 const setState = value => { hook.state = value; // 只要修改了state，我们就需要重新处理这个节点 workInProgressRoot = { dom: currentRoot.dom, props: currentRoot.props, alternate: currentRoot } // 修改nextUnitOfWork指向workInProgressRoot，这样下次requestIdleCallback就会处理这个节点了 nextUnitOfWork = workInProgressRoot; deletions = []; } return [hook.state, setState] } 上面代码可以看出我们在将useState和存储的state进行匹配的时候是用的useState的调用顺序匹配state的下标，如果这个下标匹配不上了，state就错了，所以React里面不能出现这样的代码: if (something) { const [state, setState] = useState(1); } 上述代码不能保证每次something都满足，可能导致useState这次render执行了，下次又没执行，这样新老节点的下标就匹配不上了，对于这种代码，React会直接报错： 用Hooks模拟Class组件 这个功能纯粹是娱乐性功能，通过前面实现的Hooks来模拟实现Class组件，这个并不是React官方的实现方式哈~我们可以写一个方法将Class组件转化为前面的函数组件: function transfer(Component) { return function(props) { const component = new Component(props); let [state, setState] = useState(component.state); component.props = props; component.state = state; component.setState = setState; return component.render(); } } 然后就可以写Class了，这个Class长得很像我们在React里面写的Class，有state,setState和render： import React from './myReact'; class Count4 { constructor(props) { this.props = props; this.state = { count: 1 } } onClickHandler = () => { this.setState({ count: this.state.count + 1 }) } render() { return ( Class component Count: {this.state.count} Count+1 ); } } // export的时候用transfer包装下 export default React.transfer(Count4); 然后使用的时候直接: 当然你也可以在React里面建一个空的class Component，让Count4继承他，这样就更像了。 总结 我们写的JSX代码被babel转化成了React.createElement。 React.createElement返回的其实就是虚拟DOM结构。 ReactDOM.render方法是将虚拟DOM渲染到页面的。 虚拟DOM的调和和渲染可以简单粗暴的递归，但是这个过程是同步的，如果需要处理的节点过多，可能会阻塞用户输入和动画播放，造成卡顿。 Fiber是16.x引入的新特性，用处是将同步的调和变成异步的。 Fiber改造了虚拟DOM的结构，具有父 -> 第一个子，子 -> 兄，子 -> 父这几个指针，有了这几个指针，可以从任意一个Fiber节点找到其他节点。 Fiber将整棵树的同步任务拆分成了每个节点可以单独执行的异步执行结构。 Fiber可以从任意一个节点开始遍历，遍历是深度优先遍历，顺序是父 -> 子 -> 兄 -> 父，也就是从上往下，从左往右。 Fiber的调和阶段可以是异步的小任务，但是提交阶段(commit)必须是同步的。因为异步的commit可能让用户看到节点一个一个接连出现，体验不好。 函数组件其实就是这个节点的type是个函数，直接将type拿来运行就可以得到虚拟DOM。 useState是在Fiber节点上添加了一个数组，数组里面的每个值对应了一个useState，useState调用顺序必须和这个数组下标匹配，不然会报错。 参考资料 A Cartoon Intro to Fiber 妙味课堂大圣老师：手写react的fiber和hooks架构 React Fiber 这可能是最通俗的 React Fiber(时间分片) 打开方式 浅析 React Fiber React Fiber架构 "},"Articles/React/Redux.html":{"url":"Articles/React/Redux.html","title":"手写Redux","keywords":"","body":"Redux可是一个大名鼎鼎的库，很多地方都在用，我也用了几年了，今天这篇文章就是自己来实现一个Redux，以便于深入理解他的原理。我们还是老套路，从基本的用法入手，然后自己实现一个Redux来替代源码的NPM包，但是功能保持不变。本文只会实现Redux的核心库，跟其他库的配合使用，比如React-Redux准备后面单独写一篇文章来讲。有时候我们过于关注使用，只记住了各种使用方式，反而忽略了他们的核心原理，但是如果我们想真正的提高技术，最好还是一个一个搞清楚，比如Redux和React-Redux看起来很像，但是他们的核心理念和关注点是不同的，Redux其实只是一个单纯状态管理库，没有任何界面相关的东西，React-Redux关注的是怎么将Redux跟React结合起来，用到了一些React的API。 基本概念 Redux的概念有很多文章都讲过，想必大家都看过很多了，我这里不再展开，只是简单提一下。Redux基本概念主要有以下几个： Store 人如其名，Store就是一个仓库，它存储了所有的状态(State)，还提供了一些操作他的API，我们后续的操作其实都是在操作这个仓库。假如我们的仓库是用来放牛奶的，初始情况下，我们的仓库里面一箱牛奶都没有，那Store的状态(State)就是： { milk: 0 } Actions 一个Action就是一个动作，这个动作的目的是更改Store中的某个状态，Store还是上面的那个仓库，现在我想往仓库放一箱牛奶，那\"我想往仓库放一箱牛奶\"就是一个Action，代码就是这样： { type: \"PUT_MILK\", count: 1 } Reducers 前面\"我想往仓库放一箱牛奶\"只是想了，还没操作，具体操作要靠Reducer，Reducer就是根据接收的Action来改变Store中的状态，比如我接收了一个PUT_MILK，同时数量count是1，那放进去的结果就是milk增加了1，从0变成了1，代码就是这样: const initState = { milk: 0 } function reducer(state = initState, action) { switch (action.type) { case 'PUT_MILK': return {...state, milk: state.milk + action.count} default: return state } } 可以看到Redux本身就是一个单纯的状态机，Store存放了所有的状态，Action是一个改变状态的通知，Reducer接收到通知就更改Store中对应的状态。 简单例子 下面我们来看一个简单的例子，包含了前面提到的Store，Action和Reducer这几个概念： import { createStore } from 'redux'; const initState = { milk: 0 }; function reducer(state = initState, action) { switch (action.type) { case 'PUT_MILK': return {...state, milk: state.milk + action.count}; case 'TAKE_MILK': return {...state, milk: state.milk - action.count}; default: return state; } } let store = createStore(reducer); // subscribe其实就是订阅store的变化，一旦store发生了变化，传入的回调函数就会被调用 // 如果是结合页面更新，更新的操作就是在这里执行 store.subscribe(() => console.log(store.getState())); // 将action发出去要用dispatch store.dispatch({ type: 'PUT_MILK' }); // milk: 1 store.dispatch({ type: 'PUT_MILK' }); // milk: 2 store.dispatch({ type: 'TAKE_MILK' }); // milk: 1 自己实现 前面我们那个例子虽然短小，但是已经包含了Redux的核心功能了，所以我们手写的第一个目标就是替换这个例子中的Redux。要替换这个Redux，我们得先知道他里面都有什么东西，仔细一看，我们好像只用到了他的一个API: createStore：这个API接受reducer方法作为参数，返回一个store，主要功能都在这个store上。 看看store上我们都用到了啥： store.subscribe: 订阅state的变化，当state变化的时候执行回调，可以有多个subscribe，里面的回调会依次执行。 store.dispatch: 发出action的方法，每次dispatch action都会执行reducer生成新的state，然后执行subscribe注册的回调。 store.getState:一个简单的方法，返回当前的state。 看到subscribe注册回调，dispatch触发回调，想到了什么，这不就是发布订阅模式吗？我之前有一篇文章详细讲过发布订阅模式了，这里直接仿写一个。 function createStore() { let state; // state记录所有状态 let listeners = []; // 保存所有注册的回调 function subscribe(callback) { listeners.push(callback); // subscribe就是将回调保存下来 } // dispatch就是将所有的回调拿出来依次执行就行 function dispatch() { for (let i = 0; i 上述代码是不是很简单嘛，Redux核心也是一个发布订阅模式，就是这么简单！等等，好像漏了啥，reducer呢？reducer的作用是在发布事件的时候改变state，所以我们的dispatch在执行回调前应该先执行reducer,用reducer的返回值重新给state赋值，dispatch改写如下: function dispatch(action) { state = reducer(state, action); for (let i = 0; i 到这里，前面例子用到的所有API我们都自己实现了，我们用自己的Redux来替换下官方的Redux试试： // import { createStore } from 'redux'; import { createStore } from './myRedux'; 可以看到输出结果是一样的，说明我们自己写的Redux没有问题： 了解了Redux的核心原理，我们再去看他的源码应该就没有问题了，createStore的源码传送门。 最后我们再来梳理下Redux的核心流程，注意单纯的Redux只是个状态机，是没有View层的哦。 除了这个核心逻辑外，Redux里面还有些API也很有意思，我们也来手写下。 手写combineReducers combineReducers也是使用非常广泛的API，当我们应用越来越复杂，如果将所有逻辑都写在一个reducer里面，最终这个文件可能会有成千上万行，所以Redux提供了combineReducers，可以让我们为不同的模块写自己的reducer，最终将他们组合起来。比如我们最开始那个牛奶仓库，由于我们的业务发展很好，我们又增加了一个放大米的仓库，我们可以为这两个仓库创建自己的reducer，然后将他们组合起来，使用方法如下： import { createStore, combineReducers } from 'redux'; const initMilkState = { milk: 0 }; function milkReducer(state = initMilkState, action) { switch (action.type) { case 'PUT_MILK': return {...state, milk: state.milk + action.count}; case 'TAKE_MILK': return {...state, milk: state.milk - action.count}; default: return state; } } const initRiceState = { rice: 0 }; function riceReducer(state = initRiceState, action) { switch (action.type) { case 'PUT_RICE': return {...state, rice: state.rice + action.count}; case 'TAKE_RICE': return {...state, rice: state.rice - action.count}; default: return state; } } // 使用combineReducers组合两个reducer const reducer = combineReducers({milkState: milkReducer, riceState: riceReducer}); let store = createStore(reducer); store.subscribe(() => console.log(store.getState())); // 操作🥛的action store.dispatch({ type: 'PUT_MILK', count: 1 }); // milk: 1 store.dispatch({ type: 'PUT_MILK', count: 1 }); // milk: 2 store.dispatch({ type: 'TAKE_MILK', count: 1 }); // milk: 1 // 操作大米的action store.dispatch({ type: 'PUT_RICE', count: 1 }); // rice: 1 store.dispatch({ type: 'PUT_RICE', count: 1 }); // rice: 2 store.dispatch({ type: 'TAKE_RICE', count: 1 }); // rice: 1 上面代码我们将大的state分成了两个小的milkState和riceState，最终运行结果如下： 知道了用法，我们尝试自己来写下呢！要手写combineReducers，我们先来分析下他干了啥，首先它的返回值是一个reducer，这个reducer同样会作为createStore的参数传进去，说明这个返回值是一个跟我们之前普通reducer结构一样的函数。这个函数同样接收state和action然后返回新的state，只是这个新的state要符合combineReducers参数的数据结构。我们尝试来写下： function combineReducers(reducerMap) { const reducerKeys = Object.keys(reducerMap); // 先把参数里面所有的键值拿出来 // 返回值是一个普通结构的reducer函数 const reducer = (state = {}, action) => { const newState = {}; for(let i = 0; i 官方源码的实现原理跟我们的一样，只是他有更多的错误处理，大家可以对照着看下。 手写applyMiddleware middleware是Redux里面很重要的一个概念，Redux的生态主要靠这个API接入，比如我们想写一个logger的中间件可以这样写(这个中间件来自于官方文档)： // logger是一个中间件，注意返回值嵌了好几层函数 // 我们后面来看看为什么这么设计 function logger(store) { return function(next) { return function(action) { console.group(action.type); console.info('dispatching', action); let result = next(action); console.log('next state', store.getState()); console.groupEnd(); return result } } } // 在createStore的时候将applyMiddleware作为第二个参数传进去 const store = createStore( reducer, applyMiddleware(logger) ) 可以看到上述代码为了支持中间件，createStore支持了第二个参数，这个参数官方称为enhancer，顾名思义他是一个增强器，用来增强store的能力的。官方对于enhancer的定义如下： type StoreEnhancer = (next: StoreCreator) => StoreCreator 上面的结构的意思是说enhancer作为一个函数，他接收StoreCreator函数作为参数，同时返回的也必须是一个StoreCreator函数。注意他的返回值也是一个StoreCreator函数，也就是我们把他的返回值拿出来继续执行应该得到跟之前的createStore一样的返回结构，也就是说我们之前的createStore返回啥结构，他也必须返回结构，也就是这个store： { subscribe, dispatch, getState } createStore支持enhancer 根据他关于enhancer的定义，我们来改写下自己的createStore，让他支持enhancer： function createStore(reducer, enhancer) { // 接收第二个参数enhancer // 先处理enhancer // 如果enhancer存在并且是函数 // 我们将createStore作为参数传给他 // 他应该返回一个新的createStore给我 // 我再拿这个新的createStore执行，应该得到一个store // 直接返回这个store就行 if(enhancer && typeof enhancer === 'function'){ const newCreateStore = enhancer(createStore); const newStore = newCreateStore(reducer); return newStore; } // 如果没有enhancer或者enhancer不是函数，直接执行之前的逻辑 // 下面这些代码都是之前那版 // 省略n行代码 // ....... const store = { subscribe, dispatch, getState } return store; } 这部分对应的源码看这里。 applyMiddleware返回值是一个enhancer 前面我们已经有了enhancer的基本结构，applyMiddleware是作为第二个参数传给createStore的，也就是说他是一个enhancer，准确的说是applyMiddleware的返回值是一个enhancer，因为我们传给createStore的是他的执行结果applyMiddleware()： function applyMiddleware(middleware) { // applyMiddleware的返回值应该是一个enhancer // 按照我们前面说的enhancer的参数是createStore function enhancer(createStore) { // enhancer应该返回一个新的createStore function newCreateStore(reducer) { // 我们先写个空的newCreateStore，直接返回createStore的结果 const store = createStore(reducer); return store } return newCreateStore; } return enhancer; } 实现applyMiddleware 上面我们已经有了applyMiddleware的基本结构了，但是功能还没实现，要实现他的功能，我们必须先搞清楚一个中间件到底有什么功能，还是以前面的logger中间件为例： function logger(store) { return function(next) { return function(action) { console.group(action.type); console.info('dispatching', action); let result = next(action); console.log('next state', store.getState()); console.groupEnd(); return result } } } 这个中间件运行效果如下: 可以看到我们let result = next(action);这行执行之后state改变了，前面我们说了要改变state只能dispatch(action)，所以这里的next(action)就是dispatch(action)，只是换了一个名字而已。而且注意最后一层返回值return function(action)的结构，他的参数是action，是不是很像dispatch(action)，其实他就是一个新的dispatch(action)，这个新的dispatch(action)会调用原始的dispatch，并且在调用的前后加上自己的逻辑。所以到这里一个中间件的结构也清楚了： 一个中间件接收store作为参数，会返回一个函数 返回的这个函数接收老的dispatch函数作为参数，会返回一个新的函数 返回的新函数就是新的dispatch函数，这个函数里面可以拿到外面两层传进来的store和老dispatch函数 所以说白了，中间件就是加强dispatch的功能，用新的dispatch替换老的dispatch，这不就是个装饰者模式吗？其实前面enhancer也是一个装饰者模式，传入一个createStore，在createStore执行前后加上些代码，最后又返回一个增强版的createStore。可见设计模式在这些优秀的框架中还真是广泛存在，如果你对装饰者模式还不太熟悉，可以看我之前这篇文章。 遵循这个思路，我们的applyMiddleware就可以写出来了： // 直接把前面的结构拿过来 function applyMiddleware(middleware) { function enhancer(createStore) { function newCreateStore(reducer) { const store = createStore(reducer); // 将middleware拿过来执行下，传入store // 得到第一层函数 const func = middleware(store); // 解构出原始的dispatch const { dispatch } = store; // 将原始的dispatch函数传给func执行 // 得到增强版的dispatch const newDispatch = func(dispatch); // 返回的时候用增强版的newDispatch替换原始的dispatch return {...store, dispatch: newDispatch} } return newCreateStore; } return enhancer; } 照例用我们自己的applyMiddleware替换老的，跑起来是一样的效果，说明我们写的没问题，哈哈~ 支持多个middleware 我们的applyMiddleware还差一个功能，就是支持多个middleware，比如像这样: applyMiddleware( rafScheduler, timeoutScheduler, thunk, vanillaPromise, readyStatePromise, logger, crashReporter ) 其实要支持这个也简单，我们返回的newDispatch里面依次的将传入的middleware拿出来执行就行，多个函数的串行执行可以使用辅助函数compose，这个函数定义如下。只是需要注意的是我们这里的compose不能把方法拿来执行就完了，应该返回一个包裹了所有方法的方法。 function compose(...func){ return funcs.reduce((a, b) => (...args) => a(b(...args))); } 这个compose可能比较让人困惑，我这里还是讲解下，比如我们有三个函数，这三个函数都是我们前面接收dispatch返回新dispatch的方法： const fun1 = dispatch => newDispatch1; const fun2 = dispatch => newDispatch2; const fun3 = dispatch => newDispatch3; 当我们使用了compose(fun1, fun2, fun3)后执行顺序是什么样的呢？ // 第一次其实执行的是 (func1, func2) => (...args) => func1(fun2(...args)) // 这次执行完的返回值是下面这个，用个变量存起来吧 const temp = (...args) => func1(fun2(...args)) // 我们下次再循环的时候其实执行的是 (temp, func3) => (...args) => temp(func3(...args)); // 这个返回值是下面这个，也就是最终的返回值，其实就是从func3开始从右往左执行完了所有函数 // 前面的返回值会作为后面参数 (...args) => temp(func3(...args)); // 再看看上面这个方法，如果把dispatch作为参数传进去会是什么效果 (dispatch) => temp(func3(dispatch)); // 然后func3(dispatch)返回的是newDispatch3，这个又传给了temp(newDispatch3)，也就是下面这个会执行 (newDispatch3) => func1(fun2(newDispatch3)) // 上面这个里面用newDispatch3执行fun2(newDispatch3)会得到newDispatch2 // 然后func1(newDispatch2)会得到newDispatch1 // 注意这时候的newDispatch1其实已经包含了newDispatch3和newDispatch2的逻辑了，将它拿出来执行这三个方法就都执行了 更多关于compose原理的细节可以看我之前这篇文章。 所以我们支持多个middleware的代码就是这样: // 参数支持多个中间件 function applyMiddleware(...middlewares) { function enhancer(createStore) { function newCreateStore(reducer) { const store = createStore(reducer); // 多个middleware，先解构出dispatch => newDispatch的结构 const chain = middlewares.map(middleware => middleware(store)); const { dispatch } = store; // 用compose得到一个组合了所有newDispatch的函数 const newDispatchGen = compose(...chain); // 执行这个函数得到newDispatch const newDispatch = newDispatchGen(dispatch); return {...store, dispatch: newDispatch} } return newCreateStore; } return enhancer; } 最后我们再加一个logger2中间件实现效果: function logger2(store) { return function(next) { return function(action) { let result = next(action); console.log('logger2'); return result } } } let store = createStore(reducer, applyMiddleware(logger, logger2)); 可以看到logger2也已经打印出来了，大功告成。 现在我们也可以知道他的中间件为什么要包裹几层函数了： 第一层：目的是传入store参数 第二层：第二层的结构是dispatch => newDispatch，多个中间件的这层函数可以compose起来，形成一个大的dispatch => newDispatch 第三层：这层就是最终的返回值了，其实就是newDispatch，是增强过的dispatch，是中间件的真正逻辑所在。 到这里我们的applyMiddleware就写完了，对应的源码可以看这里，相信看了本文再去看源码就没啥问题了！ 总结 单纯的Redux只是一个状态机，store里面存了所有的状态state，要改变里面的状态state，只能dispatch action。 对于发出来的action需要用reducer来处理，reducer会计算新的state来替代老的state。 subscribe方法可以注册回调方法，当dispatch action的时候会执行里面的回调。 Redux其实就是一个发布订阅模式！ Redux还支持enhancer，enhancer其实就是一个装饰者模式，传入当前的createStore，返回一个增强的createStore。 Redux使用applyMiddleware支持中间件，applyMiddleware的返回值其实就是一个enhancer。 Redux的中间件也是一个装饰者模式，传入当前的dispatch，返回一个增强了的dispatch。 单纯的Redux是没有View层的，所以他可以跟各种UI库结合使用，比如react-redux，计划下一篇文章就是手写react-redux。 参考资料 官方文档：https://redux.js.org/ GitHub源码：https://github.com/reduxjs/redux "},"Articles/React/React-Redux.html":{"url":"Articles/React/React-Redux.html","title":"手写React-Redux","keywords":"","body":"上一篇文章我们手写了一个Redux，但是单纯的Redux只是一个状态机，是没有UI呈现的，所以一般我们使用的时候都会配合一个UI库，比如在React中使用Redux就会用到React-Redux这个库。这个库的作用是将Redux的状态机和React的UI呈现绑定在一起，当你dispatch action改变state的时候，会自动更新页面。本文还是从它的基本使用入手来自己写一个React-Redux，然后替换官方的NPM库，并保持功能一致。 基本用法 下面这个简单的例子是一个计数器，跑起来效果如下： 要实现这个功能，首先我们要在项目里面添加react-redux库，然后用它提供的Provider包裹整个ReactApp的根组件： import React from 'react'; import ReactDOM from 'react-dom'; import { Provider } from 'react-redux' import store from './store' import App from './App'; ReactDOM.render( , document.getElementById('root') ); 上面代码可以看到我们还给Provider提供了一个参数store，这个参数就是Redux的createStore生成的store，我们需要调一下这个方法，然后将返回的store传进去： import { createStore } from 'redux'; import reducer from './reducer'; let store = createStore(reducer); export default store; 上面代码中createStore的参数是一个reducer，所以我们还要写个reducer: const initState = { count: 0 }; function reducer(state = initState, action) { switch (action.type) { case 'INCREMENT': return {...state, count: state.count + 1}; case 'DECREMENT': return {...state, count: state.count - 1}; case 'RESET': return {...state, count: 0}; default: return state; } } export default reducer; 这里的reduce会有一个初始state，里面的count是0，同时他还能处理三个action，这三个action对应的是UI上的三个按钮，可以对state里面的计数进行加减和重置。到这里其实我们React-Redux的接入和Redux数据的组织其实已经完成了，后面如果要用Redux里面的数据的话，只需要用connectAPI将对应的state和方法连接到组件里面就行了，比如我们的计数器组件需要count这个状态和加一，减一，重置这三个action，我们用connect将它连接进去就是这样： import React from 'react'; import { connect } from 'react-redux'; import { increment, decrement, reset } from './actions'; function Counter(props) { const { count, incrementHandler, decrementHandler, resetHandler } = props; return ( <> Count: {count} 计数+1 计数-1 重置 ); } const mapStateToProps = (state) => { return { count: state.count } } const mapDispatchToProps = (dispatch) => { return { incrementHandler: () => dispatch(increment()), decrementHandler: () => dispatch(decrement()), resetHandler: () => dispatch(reset()), } }; export default connect( mapStateToProps, mapDispatchToProps )(Counter) 上面代码可以看到connect是一个高阶函数，他的第一阶会接收mapStateToProps和mapDispatchToProps两个参数，这两个参数都是函数。mapStateToProps可以自定义需要将哪些state连接到当前组件，这些自定义的state可以在组件里面通过props拿到。mapDispatchToProps方法会传入dispatch函数，我们可以自定义一些方法，这些方法可以调用dispatch去dispatch action，从而触发state的更新，这些自定义的方法也可以通过组件的props拿到，connect的第二阶接收的参数是一个组件，我们可以猜测这个函数的作用就是将前面自定义的state和方法注入到这个组件里面，同时要返回一个新的组件给外部调用，所以connect其实也是一个高阶组件。 到这里我们汇总来看下我们都用到了哪些API，这些API就是我们后面要手写的目标： Provider: 用来包裹根组件的组件，作用是注入Redux的store。 createStore: Redux用来创建store的核心方法，我们另一篇文章已经手写过了。 connect：用来将state和dispatch注入给需要的组件，返回一个新组件，他其实是个高阶组件。 所以React-Redux核心其实就两个API，而且两个都是组件，作用还很类似，都是往组件里面注入参数，Provider是往根组件注入store，connect是往需要的组件注入state和dispatch。 在手写之前我们先来思考下，为什么React-Redux要设计这两个API，假如没有这两个API，只用Redux可以吗？当然是可以的！其实我们用Redux的目的不就是希望用它将整个应用的状态都保存下来，每次操作只用dispatch action去更新状态，然后UI就自动更新了吗？那我从根组件开始，每一级都把store传下去不就行了吗？每个子组件需要读取状态的时候，直接用store.getState()就行了，更新状态的时候就store.dispatch，这样其实也能达到目的。但是，如果这样写，子组件如果嵌套层数很多，每一级都需要手动传入store，比较丑陋，开发也比较繁琐，而且如果某个新同学忘了传store，那后面就是一连串的错误了。所以最好有个东西能够将store全局的注入组件树，而不需要一层层作为props传递，这个东西就是Provider！而且如果每个组件都独立依赖Redux会破坏React的数据流向，这个我们后面会讲到。 React的Context API React其实提供了一个全局注入变量的API，这就是context api。假如我现在有一个需求是要给我们所有组件传一个文字颜色的配置，我们的颜色配置在最顶级的组件上，当这个颜色改变的时候，下面所有组件都要自动应用这个颜色。那我们可以使用context api注入这个配置： 先使用React.createContext创建一个context // 我们使用一个单独的文件来调用createContext // 因为这个返回值会被Provider和Consumer在不同的地方引用 import React from 'react'; const TestContext = React.createContext(); export default TestContext; 使用Context.Provider包裹根组件 创建好了context，如果我们要传递变量给某些组件，我们需要在他们的根组件上加上TestContext.Provider，然后将变量作为value参数传给TestContext.Provider: import TestContext from './TestContext'; const setting = { color: '#d89151' } ReactDOM.render( , document.getElementById('root') ); 使用Context.Consumer接收参数 上面我们使用Context.Provider将参数传递进去了，这样被Context.Provider包裹的所有子组件都可以拿到这个变量，只是拿这个变量的时候需要使用Context.Consumer包裹，比如我们前面的Counter组件就可以拿到这个颜色了，只需要将它返回的JSX用Context.Consumer包裹一下就行： // 注意要引入同一个Context import TestContext from './TestContext'; // ... 中间省略n行代码 ... // 返回的JSX用Context.Consumer包裹起来 // 注意Context.Consumer里面是一个方法，这个方法就可以访问到context参数 // 这里的context也就是前面Provider传进来的setting，我们可以拿到上面的color变量 return ( {context => <> Count: {count} 计数+1&nbsp;&nbsp; 计数-1&nbsp;&nbsp; 重置 } ); 上面代码我们通过context传递了一个全局配置，可以看到我们文字颜色已经变了: 使用useContext接收参数 除了上面的Context.Consumer可以用来接收context参数，新版React还有useContext这个hook可以接收context参数，使用起来更简单，比如上面代码可以这样写： const context = useContext(TestContext); return ( <> Count: {count} 计数+1&nbsp;&nbsp; 计数-1&nbsp;&nbsp; 重置 ); 所以我们完全可以用context api来传递redux store，现在我们也可以猜测React-Redux的Provider其实就是包装了Context.Provider，而传递的参数就是redux store，而React-Redux的connectHOC其实就是包装的Context.Consumer或者useContext。我们可以按照这个思路来自己实现下React-Redux了。 手写Provider 上面说了Provider用了context api，所以我们要先建一个context文件，导出需要用的context： // Context.js import React from 'react'; const ReactReduxContext = React.createContext(); export default ReactReduxContext; 这个文件很简单，新建一个context再导出就行了，对应的源码看这里。 然后将这个context应用到我们的Provider组件里面： import React from 'react'; import ReactReduxContext from './Context'; function Provider(props) { const {store, children} = props; // 这是要传递的context const contextValue = { store }; // 返回ReactReduxContext包裹的组件，传入contextValue // 里面的内容就直接是children，我们不动他 return ( {children} ) } Provider的组件代码也不难，直接将传进来的store放到context上，然后直接渲染children就行，对应的源码看这里。 手写connect 基本功能 其实connect才是React-Redux中最难的部分，里面功能复杂，考虑的因素很多，想要把它搞明白我们需要一层一层的来看，首先我们实现一个只具有基本功能的connect。 import React, { useContext } from 'react'; import ReactReduxContext from './Context'; // 第一层函数接收mapStateToProps和mapDispatchToProps function connect(mapStateToProps, mapDispatchToProps) { // 第二层函数是个高阶组件，里面获取context // 然后执行mapStateToProps和mapDispatchToProps // 再将这个结果组合用户的参数作为最终参数渲染WrappedComponent // WrappedComponent就是我们使用connext包裹的自己的组件 return function connectHOC(WrappedComponent) { function ConnectFunction(props) { // 复制一份props到wrapperProps const { ...wrapperProps } = props; // 获取context的值 const context = useContext(ReactReduxContext); const { store } = context; // 解构出store const state = store.getState(); // 拿到state // 执行mapStateToProps和mapDispatchToProps const stateProps = mapStateToProps(state); const dispatchProps = mapDispatchToProps(store.dispatch); // 组装最终的props const actualChildProps = Object.assign({}, stateProps, dispatchProps, wrapperProps); // 渲染WrappedComponent return } return ConnectFunction; } } export default connect; 触发更新 用上面的Provider和connect替换官方的react-redux其实已经可以渲染出页面了，但是点击按钮还不会有反应，因为我们虽然通过dispatch改变了store中的state，但是这种改变并没有触发我们组件的更新。之前Redux那篇文章讲过，可以用store.subscribe来监听state的变化并执行回调，我们这里需要注册的回调是检查我们最终给WrappedComponent的props有没有变化，如果有变化就重新渲染ConnectFunction，所以这里我们需要解决两个问题： 当我们state变化的时候检查最终给到ConnectFunction的参数有没有变化 如果这个参数有变化，我们需要重新渲染ConnectFunction 检查参数变化 要检查参数的变化，我们需要知道上次渲染的参数和本地渲染的参数，然后拿过来比一下就知道了。为了知道上次渲染的参数，我们可以直接在ConnectFunction里面使用useRef将上次渲染的参数记录下来： // 记录上次渲染参数 const lastChildProps = useRef(); useLayoutEffect(() => { lastChildProps.current = actualChildProps; }, []); 注意lastChildProps.current是在第一次渲染结束后赋值，而且需要使用useLayoutEffect来保证渲染后立即同步执行。 因为我们检测参数变化是需要重新计算actualChildProps，计算的逻辑其实都是一样的，我们将这块计算逻辑抽出来，成为一个单独的方法childPropsSelector: function childPropsSelector(store, wrapperProps) { const state = store.getState(); // 拿到state // 执行mapStateToProps和mapDispatchToProps const stateProps = mapStateToProps(state); const dispatchProps = mapDispatchToProps(store.dispatch); return Object.assign({}, stateProps, dispatchProps, wrapperProps); } 然后就是注册store的回调，在里面来检测参数是否变了，如果变了就强制更新当前组件，对比两个对象是否相等，React-Redux里面是采用的shallowEqual，也就是浅比较，也就是只对比一层，如果你mapStateToProps返回了好几层结构，比如这样： { stateA: { value: 1 } } 你去改了stateA.value是不会触发重新渲染的，React-Redux这样设计我想是出于性能考虑，如果是深比较，比如递归去比较，比较浪费性能，而且如果有循环引用还可能造成死循环。采用浅比较就需要用户遵循这种范式，不要传入多层结构，这点在官方文档中也有说明。我们这里直接抄一个它的浅比较： // shallowEqual.js function is(x, y) { if (x === y) { return x !== 0 || y !== 0 || 1 / x === 1 / y } else { return x !== x && y !== y } } export default function shallowEqual(objA, objB) { if (is(objA, objB)) return true if ( typeof objA !== 'object' || objA === null || typeof objB !== 'object' || objB === null ) { return false } const keysA = Object.keys(objA) const keysB = Object.keys(objB) if (keysA.length !== keysB.length) return false for (let i = 0; i 在回调里面检测参数变化: // 注册回调 store.subscribe(() => { const newChildProps = childPropsSelector(store, wrapperProps); // 如果参数变了，记录新的值到lastChildProps上 // 并且强制更新当前组件 if(!shallowEqual(newChildProps, lastChildProps.current)) { lastChildProps.current = newChildProps; // 需要一个API来强制更新当前组件 } }); 强制更新 要强制更新当前组件的方法不止一个，如果你是用的Class组件，你可以直接this.setState({})，老版的React-Redux就是这么干的。但是新版React-Redux用hook重写了，那我们可以用React提供的useReducer或者useStatehook，React-Redux源码用了useReducer，为了跟他保持一致，我也使用useReducer: function storeStateUpdatesReducer(count) { return count + 1; } // ConnectFunction里面 function ConnectFunction(props) { // ... 前面省略n行代码 ... // 使用useReducer触发强制更新 const [ , forceComponentUpdateDispatch ] = useReducer(storeStateUpdatesReducer, 0); // 注册回调 store.subscribe(() => { const newChildProps = childPropsSelector(store, wrapperProps); if(!shallowEqual(newChildProps, lastChildProps.current)) { lastChildProps.current = newChildProps; forceComponentUpdateDispatch(); } }); // ... 后面省略n行代码 ... } connect这块代码主要对应的是源码中connectAdvanced这个类，基本原理和结构跟我们这个都是一样的，只是他写的更灵活，支持用户传入自定义的childPropsSelector和合并stateProps, dispatchProps, wrapperProps的方法。有兴趣的朋友可以去看看他的源码：https://github.com/reduxjs/react-redux/blob/master/src/components/connectAdvanced.js 到这里其实已经可以用我们自己的React-Redux替换官方的了，计数器的功能也是支持了。但是下面还想讲一下React-Redux是怎么保证组件的更新顺序的，因为源码中很多代码都是在处理这个。 保证组件更新顺序 前面我们的Counter组件使用connect连接了redux store，假如他下面还有个子组件也连接到了redux store，我们就要考虑他们的回调的执行顺序的问题了。我们知道React是单向数据流的，参数都是由父组件传给子组件的，现在引入了Redux，即使父组件和子组件都引用了同一个变量count，但是子组件完全可以不从父组件拿这个参数，而是直接从Redux拿，这样就打破了React本来的数据流向。在父->子这种单向数据流中，如果他们的一个公用变量变化了，肯定是父组件先更新，然后参数传给子组件再更新，但是在Redux里，数据变成了Redux -> 父，Redux -> 子，父与子完全可以根据Redux的数据进行独立更新，而不能完全保证父级先更新，子级再更新的流程。所以React-Redux花了不少功夫来手动保证这个更新顺序，React-Redux保证这个更新顺序的方案是在redux store外，再单独创建一个监听者类Subscription： Subscription负责处理所有的state变化的回调 如果当前连接redux的组件是第一个连接redux的组件，也就是说他是连接redux的根组件，他的state回调直接注册到redux store；同时新建一个Subscription实例subscription通过context传递给子级。 如果当前连接redux的组件不是连接redux的根组件，也就是说他上面有组件已经注册到redux store了，那么他可以拿到上面通过context传下来的subscription，源码里面这个变量叫parentSub，那当前组件的更新回调就注册到parentSub上。同时再新建一个Subscription实例，替代context上的subscription，继续往下传，也就是说他的子组件的回调会注册到当前subscription上。 当state变化了，根组件注册到redux store上的回调会执行更新根组件，同时根组件需要手动执行子组件的回调，子组件回调执行会触发子组件更新，然后子组件再执行自己subscription上注册的回调，触发孙子组件更新，孙子组件再调用注册到自己subscription上的回调。。。这样就实现了从根组件开始，一层一层更新子组件的目的，保证了父->子这样的更新顺序。 Subscription类 所以我们先新建一个Subscription类： export default class Subscription { constructor(store, parentSub) { this.store = store this.parentSub = parentSub this.listeners = []; // 源码listeners是用链表实现的，我这里简单处理，直接数组了 this.handleChangeWrapper = this.handleChangeWrapper.bind(this) } // 子组件注册回调到Subscription上 addNestedSub(listener) { this.listeners.push(listener) } // 执行子组件的回调 notifyNestedSubs() { const length = this.listeners.length; for(let i = 0; i Subscription对应的源码看这里。 改造Provider 然后在我们前面自己实现的React-Redux里面，我们的根组件始终是Provider，所以Provider需要实例化一个Subscription并放到context上，而且每次state更新的时候需要手动调用子组件回调，代码改造如下： import React, { useMemo, useEffect } from 'react'; import ReactReduxContext from './Context'; import Subscription from './Subscription'; function Provider(props) { const {store, children} = props; // 这是要传递的context // 里面放入store和subscription实例 const contextValue = useMemo(() => { const subscription = new Subscription(store) // 注册回调为通知子组件，这样就可以开始层级通知了 subscription.onStateChange = subscription.notifyNestedSubs return { store, subscription } }, [store]) // 拿到之前的state值 const previousState = useMemo(() => store.getState(), [store]) // 每次contextValue或者previousState变化的时候 // 用notifyNestedSubs通知子组件 useEffect(() => { const { subscription } = contextValue; subscription.trySubscribe() if (previousState !== store.getState()) { subscription.notifyNestedSubs() } }, [contextValue, previousState]) // 返回ReactReduxContext包裹的组件，传入contextValue // 里面的内容就直接是children，我们不动他 return ( {children} ) } export default Provider; 改造connect 有了Subscription类，connect就不能直接注册到store了，而是应该注册到父级subscription上，更新的时候除了更新自己还要通知子组件更新。在渲染包裹的组件时，也不能直接渲染了，而是应该再次使用Context.Provider包裹下，传入修改过的contextValue，这个contextValue里面的subscription应该替换为自己的。改造后代码如下： import React, { useContext, useRef, useLayoutEffect, useReducer } from 'react'; import ReactReduxContext from './Context'; import shallowEqual from './shallowEqual'; import Subscription from './Subscription'; function storeStateUpdatesReducer(count) { return count + 1; } function connect( mapStateToProps = () => {}, mapDispatchToProps = () => {} ) { function childPropsSelector(store, wrapperProps) { const state = store.getState(); // 拿到state // 执行mapStateToProps和mapDispatchToProps const stateProps = mapStateToProps(state); const dispatchProps = mapDispatchToProps(store.dispatch); return Object.assign({}, stateProps, dispatchProps, wrapperProps); } return function connectHOC(WrappedComponent) { function ConnectFunction(props) { const { ...wrapperProps } = props; const contextValue = useContext(ReactReduxContext); const { store, subscription: parentSub } = contextValue; // 解构出store和parentSub const actualChildProps = childPropsSelector(store, wrapperProps); const lastChildProps = useRef(); useLayoutEffect(() => { lastChildProps.current = actualChildProps; }, [actualChildProps]); const [ , forceComponentUpdateDispatch ] = useReducer(storeStateUpdatesReducer, 0) // 新建一个subscription实例 const subscription = new Subscription(store, parentSub); // state回调抽出来成为一个方法 const checkForUpdates = () => { const newChildProps = childPropsSelector(store, wrapperProps); // 如果参数变了，记录新的值到lastChildProps上 // 并且强制更新当前组件 if(!shallowEqual(newChildProps, lastChildProps.current)) { lastChildProps.current = newChildProps; // 需要一个API来强制更新当前组件 forceComponentUpdateDispatch(); // 然后通知子级更新 subscription.notifyNestedSubs(); } }; // 使用subscription注册回调 subscription.onStateChange = checkForUpdates; subscription.trySubscribe(); // 修改传给子级的context // 将subscription替换为自己的 const overriddenContextValue = { ...contextValue, subscription } // 渲染WrappedComponent // 再次使用ReactReduxContext包裹，传入修改过的context return ( ) } return ConnectFunction; } } export default connect; 下面我们再来总结下React-Redux的核心原理。 总结 React-Redux是连接React和Redux的库，同时使用了React和Redux的API。 React-Redux主要是使用了React的context api来传递Redux的store。 Provider的作用是接收Redux store并将它放到context上传递下去。 connect的作用是从Redux store中选取需要的属性传递给包裹的组件。 connect会自己判断是否需要更新，判断的依据是需要的state是否已经变化了。 connect在判断是否变化的时候使用的是浅比较，也就是只比较一层，所以在mapStateToProps和mapDispatchToProps中不要反回多层嵌套的对象。 为了解决父组件和子组件各自独立依赖Redux，破坏了React的父级->子级的更新流程，React-Redux使用Subscription类自己管理了一套通知流程。 只有连接到Redux最顶级的组件才会直接注册到Redux store，其他子组件都会注册到最近父组件的subscription实例上。 通知的时候从根组件开始依次通知自己的子组件，子组件接收到通知的时候，先更新自己再通知自己的子组件。 参考资料 官方文档：https://react-redux.js.org/ GitHub源码：https://github.com/reduxjs/react-redux/ "},"Articles/React/Redux-Thunk.html":{"url":"Articles/React/Redux-Thunk.html","title":"Redux-Thunk原理及源码","keywords":"","body":"前段时间，我们写了一篇Redux源码分析的文章，也分析了跟React连接的库React-Redux的源码实现。但是在Redux的生态中还有一个很重要的部分没有涉及到，那就是Redux的异步解决方案。本文会讲解Redux官方实现的异步解决方案----Redux-Thunk，我们还是会从基本的用法入手，再到原理解析，然后自己手写一个Redux-Thunk来替换它，也就是源码解析。 Redux-Thunk和前面写过的Redux和React-Redux其实都是Redux官方团队的作品，他们的侧重点各有不同: Redux：是核心库，功能简单，只是一个单纯的状态机，但是蕴含的思想不简单，是传说中的“百行代码，千行文档”。 React-Redux：是跟React的连接库，当Redux状态更新的时候通知React更新组件。 Redux-Thunk：提供Redux的异步解决方案，弥补Redux功能的不足。 基本用法 还是以我们之前的那个计数器作为例子，为了让计数器+1，我们会发出一个action，像这样： function increment() { return { type: 'INCREMENT' } }; store.dispatch(increment()); 原始的Redux里面，action creator必须返回plain object，而且必须是同步的。但是我们的应用里面经常会有定时器，网络请求等等异步操作，使用Redux-Thunk就可以发出异步的action： function increment() { return { type: 'INCREMENT' } }; // 异步action creator function incrementAsync() { return (dispatch) => { setTimeout(() => { dispatch(increment()); }, 1000); } } // 使用了Redux-Thunk后dispatch不仅仅可以发出plain object，还可以发出这个异步的函数 store.dispatch(incrementAsync()); 下面再来看个更实际点的例子，也是官方文档中的例子： import { createStore, applyMiddleware } from 'redux'; import thunk from 'redux-thunk'; import rootReducer from './reducers'; // createStore的时候传入thunk中间件 const store = createStore(rootReducer, applyMiddleware(thunk)); // 发起网络请求的方法 function fetchSecretSauce() { return fetch('https://www.baidu.com/s?wd=Secret%20Sauce'); } // 下面两个是普通的action function makeASandwich(forPerson, secretSauce) { return { type: 'MAKE_SANDWICH', forPerson, secretSauce, }; } function apologize(fromPerson, toPerson, error) { return { type: 'APOLOGIZE', fromPerson, toPerson, error, }; } // 这是一个异步action，先请求网络，成功就makeASandwich，失败就apologize function makeASandwichWithSecretSauce(forPerson) { return function (dispatch) { return fetchSecretSauce().then( (sauce) => dispatch(makeASandwich(forPerson, sauce)), (error) => dispatch(apologize('The Sandwich Shop', forPerson, error)), ); }; } // 最终dispatch的是异步action makeASandwichWithSecretSauce store.dispatch(makeASandwichWithSecretSauce('Me')); 为什么要用Redux-Thunk？ 在继续深入源码前，我们先来思考一个问题，为什么我们要用Redux-Thunk，不用它行不行？再仔细看看Redux-Thunk的作用： // 异步action creator function incrementAsync() { return (dispatch) => { setTimeout(() => { dispatch(increment()); }, 1000); } } store.dispatch(incrementAsync()); 他仅仅是让dispath多支持了一种类型，就是函数类型，在使用Redux-Thunk前我们dispatch的action必须是一个纯对象(plain object)，使用了Redux-Thunk后，dispatch可以支持函数，这个函数会传入dispatch本身作为参数。但是其实我们不使用Redux-Thunk也可以达到同样的效果，比如上面代码我完全可以不要外层的incrementAsync，直接这样写： setTimeout(() => { store.dispatch(increment()); }, 1000); 这样写同样可以在1秒后发出增加的action，而且代码还更简单，那我们为什么还要用Redux-Thunk呢，他存在的意义是什么呢？stackoverflow对这个问题有一个很好的回答，而且是官方推荐的解释。我再写一遍也不会比他写得更好，所以我就直接翻译了： ----翻译从这里开始---- 不要觉得一个库就应该规定了所有事情！如果你想用JS处理一个延时任务，直接用setTimeout就好了，即使你使用了Redux也没啥区别。Redux确实提供了另一种处理异步任务的机制，但是你应该用它来解决你很多重复代码的问题。如果你没有太多重复代码，使用语言原生方案其实是最简单的方案。 直接写异步代码 到目前为止这是最简单的方案，Redux也不需要特殊的配置： store.dispatch({ type: 'SHOW_NOTIFICATION', text: 'You logged in.' }) setTimeout(() => { store.dispatch({ type: 'HIDE_NOTIFICATION' }) }, 5000) (译注：这段代码的功能是显示一个通知，5秒后自动消失，也就是我们经常使用的toast效果，原作者一直以这个为例。) 相似的，如果你是在一个连接了Redux组件中使用： this.props.dispatch({ type: 'SHOW_NOTIFICATION', text: 'You logged in.' }) setTimeout(() => { this.props.dispatch({ type: 'HIDE_NOTIFICATION' }) }, 5000) 唯一的区别就是连接组件一般不需要直接使用store，而是将dispatch或者action creator作为props注入，这两种方式对我们都没区别。 如果你不想写重复的action名字，你可以将这两个action抽取成action creator而不是直接dispatch一个对象: // actions.js export function showNotification(text) { return { type: 'SHOW_NOTIFICATION', text } } export function hideNotification() { return { type: 'HIDE_NOTIFICATION' } } // component.js import { showNotification, hideNotification } from '../actions' this.props.dispatch(showNotification('You just logged in.')) setTimeout(() => { this.props.dispatch(hideNotification()) }, 5000) 或者你已经通过connect()注入了这两个action creator： this.props.showNotification('You just logged in.') setTimeout(() => { this.props.hideNotification() }, 5000) 到目前为止，我们没有使用任何中间件或者其他高级技巧，但是我们同样实现了异步任务的处理。 提取异步的Action Creator 使用上面的方式在简单场景下可以工作的很好，但是你可能已经发现了几个问题： 每次你想显示toast的时候，你都得把这一大段代码抄过来抄过去。 现在的toast没有id，这可能会导致一种竞争的情况：如果你连续快速的显示两次toast，当第一次的结束时，他会dispatch出HIDE_NOTIFICATION，这会错误的导致第二个也被关掉。 为了解决这两个问题，你可能需要将toast的逻辑抽取出来作为一个方法，大概长这样： // actions.js function showNotification(id, text) { return { type: 'SHOW_NOTIFICATION', id, text } } function hideNotification(id) { return { type: 'HIDE_NOTIFICATION', id } } let nextNotificationId = 0 export function showNotificationWithTimeout(dispatch, text) { // 给通知分配一个ID可以让reducer忽略非当前通知的HIDE_NOTIFICATION // 而且我们把计时器的ID记录下来以便于后面用clearTimeout()清除计时器 const id = nextNotificationId++ dispatch(showNotification(id, text)) setTimeout(() => { dispatch(hideNotification(id)) }, 5000) } 现在你的组件可以直接使用showNotificationWithTimeout，再也不用抄来抄去了，也不用担心竞争问题了： // component.js showNotificationWithTimeout(this.props.dispatch, 'You just logged in.') // otherComponent.js showNotificationWithTimeout(this.props.dispatch, 'You just logged out.') 但是为什么showNotificationWithTimeout()要接收dispatch作为第一个参数呢？因为他需要将action发给store。一般组件是可以拿到dispatch的，为了让外部方法也能dispatch，我们需要给他dispath作为参数。 如果你有一个单例的store，你也可以让showNotificationWithTimeout直接引入这个store然后dispatch action： // store.js export default createStore(reducer) // actions.js import store from './store' // ... let nextNotificationId = 0 export function showNotificationWithTimeout(text) { const id = nextNotificationId++ store.dispatch(showNotification(id, text)) setTimeout(() => { store.dispatch(hideNotification(id)) }, 5000) } // component.js showNotificationWithTimeout('You just logged in.') // otherComponent.js showNotificationWithTimeout('You just logged out.') 这样做看起来不复杂，也能达到效果，但是我们不推荐这种做法！主要原因是你的store必须是单例的，这让Server Render实现起来很麻烦。在Server端，你会希望每个请求都有自己的store，比便于不同的用户可以拿到不同的预加载内容。 一个单例的store也让单元测试很难写。测试action creator的时候你很难mock store，因为他引用了一个具体的真实的store。你甚至不能从外部重置store状态。 所以从技术上来说，你可以从一个module导出单例的store，但是我们不鼓励这样做。除非你确定加肯定你以后都不会升级Server Render。所以我们还是回到前面一种方案吧： // actions.js // ... let nextNotificationId = 0 export function showNotificationWithTimeout(dispatch, text) { const id = nextNotificationId++ dispatch(showNotification(id, text)) setTimeout(() => { dispatch(hideNotification(id)) }, 5000) } // component.js showNotificationWithTimeout(this.props.dispatch, 'You just logged in.') // otherComponent.js showNotificationWithTimeout(this.props.dispatch, 'You just logged out.') 这个方案就可以解决重复代码和竞争问题。 Thunk中间件 对于简单项目，上面的方案应该已经可以满足需求了。 但是对于大型项目，你可能还是会觉得这样使用并不方便。 比如，似乎我们必须将dispatch作为参数传递，这让我们分隔容器组件和展示组件变得更困难，因为任何发出异步Redux action的组件都必须接收dispatch作为参数，这样他才能将它继续往下传。你也不能仅仅使用connect()来绑定action creator，因为showNotificationWithTimeout()并不是一个真正的action creator，他返回的也不是Redux action。 还有个很尴尬的事情是，你必须记住哪个action cerator是同步的，比如showNotification，哪个是异步的辅助方法，比如showNotificationWithTimeout。这两个的用法是不一样的，你需要小心的不要传错了参数，也不要混淆了他们。 这就是我们为什么需要找到一个“合法”的方法给辅助方法提供dispatch参数，并且帮助Redux区分出哪些是异步的action creator，好特殊处理他们。 如果你的项目中面临着类似的问题，欢迎使用Redux Thunk中间件。 简单来说，React Thunk告诉Redux怎么去区分这种特殊的action----他其实是个函数： import { createStore, applyMiddleware } from 'redux' import thunk from 'redux-thunk' const store = createStore( reducer, applyMiddleware(thunk) ) // 这个是普通的纯对象action store.dispatch({ type: 'INCREMENT' }) // 但是有了Thunk，他就可以识别函数了 store.dispatch(function (dispatch) { // 这个函数里面又可以dispatch很多action dispatch({ type: 'INCREMENT' }) dispatch({ type: 'INCREMENT' }) dispatch({ type: 'INCREMENT' }) setTimeout(() => { // 异步的dispatch也可以 dispatch({ type: 'DECREMENT' }) }, 1000) }) 如果你使用了这个中间件，而且你dispatch的是一个函数，React Thunk会自己将dispatch作为参数传进去。而且他会将这些函数action“吃了”，所以不用担心你的reducer会接收到奇怪的函数参数。你的reducer只会接收到纯对象action，无论是直接发出的还是前面那些异步函数发出的。 这个看起来好像也没啥大用，对不对？在当前这个例子确实是的！但是他让我们可以像定义一个普通的action creator那样去定义showNotificationWithTimeout： // actions.js function showNotification(id, text) { return { type: 'SHOW_NOTIFICATION', id, text } } function hideNotification(id) { return { type: 'HIDE_NOTIFICATION', id } } let nextNotificationId = 0 export function showNotificationWithTimeout(text) { return function (dispatch) { const id = nextNotificationId++ dispatch(showNotification(id, text)) setTimeout(() => { dispatch(hideNotification(id)) }, 5000) } } 注意这里的showNotificationWithTimeout跟我们前面的那个看起来非常像，但是他并不需要接收dispatch作为第一个参数。而是返回一个函数来接收dispatch作为第一个参数。 那在我们的组件中怎么使用这个函数呢，我们当然可以这样写： // component.js showNotificationWithTimeout('You just logged in.')(this.props.dispatch) 这样我们直接调用了异步的action creator来得到内层的函数，这个函数需要dispatch做为参数，所以我们给了他dispatch参数。 然而这样使用岂不是更尬，还不如我们之前那个版本的！我们为啥要这么干呢？ 我之前就告诉过你：只要使用了Redux Thunk，如果你想dispatch一个函数，而不是一个纯对象，这个中间件会自己帮你调用这个函数，而且会将dispatch作为第一个参数传进去。 所以我们可以直接这样干： // component.js this.props.dispatch(showNotificationWithTimeout('You just logged in.')) 最后，对于组件来说，dispatch一个异步的action(其实是一堆普通action)看起来和dispatch一个普通的同步action看起来并没有啥区别。这是个好现象，因为组件就不应该关心那些动作到底是同步的还是异步的，我们已经将它抽象出来了。 注意因为我们已经教了Redux怎么区分这些特殊的action creator(我们称之为thunk action creator)，现在我们可以在任何普通的action creator的地方使用他们了。比如，我们可以直接在connect()中使用他们： // actions.js function showNotification(id, text) { return { type: 'SHOW_NOTIFICATION', id, text } } function hideNotification(id) { return { type: 'HIDE_NOTIFICATION', id } } let nextNotificationId = 0 export function showNotificationWithTimeout(text) { return function (dispatch) { const id = nextNotificationId++ dispatch(showNotification(id, text)) setTimeout(() => { dispatch(hideNotification(id)) }, 5000) } } // component.js import { connect } from 'react-redux' // ... this.props.showNotificationWithTimeout('You just logged in.') // ... export default connect( mapStateToProps, { showNotificationWithTimeout } )(MyComponent) 在Thunk中读取State 通常来说，你的reducer会包含计算新的state的逻辑，但是reducer只有当你dispatch了action才会触发。如果你在thunk action creator中有一个副作用(比如一个API调用)，某些情况下，你不想发出这个action该怎么办呢？ 如果没有Thunk中间件，你需要在组件中添加这个逻辑： // component.js if (this.props.areNotificationsEnabled) { showNotificationWithTimeout(this.props.dispatch, 'You just logged in.') } 但是我们提取action creator的目的就是为了集中这些在各个组件中重复的逻辑。幸运的是，Redux Thunk提供了一个读取当前store state的方法。那就是除了传入dispatch参数外，他还会传入getState作为第二个参数，这样thunk就可以读取store的当前状态了。 let nextNotificationId = 0 export function showNotificationWithTimeout(text) { return function (dispatch, getState) { // 不像普通的action cerator，这里我们可以提前退出 // Redux不关心这里的返回值，没返回值也没关系 if (!getState().areNotificationsEnabled) { return } const id = nextNotificationId++ dispatch(showNotification(id, text)) setTimeout(() => { dispatch(hideNotification(id)) }, 5000) } } 但是不要滥用这种方法！如果你需要通过检查缓存来判断是否发起API请求，这种方法就很好，但是将你整个APP的逻辑都构建在这个基础上并不是很好。如果你只是用getState来做条件判断是否要dispatch action，你可以考虑将这些逻辑放到reducer里面去。 下一步 现在你应该对thunk的工作原理有了一个基本的概念，如果你需要更多的例子，可以看这里:https://redux.js.org/introduction/examples#async。 你可能会发现很多例子都返回了Promise，这个不是必须的，但是用起来却很方便。Redux并不关心你的thunk返回了什么值，但是他会将这个值通过外层的dispatch()返回给你。这就是为什么你可以在thunk中返回一个Promise并且等他完成： dispatch(someThunkReturningPromise()).then(...) 另外你还可以将一个复杂的thunk action creator拆分成几个更小的thunk action creator。这是因为thunk提供的dispatch也可以接收thunk，所以你可以一直嵌套的dispatch thunk。而且结合Promise的话可以更好的控制异步流程。 在一些更复杂的应用中，你可能会发现你的异步控制流程通过thunk很难表达。比如，重试失败的请求，使用token进行重新授权认证，或者在一步一步的引导流程中，使用这种方式可能会很繁琐，而且容易出错。如果你有这些需求，你可以考虑下一些更高级的异步流程控制库，比如Redux Saga或者Redux Loop。可以看看他们，评估下，哪个更适合你的需求，选一个你最喜欢的。 最后，不要使用任何库(包括thunk)如果你没有真实的需求。记住，我们的实现都是要看需求的，也许你的需求这个简单的方案就能满足： store.dispatch({ type: 'SHOW_NOTIFICATION', text: 'You logged in.' }) setTimeout(() => { store.dispatch({ type: 'HIDE_NOTIFICATION' }) }, 5000) 不要跟风尝试，除非你知道你为什么需要这个！ ----翻译到此结束---- StackOverflow的大神Dan Abramov对这个问题的回答实在太细致，太到位了，以致于我看了之后都不敢再写这个原因了，以此翻译向大神致敬，再贴下这个回答的地址：https://stackoverflow.com/questions/35411423/how-to-dispatch-a-redux-action-with-a-timeout/35415559#35415559。 PS: Dan Abramov是Redux生态的核心作者，这几篇文章讲的Redux，React-Redux，Redux-Thunk都是他的作品。 源码解析 上面关于原因的翻译其实已经将Redux适用的场景和原理讲的很清楚了，下面我们来看看他的源码，自己仿写一个来替换他。照例我们先来分析下要点: Redux-Thunk是一个Redux中间件，所以他遵守Redux中间件的范式。 thunk是一个可以dispatch的函数，所以我们需要改写dispatch让他接受函数参数。 Redux中间件范式 在我前面那篇讲Redux源码的文章讲过中间件的范式以及Redux中这块源码是怎么实现的，没看过或者忘了的朋友可以再去看看。我这里再简单提一下，一个Redux中间件结构大概是这样： function logger(store) { return function(next) { return function(action) { console.group(action.type); console.info('dispatching', action); let result = next(action); console.log('next state', store.getState()); console.groupEnd(); return result } } } 这里注意几个要点： 一个中间件接收store作为参数，会返回一个函数 返回的这个函数接收老的dispatch函数作为参数(也就是代码中的next)，会返回一个新的函数 返回的新函数就是新的dispatch函数，这个函数里面可以拿到外面两层传进来的store和老dispatch函数 仿照这个范式，我们来写一下thunk中间件的结构： function thunk(store) { return function (next) { return function (action) { // 先直接返回原始结果 let result = next(action); return result } } } 处理thunk 根据我们前面讲的，thunk是一个函数，接收dispatch getState两个参数，所以我们应该将thunk拿出来运行，然后给他传入这两个参数，再将它的返回值直接返回就行。 function thunk(store) { return function (next) { return function (action) { // 从store中解构出dispatch, getState const { dispatch, getState } = store; // 如果action是函数，将它拿出来运行，参数就是dispatch和getState if (typeof action === 'function') { return action(dispatch, getState); } // 否则按照普通action处理 let result = next(action); return result } } } 接收额外参数withExtraArgument Redux-Thunk还提供了一个API，就是你在使用applyMiddleware引入的时候，可以使用withExtraArgument注入几个自定义的参数，比如这样： const api = \"http://www.example.com/sandwiches/\"; const whatever = 42; const store = createStore( reducer, applyMiddleware(thunk.withExtraArgument({ api, whatever })), ); function fetchUser(id) { return (dispatch, getState, { api, whatever }) => { // 现在你可以使用这个额外的参数api和whatever了 }; } 这个功能要实现起来也很简单，在前面的thunk函数外面再包一层就行: // 外面再包一层函数createThunkMiddleware接收额外的参数 function createThunkMiddleware(extraArgument) { return function thunk(store) { return function (next) { return function (action) { const { dispatch, getState } = store; if (typeof action === 'function') { // 这里执行函数时，传入extraArgument return action(dispatch, getState, extraArgument); } let result = next(action); return result } } } } 然后我们的thunk中间件其实相当于没传extraArgument： const thunk = createThunkMiddleware(); 而暴露给外面的withExtraArgument函数就直接是createThunkMiddleware了： thunk.withExtraArgument = createThunkMiddleware; 源码解析到此结束。啥，这就完了？是的，这就完了！Redux-Thunk就是这么简单，虽然背后的思想比较复杂，但是代码真的只有14行！我当时也震惊了，来看看官方源码吧: function createThunkMiddleware(extraArgument) { return ({ dispatch, getState }) => (next) => (action) => { if (typeof action === 'function') { return action(dispatch, getState, extraArgument); } return next(action); }; } const thunk = createThunkMiddleware(); thunk.withExtraArgument = createThunkMiddleware; export default thunk; 总结 如果是Redux是“百行代码，千行文档”，那Redux-Thunk就是“十行代码，百行思想”。 Redux-Thunk最主要的作用是帮你给异步action传入dispatch，这样你就不用从调用的地方手动传入dispatch，从而实现了调用的地方和使用的地方的解耦。 Redux和Redux-Thunk让我深深体会到什么叫“编程思想”，编程思想可以很复杂，但是实现可能并不复杂，但是却非常有用。 在我们评估是否要引入一个库时最好想清楚我们为什么要引入这个库，是否有更简单的方案。 参考资料 Redux-Thunk文档：https://github.com/reduxjs/redux-thunk Redux-Thunk源码: https://github.com/reduxjs/redux-thunk/blob/master/src/index.js Dan Abramov在StackOverflow上的回答: https://stackoverflow.com/questions/35411423/how-to-dispatch-a-redux-action-with-a-timeout/35415559#35415559 "},"Articles/React/Redux-Saga.html":{"url":"Articles/React/Redux-Saga.html","title":"手写Redux-Saga源码","keywords":"","body":"上一篇文章我们分析了Redux-Thunk的源码，可以看到他的代码非常简单，只是让dispatch可以处理函数类型的action，其作者也承认对于复杂场景，Redux-Thunk并不适用，还推荐了Redux-Saga来处理复杂副作用。本文要讲的就是Redux-Saga，这个也是我在实际工作中使用最多的Redux异步解决方案。Redux-Saga比Redux-Thunk复杂得多，而且他整个异步流程都使用Generator来处理，Generator也是我们这篇文章的前置知识，如果你对Generator还不熟悉，可以看看这篇文章。 本文仍然是老套路，先来一个Redux-Saga的简单例子，然后我们自己写一个Redux-Saga来替代他，也就是源码分析。 简单例子 网络请求是我们经常需要处理的异步操作，假设我们现在的一个简单需求就是点击一个按钮去请求用户的信息，大概长这样： 这个需求使用Redux实现起来也很简单，点击按钮的时候dispatch出一个action。这个action会触发一个请求，请求返回的数据拿来显示在页面上就行： import React from 'react'; import { connect } from 'react-redux'; function App(props) { const { dispatch, userInfo } = props; const getUserInfo = () => { dispatch({ type: 'FETCH_USER_INFO' }) } return ( Get User Info {userInfo && JSON.stringify(userInfo)} ); } const matStateToProps = (state) => ({ userInfo: state.userInfo }) export default connect(matStateToProps)(App); 上面这种写法都是我们之前讲Redux就介绍过的，Redux-Saga介入的地方是dispatch({ type: 'FETCH_USER_INFO' })之后。按照Redux一般的流程，FETCH_USER_INFO被发出后应该进入reducer处理，但是reducer都是同步代码，并不适合发起网络请求，所以我们可以使用Redux-Saga来捕获FETCH_USER_INFO并处理。 Redux-Saga是一个Redux中间件，所以我们在createStore的时候将它引入就行： // store.js import { createStore, applyMiddleware } from 'redux'; import createSagaMiddleware from 'redux-saga'; import reducer from './reducer'; import rootSaga from './saga'; const sagaMiddleware = createSagaMiddleware() let store = createStore(reducer, applyMiddleware(sagaMiddleware)); // 注意这里，sagaMiddleware作为中间件放入Redux后 // 还需要手动启动他来运行rootSaga sagaMiddleware.run(rootSaga); export default store; 注意上面代码里的这一行： sagaMiddleware.run(rootSaga); sagaMiddleware.run是用来手动启动rootSaga的，我们来看看rootSaga是怎么写的： import { call, put, takeLatest } from 'redux-saga/effects'; import { fetchUserInfoAPI } from './api'; function* fetchUserInfo() { try { const user = yield call(fetchUserInfoAPI); yield put({ type: \"FETCH_USER_SUCCEEDED\", payload: user }); } catch (e) { yield put({ type: \"FETCH_USER_FAILED\", payload: e.message }); } } function* rootSaga() { yield takeEvery(\"FETCH_USER_INFO\", fetchUserInfo); } export default rootSaga; 上面的代码我们从export开始看吧，export的东西是rootSaga这个Generator函数，这里面就一行: yield takeEvery(\"FETCH_USER_INFO\", fetchUserInfo); 这一行代码用到了Redux-Saga的一个effect，也就是takeEvery，他的作用是监听每个FETCH_USER_INFO,当FETCH_USER_INFO出现的时候，就调用fetchUserInfo函数，注意这里是每个FETCH_USER_INFO。也就是说如果同时发出多个FETCH_USER_INFO，我们每个都会响应并发起请求。类似的还有takeLatest，takeLatest从名字都可以看出来，是响应最后一个请求，具体使用哪一个，要看具体的需求。 然后看看fetchUserInfo函数，这个函数也不复杂，就是调用一个API函数fetchUserInfoAPI去获取数据，注意我们这里函数调用并不是直接的fetchUserInfoAPI()，而是使用了Redux-Saga的call这个effect，这样做可以让我们写单元测试变得更简单，为什么会这样，我们后面讲源码的时候再来仔细看看。获取数据后，我们调用了put去发出FETCH_USER_SUCCEEDED这个action，这里的put类似于Redux里面的dispatch，也是用来发出action的。这样我们的reducer就可以拿到FETCH_USER_SUCCEEDED进行处理了，跟以前的reducer并没有太大区别。 // reducer.js const initState = { userInfo: null, error: '' }; function reducer(state = initState, action) { switch (action.type) { case 'FETCH_USER_SUCCEEDED': return { ...state, userInfo: action.payload }; case 'FETCH_USER_FAILED': return { ...state, error: action.payload }; default: return state; } } export default reducer; 通过这个例子的代码结构我们可以看出： action被分为了两种，一种是触发异步处理的，一种是普通的同步action。 异步action使用Redux-Saga来监听，监听的时候可以使用takeLatest或者takeEvery来处理并发的请求。 具体的saga实现可以使用Redux-Saga提供的方法，比如call，put之类的，可以让单元测试更好写。 一个action可以被Redux-Saga和Reducer同时响应，比如上面的FETCH_USER_INFO发出后我还想让页面转个圈，可以直接在reducer里面加一个就行: ... case 'FETCH_USER_INFO': return { ...state, isLoading: true }; ... 手写源码 通过上面这个例子，我们可以看出，Redux-Saga的运行是通过这一行代码来实现的： sagaMiddleware.run(rootSaga); 整个Redux-Saga的运行和原本的Redux并不冲突，Redux甚至都不知道他的存在，他们之间耦合很小，只在需要的时候通过put发出action来进行通讯。所以我猜测，他应该是自己实现了一套完全独立的异步任务处理机制，下面我们从能感知到的API入手，一步一步来探寻下他源码的奥秘吧。本文全部代码参照官方源码写成，函数名字和变量名字尽量保持一致，写到具体的方法的时候我也会贴出对应的代码地址，主要代码都在这里:https://github.com/redux-saga/redux-saga/tree/master/packages/core/src 先来看看我们用到了哪些API，这些API就是我们今天手写的目标: createSagaMiddleware：这个方法会返回一个中间件实例sagaMiddleware sagaMiddleware.run: 这个方法是真正运行我们写的saga的入口 takeEvery：这个方法是用来控制并发流程的 call：用来调用其他方法 put：发出action，用来和Redux通讯 从中间件入手 之前我们讲Redux源码的时候详细分析了Redux中间件的原理和范式，一个中间件大概就长这个样子: function logger(store) { return function(next) { return function(action) { console.group(action.type); console.info('dispatching', action); let result = next(action); console.log('next state', store.getState()); console.groupEnd(); return result } } } 这其实就相当于一个Redux中间件的范式了： 一个中间件接收store作为参数，会返回一个函数 返回的这个函数接收老的dispatch函数作为参数(也就是上面的next)，会返回一个新的函数 返回的新函数就是新的dispatch函数，这个函数里面可以拿到外面两层传进来的store和老dispatch函数 依照这个范式以及前面对createSagaMiddleware的使用，我们可以先写出这个函数的骨架： // sagaMiddlewareFactory其实就是我们外面使用的createSagaMiddleware function sagaMiddlewareFactory() { // 返回的是一个Redux中间件 // 需要符合他的范式 const sagaMiddleware = function (store) { return function (next) { return function (action) { // 内容先写个空的 let result = next(action); return result; } } } // sagaMiddleware上还有个run方法 // 是用来启动saga的 // 我们先留空吧 sagaMiddleware.run = () => { } return sagaMiddleware; } export default sagaMiddlewareFactory; 梳理架构 现在我们有了一个空的骨架，接下来该干啥呢?前面我们说过了，Redux-Saga很可能是自己实现了一套完全独立的异步事件处理机制。这种异步事件处理机制需要一个处理中心来存储事件和处理函数，还需要一个方法来触发队列中的事件的执行，再回看前面的使用的API，我们发现了两个类似功能的API： takeEvery(action, callback)：他接收的参数就是action和callback，而且我们在根saga里面可能会多次调用它来注册不同action的处理函数，这其实就相当于往处理中心里面塞入事件了。 put(action)：put的参数是action，他唯一的作用就是触发对应事件的回调运行。 可以看到Redux-Saga这种机制也是用takeEvery先注册回调，然后使用put发出消息来触发回调执行，这其实跟我们其他文章多次提到的发布订阅模式很像。 手写channel channel是Redux-Saga保存回调和触发回调的地方，类似于发布订阅模式，我们先来写个： export function multicastChannel() { const currentTakers = []; // 一个变量存储我们所有注册的事件和回调 // 保存事件和回调的函数 // Redux-Saga里面take接收回调cb和匹配方法matcher两个参数 // 事实上take到的事件名称也被封装到了matcher里面 function take(cb, matcher) { cb['MATCH'] = matcher; currentTakers.push(cb); } function put(input) { const takers = currentTakers; for (let i = 0, len = takers.length; i 上述代码中有一个奇怪的点，就是将matcher作为属性放到了回调函数上，这么做的原因我想是为了让外部可以自定义匹配方法，而不是简单的事件名称匹配，事实上Redux-Saga本身就支持好几种匹配模式，包括字符串，Symbol,数组等等。 内置支持的匹配方法可以看这里：https://github.com/redux-saga/redux-saga/blob/master/packages/core/src/internal/matcher.js。 channel对应的源码可以看这里：https://github.com/redux-saga/redux-saga/blob/master/packages/core/src/internal/channel.js#L153 有了channel之后，我们的中间件里面其实只要再干一件事情就行了，就是调用channel.put将接收的action再发给channel去执行回调就行，所以我们加一行代码: // ... 省略前面代码 const result = next(action); channel.put(action); // 将收到的action也发给Redux-Saga return result; // ... 省略后面代码 sagaMiddleware.run 前面的put是发出事件，执行回调，可是我们的回调还没注册呢，那注册回调应该在什么地方呢？看起来只有一个地方了，那就是sagaMiddleware.run。简单来说，sagaMiddleware.run接收一个Generator作为参数，然后执行这个Generator，当遇到take的时候就将它注册到channel上面去。这里我们先实现take，takeEvery是在这个基础上实现的。Redux-Saga中这块代码是单独抽取了一个文件，我们仿照这种做法吧。 首先需要在中间件里面将Redux的getState和dispatch等参数传递进去，Redux-Saga使用的是bind函数，所以中间件方法改造如下: function sagaMiddleware({ getState, dispatch }) { // 将getState, dispatch通过bind传给runSaga boundRunSaga = runSaga.bind(null, { channel, dispatch, getState, }) return function (next) { return function (action) { const result = next(action); channel.put(action); return result; } } } 然后sagaMiddleware.run就直接将boundRunSaga拿来运行就行了： sagaMiddleware.run = (...args) => { boundRunSaga(...args) } 注意这里的...args，这个其实就是我们传进去的rootSaga。到这里其实中间件部分就已经完成了，后面的代码就是具体的执行过程了。 中间件对应的源码可以看这里：https://github.com/redux-saga/redux-saga/blob/master/packages/core/src/internal/middleware.js runSaga runSaga其实才是真正的sagaMiddleware.run，通过前面的分析，我们已经知道他的作用是接收Generator并执行，如果遇到take就将它注册到channel上去，如果遇到put就将对应的回调拿出来执行，但是Redux-Saga又将这个过程分为了好几层，我们一层一层来看吧。runSaga的参数先是通过bind传入了一些上下文相关的变量，比如getState, dispatch，然后又在运行的时候传入了rootSaga，所以他应该是长这个样子的： import proc from './proc'; export function runSaga( { channel, dispatch, getState }, saga, ...args ) { // saga是一个Generator，运行后得到一个迭代器 const iterator = saga(...args); const env = { channel, dispatch, getState, }; proc(env, iterator); } 可以看到runSaga仅仅是将Generator运行下，得到迭代器对象后又调用了proc来处理。 runSaga对应的源码看这里：https://github.com/redux-saga/redux-saga/blob/master/packages/core/src/internal/runSaga.js proc proc就是具体执行这个迭代器的过程，Generator的执行方式我们之前在另一篇文章详细讲过，简单来说就是可以另外写一个方法next来执行Generator，next里面检测到如果Generator没有执行完，就继续执行next，然后外层调用一下next启动这个流程就行。 export default function proc(env, iterator) { // 调用next启动迭代器执行 next(); // next函数也不复杂 // 就是执行iterator function next(arg, isErr) { let result; if (isErr) { result = iterator.throw(arg); } else { result = iterator.next(arg); } // 如果他没结束，就继续next // digestEffect是处理当前步骤返回值的函数 // 继续执行的next也由他来调用 if (!result.done) { digestEffect(result.value, next) } } } digestEffect 上面如果迭代器没有执行完，我们会将它的值传给digestEffect处理，那么这里的result.value的值是什么的呢？回想下我们前面rootSaga里面的用法 yield takeEvery(\"FETCH_USER_INFO\", fetchUserInfo); result.value的值应该是yield后面的值，也就是takeEvery(\"FETCH_USER_INFO\", fetchUserInfo)的返回值，takeEvery是再次包装过的effect，他包装了take，fork这些简单的effect。其实对于像take这种简单的effect来说，比如: take(\"FETCH_USER_INFO\", fetchUserInfo); 这行代码的返回值直接就是一个对象，类似于这样： { IO: true, type: 'TAKE', payload: {}, } 所以我们这里digestEffect拿到的result.value也是这样的一个对象，这个对象就代表了我们的一个effect，所以我们的digestEffect就长这样： function digestEffect(effect, cb) { // 这个cb其实就是前面传进来的next // 这个变量是用来解决竞争问题的 let effectSettled; function currCb(res, isErr) { // 如果已经运行过了，直接return if (effectSettled) { return } effectSettled = true; cb(res, isErr); } runEffect(effect, currCb); } runEffect 可以看到digestEffect又调用了一个函数runEffect，这个函数会处理具体的effect: // runEffect就只是获取对应type的处理函数，然后拿来处理当前effect function runEffect(effect, currCb) { if (effect && effect.IO) { const effectRunner = effectRunnerMap[effect.type] effectRunner(env, effect.payload, currCb); } else { currCb(); } } 这点代码可以看出，runEffect也只是对effect进行了检测，通过他的类型获取对应的处理函数，然后进行处理，我这里代码简化了，只支持IO这种effect，官方源码中还支持promise和iterator，具体的可以看看他的源码：https://github.com/redux-saga/redux-saga/blob/master/packages/core/src/internal/proc.js effectRunner effectRunner是通过effect.type匹配出来的具体的effect的处理函数，我们先来看两个：take和fork。 runTakeEffect take的处理其实很简单，就是将它注册到我们的channel里面就行，所以我们建一个effectRunnerMap.js文件，在里面添加take的处理函数runTakeEffect: // effectRunnerMap.js function runTakeEffect(env, { channel = env.channel, pattern }, cb) { const matcher = input => input.type === pattern; // 注意channel.take的第二个参数是matcher // 我们直接写一个简单的matcher，就是输入类型必须跟pattern一样才行 // 这里的pattern就是我们经常用的action名字，比如FETCH_USER_INFO // Redux-Saga不仅仅支持这种字符串，还支持多种形式，也可以自定义matcher来解析 channel.take(cb, matcher); } const effectRunnerMap = { 'TAKE': runTakeEffect, }; export default effectRunnerMap; 注意上面代码channel.take(cb, matcher);里面的cb，这个cb其实就是我们迭代器的next，也就是说take的回调是迭代器继续执行，也就是继续执行下面的代码。也就是说，当你这样写时： yield take(\"SOME_ACTION\"); yield fork(saga); 当运行到yield take(\"SOME_ACTION\");这行代码时，整个迭代器都阻塞了，不会再往下运行。除非你触发了SOME_ACTION，这时候会把SOME_ACTION的回调拿出来执行，这个回调就是迭代器的next，所以就可以继续执行下面这行代码了yield fork(saga)。 runForkEffect 我们前面的示例代码其实没有直接用到fork这个API，但是用到了takeEvery，takeEvery其实是组合take和fork来实现的，所以我们先来看看fork。fork的使用跟call很像，也是可以直接调用传进来的方法，只是call会等待结果回来才进行下一步，fork不会阻塞这个过程，而是当前结果没回来也会直接运行下一步： fork(fn, ...args); 所以当我们拿到fork的时候，处理起来也很简单，直接调用proc处理fn就行了，fn应该是一个Generator函数。 function runForkEffect(env, { fn }, cb) { const taskIterator = fn(); // 运行fn得到一个迭代器 proc(env, taskIterator); // 直接将taskIterator给proc处理 cb(); // 直接调用cb，不需要等待proc的结果 } runPutEffect 我们前面的例子还用到了put这个effect，他就更简单了，只是发出一个action，事实上他也是调用的Redux的dispatch来发出action： function runPutEffect(env, { action }, cb) { const result = env.dispatch(action); // 直接dispatch(action) cb(result); } 注意我们这里的代码只需要dispatch(action)就行了，不需要再手动调channel.put了，因为我们前面的中间件里面已经改造了dispatch方法了，每次dispatch的时候都会自动调用channel.put。 runCallEffect 前面我们发起API请求还用到了call，一般我们使用axios这种库返回的都是一个promise，所以我们这里写一种支持promise的情况，当然普通同步函数肯定也是支持的： function runCallEffect(env, { fn, args }, cb) { const result = fn.apply(null, args); if (isPromise(result)) { return result .then(data => cb(data)) .catch(error => cb(error, true)); } cb(result); } 这些effect具体处理的方法对应的源码都在这个文件里面：https://github.com/redux-saga/redux-saga/blob/master/packages/core/src/internal/effectRunnerMap.js effects 上面我们讲了几个effect具体处理的方法，但是这些都不是对外暴露的effect API。真正对外暴露的effect API还需要单独写，他们其实都很简单，都是返回一个带有type的简单对象就行： const makeEffect = (type, payload) => ({ IO: true, type, payload }) export function take(pattern) { return makeEffect('TAKE', { pattern }) } export function fork(fn) { return makeEffect('FORK', { fn }) } export function call(fn, ...args) { return makeEffect('CALL', { fn, args }) } export function put(action) { return makeEffect('PUT', { action }) } 可以看到当我们使用effect时，他的返回值就仅仅是一个描述当前任务的对象，这就让我们的单元测试好写很多。因为我们的代码在不同的环境下运行可能会产生不同的结果，特别是这些异步请求，我们写单元测试时来造这些数据也会很麻烦。但是如果你使用Redux-Saga的effect，每次你代码运行的时候得到的都是一个任务描述对象，这个对象是稳定的，不受运行结果影响，也就不需要针对这个造测试数据了，大大减少了工作量。 effects对应的源码文件看这里：https://github.com/redux-saga/redux-saga/blob/master/packages/core/src/internal/io.js takeEvery 我们前面还用到了takeEvery来处理同时发起的多个请求，这个API是一个高级API，是封装前面的take和fork来实现的，官方源码又构造了一个新的迭代器来组合他们，不是很直观。官方文档中的这种写法反而很好理解，我这里采用文档中的这种写法: export function takeEvery(pattern, saga) { function* takeEveryHelper() { while (true) { yield take(pattern); yield fork(saga); } } return fork(takeEveryHelper); } 上面这段代码就很好理解了，我们一个死循环不停的监听pattern，即目标事件，当目标事件过来的时候，就执行对应的saga，然后又进入下一次循环继续监听pattern。 总结 到这里我们例子中用到的API已经全部自己实现了，我们可以用自己的这个Redux-Saga来替换官方的了，只是我们只实现了他的一部分功能，还有很多功能没有实现，不过这已经不妨碍我们理解他的基本原理了。再来回顾下他的主要要点： Redux-Saga其实也是一个发布订阅模式，管理事件的地方是channel，两个重点API：take和put。 take是注册一个事件到channel上，当事件过来时触发回调，需要注意的是，这里的回调仅仅是迭代器的next，并不是具体响应事件的函数。也就是说take的意思就是：我在等某某事件，这个事件来之前不许往下走，来了后就可以往下走了。 put是发出事件，他是使用Redux dispatch发出事件的，也就是说put的事件会被Redux和Redux-Saga同时响应。 Redux-Saga增强了Redux的dispatch函数，在dispatch的同时会触发channel.put，也就是让Redux-Saga也响应回调。 我们调用的effects和真正实现功能的函数是分开的，表层调用的effects只会返回一个简单的对象，这个对象描述了当前任务，他是稳定的，所以基于effects的单元测试很好写。 当拿到effects返回的对象后，我们再根据他的type去找对应的处理函数来进行处理。 整个Redux-Saga都是基于Generator的，每往下走一步都需要手动调用next，这样当他执行到中途的时候我们可以根据情况不再继续调用next，这其实就相当于将当前任务cancel了。 参考资料 Redux-Saga官方文档：https://redux-saga.js.org/ Redux-Saga源码地址： https://github.com/redux-saga/redux-saga/tree/master/packages/core/src "},"Articles/React/React-Router_Usage.html":{"url":"Articles/React/React-Router_Usage.html","title":"React-Router实现前端路由鉴权","keywords":"","body":"React-Router是React生态里面很重要的一环，现在React的单页应用的路由基本都是前端自己管理的，而不像以前是后端路由，React管理路由的库常用的就是就是React-Router。本文想写一下React-Router的使用，但是光介绍API又太平淡了，而且官方文档已经写得很好了，我这里就用一个常见的开发场景来看看React-Router是怎么用的吧。而我们一般的系统都会有用户访问权限的限制，某些页面可能需要用户具有一定的权限才能访问。本文就是用React-Router来实现一个前端鉴权模型。 应用示例 本文要实现的功能是大家经常遇到的场景，就是要控制不同的用户角色来访问不同的页面，这里总共有四个页面： /index: 网站首页 /login: 登录页 /backend：后台页面 /admin：管理页面 另外还有三种角色： 未登录用户：只能访问网站首页/index和登录页/login 普通用户：可以访问网站首页/index，登录页/login和后台页面/backend 管理员：可以访问管理页面/admin和其他所有页面 引入React-Router 要实现路由鉴权，我们还得一步一步来，我们先用React-Router搭建一个简单的带有这几个页面的项目。我们直接用create-react-app创建一个新项目，然后建了一个pages文件夹，里面放入我们前面说的那几个页面： 我们页面先写简单点，先写个标题吧，比如这样： import React from 'react'; function Admin() { return ( 管理员页面 ); } 其他几个页面也是类似的。 然后我们就可以在App.js里面引入React-Router做路由跳转了，注意我们在浏览器上使用的是react-router-dom，新版的React-Router将核心逻辑层和展示层分开了，核心逻辑会处理路由匹配等，展示层会处理实际的跳转和路由变化的监听，之所以这么分，是因为React-Router不仅仅需要支持浏览器，还需要支持React Native，这两个平台的监听和跳转是不一样的，所以现在React-Router下面有好几个包了： react-router：核心逻辑处理，包括路由匹配和Context处理等 react-router-dom：跟浏览器相关的路由监听和跳转 react-router-native：跟RN相关的路由监听和跳转 在实际使用时，我们一般不需要引用react-router，而是直接用react-router-dom就行，因为它自己会去引用react-router。下面我们在项目里面引入react-router-dom。 import React from 'react'; import { BrowserRouter as Router, Switch, Route, } from \"react-router-dom\"; import Home from './pages/Home'; import Login from './pages/Login'; import Backend from './pages/Backend'; import Admin from './pages/Admin'; function App() { return ( ); } export default App; 然后可以在Home页面用Link加上跳转到其他页面的链接，这样就可以跳转了： import React from 'react'; import { Link } from 'react-router-dom'; function Home() { return ( <> 首页 登录 后台 管理员 ); } export default Home; 到现在我们的应用运行起来是这样的： 模块划分 虽然我们的跳转实现了，但是所有人都可以访问任何页面，我们前面的需求是要根据登录的角色限制访问的页面的，在写代码前，我们先来思考下应该怎么做这个。当然最直观最简单的方法就是每个页面都检测下当前用户的角色，匹配不上就报错或者跳回首页。我们现在只有几个页面，这样做好像也还好，但是如果我们的应用变大了，页面变多了，每个页面都来一次检测就显得很重复了，所以我们应该换个角度来思考这个问题。 仔细一看，其实我们总共就三种角色，对应三种不同的权限，这三个权限还有层级关系，高级别的权限包含了低级别的权限，所以我们的页面也可以按照这些权限分为三种： 公共页面：所有人都可以访问，没登录也可以访问，包括网站首页和登录页 普通页面：普通登录用户可以访问的页面 管理员页面：只有管理员才能访问的页面 为了好管理这三种页面，我们可以将他们抽取成三个文件，放到一个独立的文件夹routes里面，三个文件分别命名为publicRoutes.js，privateRoutes.js，adminRoutes.js： 对于每个路由文件，我们可以将这类路由组织成数组，然后export出去给外面调用，比如publicRoutes.js： import Login from '../pages'; import Home from '../pages/Home'; const publicRoutes = [ { path: '/login', component: Login, exact: true, }, { path: '/', component: Home, exact: true, }, ]; export default publicRoutes; 然后我们外面使用的地方直接改为： import publicRoutes from './routes/publicRoutes'; function App() { return ( {publicRoutes.map( ({path, component, ...routes}) => )} ); } 这样我们的App.js里面就不会有冗长的路由路由列表了，而是只需要循环一个数组就行了。但是对于需要登录才能访问的页面和管理员页面我们不能直接渲染Route组件，我们最好再封装一个高级组件，将鉴权的工作放到这个组件里面去，这样我们普通的页面在实现时就不需要关心怎么鉴权了。 封装高级组件 要封装这个鉴权组件思路也很简单，前面我们将publicRoutes直接拿来循环渲染了Route组件，我们的鉴权组件只需要在这个基础上再加一个逻辑就行了：在渲染真正的Route组件前先检查一下当前用户是否有对应的权限，如果有就直接渲染Route组件，如果没有就返回某个页面，可以是登录页或者后台首页，具体根据自己项目需求来。所以我们的路由配置文件privateRoutes.js，adminRoutes.js里面的路由会比publicRoutes.js的多两个参数： // privateRoutes.js import Backend from '../pages/Backend'; const privateRoutes = [ { path: '/backend', component: Backend, exact: true, role: 'user', // 当前路由需要的角色权限 backUrl: '/login' // 不满足权限跳转的路由 }, ]; export default privateRoutes; adminRoutes.js是类似的写法： // adminRoutes.js import Admin from '../pages/Admin'; const adminRoutes = [ { path: '/admin', component: Admin, exact: true, role: 'admin', // 需要的权限是admin backUrl: '/backend' // 不满足权限跳回后台页面 }, ]; export default adminRoutes; 然后就可以写我们的高级组件了，我们将它命名为AuthRoute吧，注意我们这里假设的用户登录时后端API会返回给我们当前用户的角色，一个用户可能有多个角色，比如普通用户的角色是['user']，管理员的角色是['user', 'admin']，具体的权限验证逻辑要看自己项目权限的设计，这里只是一个例子： // AuthRoute.js import React from 'react'; import { Route, Redirect } from 'react-router-dom'; function AuthRoute(props) { const { user: { role: userRole }, role: routeRole, backUrl, ...otherProps } = props; // 如果用户有权限，就渲染对应的路由 if (userRole && userRole.indexOf(routeRole) > -1) { return } else { // 如果没有权限，返回配置的默认路由 return } } export default AuthRoute; 然后用我们的AuthRoute的渲染adminRoutes和privateRoutes: // ... 省略其他代码 ... {privateRoutes.map( (route) => )} {adminRoutes.map( (route) => )} 登录设置权限 在我们的AuthRoute里面用到了user: { role }这个变量，但是我们还没设置它。真实项目中一般是登录的时候后端API会返回当前用户的角色，然后前端将这个权限信息保存在一些状态管理工具里面，比如Redux。我们这里直接在Login页面写死两个按钮来模拟这个权限了，用户的配置就用根组件的state来管理了，Login页面的两个按钮会改变对应的state： import React from 'react'; import { Link } from 'react-router-dom'; function Login(props) { const {loginAsUser, loginAsAdmin, history} = props; const userLoginHandler = () => { loginAsUser(); // 调用父级方法设置用户权限 history.replace('/backend'); // 登录后跳转后台页面 } const adminLoginHandler = () => { loginAsAdmin(); // 调用父级方法设置管理员权限 history.replace('/admin'); // 登录后跳转管理员页面 } return ( <> 登录页 普通用户登录 管理员登录 回首页 ); } export default Login; 到这里我们这个简单的路由鉴权就完成了，具体跑起来效果如下： 总结 React-Router可以用来管理前端的路由跳转，是React生态里面很重要的一个库。 React-Router为了同时支持浏览器和React-Native，他分拆成了三个包react-router核心包，react-router-dom浏览器包，react-router-native支持React-Native。使用时不需要引入react-router，只需要引入需要的平台包就行。 对于需要不同权限的路由，我们可以将他们拎出来分好类，单独建成一个文件，如果路由不多，放在一个文件导出多个数组也行。 对于需要鉴权的路由，我们可以用一个高级组件将权限校验的逻辑封装在里面，其他页面只需要加好配置，完全不用关心鉴权的问题。 本文内容偏简单，作为熟悉React-Router的用法还不错，但是我们不能只会用，还要知道他的原理。下篇文章我们就来看看React-Router的源码里面蕴藏了什么奥秘，大家可以点个关注不迷路，哈哈~ 参考资料 官方文档：https://reactrouter.com/web/guides/quick-start GitHub源码地址：https://github.com/ReactTraining/react-router/tree/master/packages "},"Articles/React/React-Router_Code.html":{"url":"Articles/React/React-Router_Code.html","title":"手写React-Router源码","keywords":"","body":"上一篇文章我们讲了React-Router的基本用法，并实现了常见的前端路由鉴权。本文会继续深入React-Router讲讲他的源码，套路还是一样的，我们先用官方的API实现一个简单的例子，然后自己手写这些API来替换官方的并且保持功能不变。 简单示例 本文用的例子是上篇文章开始那个不带鉴权的简单路由跳转例子，跑起来是这样子的： 我们再来回顾下代码，在app.js里面我们用Route组件渲染了几个路由： import React from 'react'; import { BrowserRouter as Router, Switch, Route, } from \"react-router-dom\"; import Home from './pages/Home'; import Login from './pages/Login'; import Backend from './pages/Backend'; import Admin from './pages/Admin'; function App() { return ( ); } export default App; 每个页面的代码都很简单，只有一个标题和回首页的链接，比如登录页长这样，其他几个页面类似： import React from 'react'; import { Link } from 'react-router-dom'; function Login() { return ( <> 登录页 回首页 ); } export default Login; 这样我们就完成了一个最简单的React-Router的应用示例，我们来分析下我们用到了他的哪些API，这些API就是我们今天要手写的目标，仔细一看，我们好像只用到了几个组件，这几个组件都是从react-router-dom导出来的： BrowserRouter: 被我们重命名为了Router，他包裹了整个React-Router应用，感觉跟以前写过的react-redux的Provider类似，我猜是用来注入context之类的。 Route: 这个组件是用来定义具体的路由的，接收路由地址path和对应渲染的组件作为参数。 Switch：这个组件是用来设置匹配模式的，不加这个的话，如果浏览器地址匹配到了多个路由，这几个路由都会渲染出来，加了这个只会渲染匹配的第一个路由组件。 Link：这个是用来添加跳转链接的，功能类似于原生的a标签，我猜他里面也是封装了一个a标签。 BrowserRouter源码 我们代码里面最外层的就是BrowserRouter，我们先去看看他的源码干了啥，地址传送门：https://github.com/ReactTraining/react-router/blob/master/packages/react-router-dom/modules/BrowserRouter.js 看了他的源码，我们发现BrowserRouter代码很简单，只是一个壳： import React from \"react\"; import { Router } from \"react-router\"; import { createBrowserHistory as createHistory } from \"history\"; class BrowserRouter extends React.Component { history = createHistory(this.props); render() { return ; } } 在这个壳里面还引用了两个库react-router和history，BrowserRouter仅仅是调用history的createHistory得到一个history对象，然后用这个对象渲染了react-router的Router组件。看起来我们要搞懂react-router-dom的源码还必须得去看react-router和history的源码，现在我们手上有好几个需要搞懂的库了，为了看懂他们的源码，我们得先理清楚他们的结构关系。 React-Router的项目结构 React-Router的结构是一个典型的monorepo，monorepo这两年开始流行了，是一种比较新的多项目管理方式，与之相对的是传统的multi-repo。比如React-Router的项目结构是这样的： 注意这里的packages文件夹下面有四个文件夹，这四个文件夹每个都可以作为一个单独的项目发布。之所以把他们放在一起，是因为他们之前有很强的依赖关系： react-router：是React-Router的核心库，处理一些共用的逻辑 react-router-config：是React-Router的配置处理，我们一般不需要使用 react-router-dom：浏览器上使用的库，会引用react-router核心库 react-router-native：支持React-Native的路由库，也会引用react-router核心库 像这样多个仓库，发布多个包的情况，传统模式是给每个库都建一个git repo，这种方式被称为multi-repo。像React-Router这样将多个库放在同一个git repo里面的就是monorepo。这样做的好处是如果出了一个BUG或者加一个新功能，需要同时改react-router和react-router-dom，monorepo只需要一个commit一次性就改好了，发布也可以一起发布。如果是multi-repo则需要修改两个repo，然后分别发布两个repo，发布的时候还要协调两个repo之间的依赖关系。所以现在很多开源库都使用monorepo来将依赖很强的模块放在一个repo里面，比如React源码也是一个典型的monorepo。 yarn有一个workspaces可以支持monorepo，使用这个功能需要在package.json里面配置workspaces，比如这样： \"workspaces\": { \"packages\": [ \"packages/*\" ] } 扯远了，monorepo可以后面单独开一篇文章来讲，这里讲这个主要是为了说明React-Router分拆成了多个包，这些包之间是有比较强的依赖的。 前面我们还用了一个库是history，这个库没在React-Router的monorepo里面，而是单独的一个库，因为官方把他写的功能很独立了，不一定非要结合React-Router使用，在其他地方也可以使用。 React-Router架构思路 我之前另一篇文章讲Vue-Router的原理提到过，前端路由实现无非这几个关键点： 监听URL的改变 改变vue-router里面的current变量 监视current变量 获取对应的组件 render新组件 其实React-Router的思路也是类似的，只是React-Router将这些功能拆分得更散，监听URL变化独立成了history库，vue-router里面的current变量在React里面是用Context API实现的，而且放到了核心库react-router里面，一些跟平台相关的组件则放到了对应的平台库react-router-dom或者react-router-native里面。按照这个思路，我们自己写的React-Router文件夹下面也建几个对应的文件夹： 手写自己的React-Router 然后我们顺着这个思路一步一步的将我们代码里面用到的API替换成自己的。 BrowserRouter组件 BrowserRouter这个代码前面看过，直接抄过来就行: import React from \"react\"; import { Router } from \"react-router\"; import { createBrowserHistory as createHistory } from \"history\"; class BrowserRouter extends React.Component { history = createHistory(this.props); render() { return ; } } export default BrowserRouter; react-router的Router组件 上面的BrowserRouter用到了react-router的Router组件，这个组件在浏览器和React-Native端都有使用，主要获取当前路由并通过Context API将它传递下去： import React from \"react\"; import HistoryContext from \"./HistoryContext.js\"; import RouterContext from \"./RouterContext.js\"; /** * The public API for putting history on context. */ class Router extends React.Component { // 静态方法，检测当前路由是否匹配 static computeRootMatch(pathname) { return { path: \"/\", url: \"/\", params: {}, isExact: pathname === \"/\" }; } constructor(props) { super(props); this.state = { location: props.history.location // 将history的location挂载到state上 }; // 下面两个变量是防御性代码，防止根组件还没渲染location就变了 // 如果location变化时，当前根组件还没渲染出来，就先记下他，等当前组件mount了再设置到state上 this._isMounted = false; this._pendingLocation = null; // 通过history监听路由变化，变化的时候，改变state上的location this.unlisten = props.history.listen(location => { if (this._isMounted) { this.setState({ location }); } else { this._pendingLocation = location; } }); } componentDidMount() { this._isMounted = true; if (this._pendingLocation) { this.setState({ location: this._pendingLocation }); } } componentWillUnmount() { if (this.unlisten) { this.unlisten(); this._isMounted = false; this._pendingLocation = null; } } render() { // render的内容很简单，就是两个context // 一个是路由的相关属性，包括history和location等 // 一个只包含history信息，同时将子组件通过children渲染出来 return ( ); } } export default Router; 上述代码是我精简过的代码，原版代码可以看这里。这段代码主要是创建了两个context，将路由信息和history信息放到了这两个context上，其他也没干啥了。关于React的Context API我在另外一篇文章详细讲过，这里不再赘述了。 history 前面我们其实用到了history的三个API： createBrowserHistory: 这个是用在BrowserRouter里面的，用来创建一个history对象，后面的listen和unlisten都是挂载在这个API的返回对象上面的。 history.listen：这个是用在Router组件里面的，用来监听路由变化。 history.unlisten：这个也是在Router组件里面用的，是listen方法的返回值，用来在清理的时候取消监听的。 下面我们来实现这个history: // 创建和管理listeners的方法 function createEvents() { let handlers = []; return { push(fn) { handlers.push(fn); return function () { handlers = handlers.filter(handler => handler !== fn); }; }, call(arg) { handlers.forEach(fn => fn && fn(arg)); } } } function createBrowserHistory() { const listeners = createEvents(); let location = { pathname: '/', }; // 路由变化时的回调 const handlePop = function () { const currentLocation = { pathname: window.location.pathname } listeners.call(currentLocation); // 路由变化时执行回调 } // 监听popstate事件 // 注意pushState和replaceState并不会触发popstate // 但是浏览器的前进后退会触发popstate // 我们这里监听这个事件是为了处理浏览器的前进后退 window.addEventListener('popstate', handlePop); // 返回的history上有个listen方法 const history = { listen(listener) { return listeners.push(listener); }, location } return history; } export default createBrowserHistory; 上述history代码是超级精简版的代码，官方源码很多，还支持其他功能，我们这里只拎出来核心功能，对官方源码感兴趣的看这里：https://github.com/ReactTraining/history/blob/28c89f4091ae9e1b0001341ea60c629674e83627/packages/history/index.ts#L397 Route组件 我们前面的应用里面还有个很重要的组件是Route组件，这个组件是用来匹配路由和具体的组件的。这个组件看似是从react-router-dom里面导出来的，其实他只是相当于做了一个转发，原封不动的返回了react-router的Route组件： 这个组件其实只有一个作用，就是将参数上的path拿来跟当前的location做对比，如果匹配上了就渲染参数上的component就行。为了匹配path和location，还需要一个辅助方法matchPath，我直接从源码抄这个方法了。大致思路是将我们传入的参数path转成一个正则，然后用这个正则去匹配当前的pathname： import pathToRegexp from \"path-to-regexp\"; const cache = {}; const cacheLimit = 10000; let cacheCount = 0; function compilePath(path, options) { const cacheKey = `${options.end}${options.strict}${options.sensitive}`; const pathCache = cache[cacheKey] || (cache[cacheKey] = {}); if (pathCache[path]) return pathCache[path]; const keys = []; const regexp = pathToRegexp(path, keys, options); const result = { regexp, keys }; if (cacheCount { if (!path && path !== \"\") return null; if (matched) return matched; const { regexp, keys } = compilePath(path, { end: exact, strict, sensitive }); const match = regexp.exec(pathname); if (!match) return null; const [url, ...values] = match; const isExact = pathname === url; if (exact && !isExact) return null; return { path, // the path used to match url: path === \"/\" && url === \"\" ? \"/\" : url, // the matched portion of the URL isExact, // whether or not we matched exactly params: keys.reduce((memo, key, index) => { memo[key.name] = values[index]; return memo; }, {}) }; }, null); } export default matchPath; 然后是Route组件，调用下matchPath来看下当前路由是否匹配就行了，当前路由记得从RouterContext里面拿： import React from \"react\"; import RouterContext from \"./RouterContext.js\"; import matchPath from \"./matchPath.js\"; /** * The public API for matching a single path and rendering. */ class Route extends React.Component { render() { return ( {context => { // 从RouterContext获取location const location = context.location; const match = matchPath(location.pathname, this.props); // 调用matchPath检测当前路由是否匹配 const props = { ...context, location, match }; let { component } = this.props; // render对应的component之前先用最新的参数match更新下RouterContext // 这样下层嵌套的Route可以拿到对的值 return ( {props.match ? React.createElement(component, props) : null} ); }} ); } } export default Route; 上述代码也是精简过的，官方源码还支持函数组件和render方法等，具体代码可以看这里：https://github.com/ReactTraining/react-router/blob/master/packages/react-router/modules/Route.js 其实到这里，React-Router的核心功能已经实现了，但是我们开始的例子中还用到了Switch和Link组件，我们也一起来把它实现了吧。 Switch组件 我们上面的Route组件的功能是只要path匹配上当前路由就渲染组件，也就意味着如果多个Route的path都匹配上了当前路由，这几个组件都会渲染。所以Switch组件的功能只有一个，就是即使多个Route的path都匹配上了当前路由，也只渲染第一个匹配上的组件。要实现这个功能其实也不难，把Switch的children拿出来循环，找出第一个匹配的child，给它添加一个标记属性computedMatch，顺便把其他的child全部干掉，然后修改下Route的渲染逻辑，先检测computedMatch，如果没有这个再使用matchPath自己去匹配： import React from \"react\"; import RouterContext from \"./RouterContext.js\"; import matchPath from \"./matchPath.js\"; class Switch extends React.Component { render() { return ( {context => { const location = context.location; // 从RouterContext获取location let element, match; // 两个变量记录第一次匹配上的子元素和match属性 // 使用React.Children.forEach来遍历子元素，而不能使用React.Children.toArray().find() // 因为toArray会给每个子元素添加一个key，这会导致两个有同样component，但是不同URL的重复渲染 React.Children.forEach(this.props.children, child => { // 先检测下match是否已经匹配到了 // 如果已经匹配过了，直接跳过 if (!match && React.isValidElement(child)) { element = child; const path = child.props.path; match = matchPath(location.pathname, { ...child.props, path }); } }); // 最终组件的返回值只是匹配子元素的一个拷贝，其他子元素被忽略了 // match属性会被塞给拷贝元素的computedMatch // 如果一个都没匹配上，返回null return match ? React.cloneElement(element, { location, computedMatch: match }) : null; }} ); } } export default Switch; 然后修改下Route组件，让他先检查computedMatch： // ... 省略其他代码 ... const match = this.props.computedMatch ? this.props.computedMatch : matchPath(location.pathname, this.props); // 调用matchPath检测当前路由是否匹配 Switch组件其实也是在react-router里面，源码跟我们上面写的差不多：https://github.com/ReactTraining/react-router/blob/master/packages/react-router/modules/Switch.js Link组件 Link组件功能也很简单，就是一个跳转，浏览器上要实现一个跳转，可以用a标签，但是如果直接使用a标签可能会导致页面刷新，所以不能直接使用它，而应该使用history API，history API具体文档可以看这里。我们这里要跳转URL可以直接使用history.pushState。使用history.pushState需要注意一下几点： history.pushState只会改变history状态，不会刷新页面。换句话说就是你用了这个API，你会看到浏览器地址栏的地址变化了，但是页面并没有变化。 当你使用history.pushState或者history.replaceState改变history状态的时候，popstate事件并不会触发，所以history里面的回调不会自动调用，当用户使用history.push的时候我们需要手动调用回调函数。 history.pushState(state, title[, url])接收三个参数，第一个参数state是往新路由传递的信息，可以为空，官方React-Router会往里面加一个随机的key和其他信息，我们这里直接为空吧，第二个参数title目前大多数浏览器都不支持，可以直接给个空字符串，第三个参数url是可选的，是我们这里的关键，这个参数是要跳往的目标地址。 由于history已经成为了一个独立的库，所以我们应该将history.pushState相关处理加到history库里面。 我们先在history里面新加一个APIpush，这个API会调用history.pushState并手动执行回调： // ... 省略其他代码 ... push(url) { const history = window.history; // 这里pushState并不会触发popstate // 但是我们仍然要这样做，是为了保持state栈的一致性 history.pushState(null, '', url); // 由于push并不触发popstate，我们需要手动调用回调函数 location = { pathname: url }; listeners.call(location); } 上面说了我们直接使用a标签会导致页面刷新，但是如果不使用a标签，Link组件应该渲染个什么标签在页面上呢？可以随便渲染个span，div什么的都行，但是可能会跟大家平时的习惯不一样，还可能导致一些样式失效，所以官方还是选择了渲染一个a标签在这里，只是使用event.preventDefault禁止了默认行为，然后用history api自己实现了跳转，当然你可以自己传component参数进去改变默认的a标签。因为是a标签，不能兼容native，所以Link组件其实是在react-router-dom这个包里面： import React from \"react\"; import RouterContext from \"../react-router/RouterContext\"; // LinkAnchor只是渲染了一个没有默认行为的a标签 // 跳转行为由传进来的navigate实现 function LinkAnchor({navigate, ...rest}) { let props = { ...rest, onClick: event => { event.preventDefault(); navigate(); } } return ; } function Link({ component = LinkAnchor, // component默认是LinkAnchor to, ...rest }) { return ( {context => { const { history } = context; // 从RouterContext获取history对象 const props = { ...rest, href: to, navigate() { history.push(to); } }; return React.createElement(component, props); }} ); } export default Link; 上述代码是精简版的Link，基本逻辑跟官方源码一样：https://github.com/ReactTraining/react-router/blob/master/packages/react-router-dom/modules/Link.js 到这里开头示例用到的全部API都换成了我们自己的，其实也实现了React-Router的核心功能。但是我们只实现了H5 history模式，hash模式并没有实现，其实有了这个架子，添加hash模式也比较简单了，基本架子不变，在react-router-dom里面添加一个HashRouter,他的基本结构跟BrowserRouter是一样的，只是他会调用history的createHashHistory，createHashHistory里面不仅仅会去监听popstate，某些浏览器在hash变化的时候不会触发popstate，所以还需要监听hashchange事件。对应的源码如下，大家可以自行阅读： HashRouter: https://github.com/ReactTraining/react-router/blob/master/packages/react-router-dom/modules/HashRouter.js createHashHistory: https://github.com/ReactTraining/history/blob/28c89f4091ae9e1b0001341ea60c629674e83627/packages/history/index.ts#L616 总结 React-Router的核心源码我们已经读完了，下面我们来总结下： React-Router因为有跨平台的需求，所以分拆了好几个包，这几个包采用monorepo的方式管理： react-router是核心包，包含了大部分逻辑和组件，处理context和路由匹配都在这里。 react-router-dom是浏览器使用的包，像Link这样需要渲染具体的a标签的组件就在这里。 react-router-native是react-native使用的包，里面包含了android和ios具体的项目。 浏览器事件监听也单独独立成了一个包history，跟history相关的处理都放在了这里，比如push，replace什么的。 React-Router实现时核心逻辑如下： 使用不刷新的路由API，比如history或者hash 提供一个事件处理机制，让React组件可以监听路由变化。 提供操作路由的接口，当路由变化时，通过事件回调通知React。 当路由事件触发时，将变化的路由写入到React的响应式数据上，也就是将这个值写到根router的state上，然后通过context传给子组件。 具体渲染时将路由配置的path和当前浏览器地址做一个对比，匹配上就渲染对应的组件。 在使用popstate时需要注意： 原生history.pushState和history.replaceState并不会触发popstate，要通知React需要我们手动调用回调函数。 浏览器的前进后退按钮会触发popstate事件，所以我们还是要监听popstate，目的是兼容前进后退按钮。 参考资料 官方文档：https://reactrouter.com/web/guides/quick-start GitHub源码地址：https://github.com/ReactTraining/react-router/tree/master/packages "},"Articles/React/OptimizeCalendar.html":{"url":"Articles/React/OptimizeCalendar.html","title":"Calendar性能优化几十倍","keywords":"","body":"歪门邪道性能优化：魔改三方库源码，性能提高几十倍！ 本文会分享一个React性能优化的故事，这也是我在工作中真实遇到的故事，最终我们是通过魔改第三方库源码将它性能提高了几十倍。这个第三方库也是很有名的，在GitHub上有4.5k star，这就是：react-big-calendar。 这个工作不是我一个人做的，而是我们团队几个月前共同完成的，我觉得挺有意思，就将它复盘总结了一下，分享给大家。 在本文中你可以看到： React常用性能分析工具的使用介绍 性能问题的定位思路 常见性能优化的方式和效果：PureComponent, shouldComponentUpdate, Context, 按需渲染等等 对于第三方库的问题的解决思路 关于我工作中遇到的故事，我前面其实也分享过两篇文章了： 速度提高几百倍，记一次数据结构在实际工作中的运用 使用mono-repo实现跨项目组件共享 特别是速度提高几百倍，记一次数据结构在实际工作中的运用，这篇文章在某平台单篇阅读都有三万多，有些朋友也提出了质疑。觉得我这篇文章里面提到的问题现实中不太可能遇到，里面的性能优化更多是偏理论的，有点杞人忧天。这个观点我基本是认可的，我在那篇文章正文也提到过可能是个伪需求，但是技术问题本来很多就是理论上的，我们在leetcode上刷题还是纯理论呢，理论结合实际才能发挥其真正的价值，即使是杞人忧天，但是性能确实快上了那么一点点，也给大家提供了另一个思路，我觉得也是值得的。 与之相对的，本文提到的问题完全不是杞人忧天了，而是实打实的用户需求，我们经过用户调研，发现用户确实有这么多数据量，需求上不可能再压缩了，只能技术上优化，这也是逼得我们去改第三方库源码的原因。 需求背景 老规矩，为了让大家快速理解我们遇到的问题，我会简单讲一下我们的需求背景。我还是在那家外企，不久前我们接到一个需求：做一个体育场馆管理Web App。这里面有一个核心功能是场馆日程的管理，有点类似于大家Outlook里面的Calendar。大家如果用过Outlook，应该对他的Calendar有印象，基本上我们的会议及其他日程安排都可以很方便的放在里面。我们要做的这个也是类似的，体育场馆的老板可以用这个日历来管理他下面场地的预定。 假设你现在是一个羽毛球场的老板，来了个客户说，嘿，老板，这周六场地有空吗，我订一个小时呢！场馆每天都很多预定，你也不记得周六有没有空，所以你打开我们的网站，看了下日历： 你发现1月15号，也就是星期五有两个预定，周六还全是空闲的，于是给他说：你运气真好，周六目前还没人预定，时段随便挑！上面这个截图是react-big-calendar的官方示例，我们也是选定用他来搭建我们自己的应用。 真实场景 上面这个例子只是说明下我们的应用场景，里面预定只有两个，场地只有一块。但是我们真实的客户可比这个大多了，根据我们的调研，我们较大的客户有数百块场地，每个场地每天的预定可能有二三十个。上面那个例子我们换个生意比较好的老板，假设这个老板有20块羽毛球场地，每天客户都很多，某天还是来了个客户说，嘿，老板，这周六场地有空吗，我订一个小时呢！但是这个老板生意很好，他看到的日历是这样的： 本周场馆1全满！！如果老板想要为客户找到一个有空的场地，他需要连续切换场馆1，场馆2。。。一直到场馆20，手都点酸了。。。为了减少老板手的负担，我们的产品经理提出一个需求，同时在页面上显示10个场馆的日历，好在react-big-calendar本身就是支持这个的，他把这个叫做resources。 性能爆炸 看起来我们要的基本功能react-big-calendar都能提供，前途还是很美好的，直到我们将真实的数据渲染到页面上。。。我们的预定不仅仅是展示，还需要支持一系列的操作，比如编辑，复制，剪切，粘贴，拖拽等等。当然这一切操作的前提都是选中这个预定，下面这个截图是我选中某个预定的耗时： 仅仅是一个最简单的点击事件，脚本执行耗时6827ms，渲染耗时708ms，总计耗时7.5s左右，这TM！这玩意儿还想卖钱？送给我，我都不想用！ 可能有朋友不知道这个性能怎么看，这其实是Chrome自带的性能工具，基本步骤是： 打开Chrome调试工具，点到Performance一栏 点击左上角的小圆点，开始录制 执行你想要的操作，我这里就是点击一个预定 等你想要的结果出来，我这里就是点击的预定颜色加深 再点击左上角的小圆点，结束录制就可以看到了 为了让大家看得更清楚，我这里录制了一个操作的动图，这个图可以看到，点击操作的响应花了很长时间，Chrome加载这个性能数据也花了很长时间： 测试数据量 上面仅仅一个点击耗时就七八秒，是因为我故意用了很大数据量吗？不是！我的测试数据量是完全按照用户真实场景计算的：同时显示10个场馆，每个场馆每天20个预定，上面使用的是周视图，也就是可以同时看到7天的数据，那总共显示的预定就是： 10 * 20 * 7 = 1400，总共1400个预定显示在页面上。 为了跟上面这个龟速点击做个对比，我再放下优化后的动图，让大家对后面这个长篇大论实现的效果先有个预期： 定位问题 我们一般印象中，React不至于这么慢啊，如果慢了，大概率是写代码的人没写好！我们都知道React有个虚拟树，当一个状态改变了，我们只需要更新与这个状态相关的节点就行了，出现这种情况，是不是他干了其他不必要的更新与渲染呢？为了解决这个疑惑，我们安装了React专用调试工具：React Developer Tools。这是一个Chrome的插件，Chrome插件市场可以下载，安装成功后，Chrome的调试工具下面会多两个Tab页： 在Components这个Tab下有个设置，打开这个设置可以看到你每次操作触发哪些组件更新，我们就是从这里面发现了一点惊喜： 为了看清楚点击事件触发哪些更新，我们先减少数据量，只保留一两个预定，然后打开这个设置看看： 哼，这有点意思。。。我只是点击一个预定，你把整个日历的所有组件都给我更新了！那整个日历有多少组件呢？上面这个图可以看出10:00 AM到10:30 AM之间是一个大格子，其实这个大格子中间还有条分割线，只是颜色较淡，看的不明显，也就是说每15分钟就是一个格子。这个15分钟是可以配置的，你也可以设置为1分钟，但是那样格子更多，性能更差！我们是根据需求给用户提供了15分钟，30分钟，1小时等三个选项。当用户选择15分钟的时候，渲染的格子最多，性能最差。 那如果一个格子是15分钟，总共有多少格子呢？一天是24 * 60 = 1440分钟，15分钟一个格子，总共96个格子。我们周视图最多展示7天，那就是7 * 96 = 672格子，最多可以展示10个场馆，就是672 * 10 = 6720个格子，这还没算日期和时间本身占据的组件，四舍五入一下姑且就算7000个格子吧。 我仅仅是点击一下预定，你就把作为背景的7000个格子全部给我更新一遍，怪不得性能差！ 再仔细看下上面这个动图，我点击的是小的那个事件，当我点击他时，注意大的那个事件也更新了，外面也有个蓝框，不是很明显，但是确实是更新了，在我后面调试打Log的时候也证实了这一点。所以在真实1400条数据下，被更新的还有另外1399个事件，这其实也是不必要的。 我这里提到的事件和前文提到的预定是一个东西，react-big-calendar里面将这个称为event，也就是事件，对应我们业务的意义就是预定。 为什么会这样？ 这个现象我好像似曾相识，也是我们经常会犯的一个性能上的问题：将一个状态放到最顶层，然后一层一层往下传，当下面某个元素更新了这个状态，会导致根节点更新，从而触发下面所有子节点的更新。这里说的更新并不一定要重新渲染DOM节点，但是会运行每个子节点的render函数，然后根据render函数运行结果来做diff，看看要不要更新这个DOM节点。React在这一步会帮我们省略不必要的DOM操作，但是render函数的运行却是必须的，而成千上万次render函数的运行也会消耗大量性能。 说到这个我想起以前看到过的一个资料，也是讲这个问题的，他用了一个一万行的列表来做例子，原文在这里：high-performance-redux。下面这个例子来源于这篇文章： function itemsReducer(state = initial_state, action) { switch (action.type) { case 'MARK': return state.map((item) => action.id === item.id ? {...item, marked: !item.marked } : item ); default: return state; } } class App extends Component { render() { const { items, markItem } = this.props; return ( {items.map(item => )} ); } }; function mapStateToProps(state) { return state; } const markItem = (id) => ({type: 'MARK', id}); export default connect( mapStateToProps, {markItem} )(App); 上面这段代码不复杂，就是一个App，接收一个items参数，然后将这个参数全部渲染成Item组件，然后你可以点击单个Item来改变他的选中状态，运行效果如下： 这段代码所有数据都在items里面，这个参数从顶层App传进去，当点击Item的时候改变items数据，从而更新整个列表。这个运行结果跟我们上面的Calendar有类似的问题，当单条Item状态改变的时候，其他没有涉及的Item也会更新。原因也是一样的：顶层的参数items改变了。 说实话，类似的写法我见过很多，即使不是从App传入，也会从其他大的组件节点传入，从而引起类似的问题。当数据量少的时候，这个问题不明显，很多时候都被忽略了，像上面这个图，即使一万条数据，因为每个Item都很简单，所以运行一万次render你也不会明显感知出来，在控制台看也就一百多毫秒。但是我们面临的Calendar就复杂多了，每个子节点的运算逻辑都更复杂，最终将我们的响应速度拖累到了七八秒上。 优化方案 还是先说这个一万条的列表，原作者除了提出问题外，也提出了解决方案：顶层App只传id，Item渲染的数据自己连接redux store获取。下面这段代码同样来自这篇文章： // index.js function items(state = initial_state, action) { switch (action.type) { case 'MARK': const item = state[action.id]; return { ...state, [action.id]: {...item, marked: !item.marked} }; default: return state; } } function ids(state = initial_ids, action) { return state; } function itemsReducer(state = {}, action) { return { // 注意这里，数据多了一个ids ids: ids(state.ids, action), items: items(state.items, action), } } const store = createStore(itemsReducer); export default class NaiveList extends Component { render() { return ( ); } } // app.js class App extends Component { static rerenderViz = true; render() { // App组件只使用ids来渲染列表，不关心具体的数据 const { ids } = this.props; return ( { ids.map(id => { return ; }) } ); } }; function mapStateToProps(state) { return {ids: state.ids}; } export default connect(mapStateToProps)(App); // Item.js // Item组件自己去连接Redux获取数据 class Item extends Component { constructor() { super(); this.onClick = this.onClick.bind(this); } onClick() { this.props.markItem(this.props.id); } render() { const {id, marked} = this.props.item; const bgColor = marked ? '#ECF0F1' : '#fff'; return ( {id} ); } } function mapStateToProps(_, initialProps) { const { id } = initialProps; return (state) => { const { items } = state; return { item: items[id], }; } } const markItem = (id) => ({type: 'MARK', id}); export default connect(mapStateToProps, {markItem})(Item); 这段代码的优化主要在这几个地方： 将数据从单纯的items拆分成了ids和items。 顶层组件App使用ids来渲染列表，ids里面只有id，所以只要不是增加和删除，仅仅单条数据的状态变化，ids并不需要变化，所以App不会更新。 Item组件自己去连接自己需要的数据，当自己关心的数据变化时才更新，其他组件的数据变化并不会触发更新。 拆解第三方库源码 上面通过使用调试工具我看到了一个熟悉的现象，并猜到了他慢的原因，但是目前仅仅是猜测，具体是不是这个原因还要看看他的源码才能确认。好在我在看他的源码前先去看了下他的文档，然后发现了这个： react-big-calendar接收两个参数onSelectEvent和selected，selected表示当前被选中的事件(预定)，onSelectEvent可以用来改变selected的值。也就是说当我们选中某个预定的时候，会改变selected的值，由于这个参数是从顶层往下传的，所以他会引起下面所有子节点的更新，在我们这里就是差不多7000个背景格子 + 1399个其他事件，这样就导致不需要更新的组件更新了。 顶层selected换成Context? react-big-calendar在顶层设计selected这样一个参数是可以理解的，因为使用者可以通过修改这个值来控制选中的事件。这样选中一个事件就有了两个途径： 用户通过点击某个事件来改变selected的值 开发者可以在外部直接修改selected的值来选中某个事件 有了前面一万条数据列表优化的经验，我们知道对于这种问题的处理办法了：使用selected的组件自己去连接Redux获取值，而不是从顶部传入。可惜，react-big-calendar并没有使用Redux，也没有使用其他任何状态管理库。如果他使用Redux，我们还可以考虑添加一个action来给外部修改selected，可惜他没有。没有Redux就玩不转了吗？当然不是！React其实自带一个全局状态共享的功能，那就是Context。React Context API官方有详细介绍，我之前的一篇文章也介绍过他的基本使用方法，这里不再讲述他的基本用法，我这里想提的是他的另一个特性：使用Context Provider包裹时，如果你传入的value变了，会运行下面所有节点的render函数，这跟前面提到的普通props是一样的。但是，如果Provider下面的儿子节点是PureComponent，可以不运行儿子节点的render函数，而直接运行使用这个value的孙子节点。 什么意思呢，下面我将我们面临的问题简化来说明下。假设我们只有三层，第一层是顶层容器Calendar，第二层是背景的空白格子(儿子)，第三层是真正需要使用selected的事件(孙子)： 示例代码如下： // SelectContext.js // 一个简单的Context import React from 'react' const SelectContext = React.createContext() export default SelectContext; // Calendar.js // 使用Context Provider包裹，接收参数selected，渲染背景Background import SelectContext from './SelectContext'; class Calendar extends Component { constructor(...args) { super(...args) this.state = { selected: null }; this.setSelected = this.setSelected.bind(this); } setSelected(selected) { this.setState({ selected }) } componentDidMount() { const { selected } = this.props; this.setSelected(selected); } render() { const { selected } = this.state; const value = { selected, setSelected: this.setSelected } return ( ) } } // Background.js // 继承自PureComponent，渲染背景格子和事件Event class Background extends PureComponent { render() { const { events } = this.props; return ( 这里面是7000个背景格子 下面是渲染1400个事件 {events.map(event => )} ) } } // Event.js // 从Context中取selected来决定自己的渲染样式 import SelectContext from './SelectContext'; class Event extends Component { render() { const { selected, setSelected } = this.context; const { event } = this.props; return ( setSelected(event)}> ) } } Event.contextType = SelectContext; // 连接Context 什么是PureComponent？ 我们知道如果我们想阻止一个组件的render函数运行，我们可以在shouldComponentUpdate返回false，当新的props相对于老的props来说没有变化时，其实就不需要运行render，shouldComponentUpdate就可以这样写： shouldComponentUpdate(nextProps) { const fields = Object.keys(this.props) const fieldsLength = fields.length let flag = false for (let i = 0; i 这段代码就是将新的nextProps与老的props一一进行对比，如果一样就返回false，不需要运行render。而PureComponent其实就是React官方帮我们实现了这样一个shouldComponentUpdate。所以我们上面的Background组件继承自PureComponent，就自带了这么一个优化。如果Background本身的参数没有变化，他就不会更新，而Event因为自己连接了SelectContext，所以当SelectContext的值变化的时候，Event会更新。这就实现了我前面说的如果Provider下面的儿子节点是PureComponent，可以不运行儿子节点的render函数，而直接运行使用这个value的孙子节点。 PureComponent不起作用 理想是美好的，现实是骨感的。。。理论上来说，如果我将中间儿子这层改成了PureComponent，背景上7000个格子就不应该更新了，性能应该大幅提高才对。但是我测试后发现并没有什么用，这7000个格子还是更新了，什么鬼？其实这是PureComponent本身的一个问题：只进行浅比较。注意this.props[field] !== nextProps[field]，如果this.props[field]是个引用对象呢，比如对象，数组之类的？因为他是浅比较，所以即使前后属性内容没变，但是引用地址变了，这两个就不一样了，就会导致组件的更新！ 而在react-big-calendar里面大量存在这种计算后返回新的对象的操作，比如他在顶层Calendar里面有这种操作： 代码地址：https://github.com/jquense/react-big-calendar/blob/master/src/Calendar.js#L790 这行代码的意思是每次props改变都去重新计算状态state，而他的计算代码是这样的： 代码地址：https://github.com/jquense/react-big-calendar/blob/master/src/Calendar.js#L794 注意他的返回值是一个新的对象，而且这个对象里面的属性，比如localizer的计算方法mergeWithDefaults也是这样，每次都返回新的对象： 代码地址：https://github.com/jquense/react-big-calendar/blob/master/src/localizer.js#L39 这样会导致中间儿子节点每次接受到的props虽然内容是一样的，但是因为是一个新对象，即使使用了PureComponent，其运行结果也是需要更新。这种操作在他的源码中大量存在，其实从功能角度来说，这样写是可以理解的，因为我有时候也会这么干。。。有时候某个属性更新了，不太确定要不要更新下面的组件，干脆直接返回一个新对象触发更新，省事是省事了，但是面对我们这种近万个组件的时候性能就崩了。。。 歪门邪道shouldComponentUpdate 如果只有一两个属性是这样返回新对象，我还可以考虑给他重构下，但是调试了一下发现有大量的属性都是这样，咱也不是他作者，也不知道会不会改坏功能，没敢乱动。但是不动性能也绷不住啊，想来想去，还是在儿子的shouldComponentUpdate上动点手脚吧。简单的this.props[field] !== nextProps[field]判断肯定是不行的，因为引用地址变啦，但是他内容其实是没变，那我们就判断他的内容吧。两个对象的深度比较需要使用递归，也可以参考React diff算法来进行性能优化，但是无论你怎么优化这个算法，性能最差的时候都是两个对象一样的时候，因为他们是一样的，你需要遍历到最深处才能肯定他们是一样的，如果对象很深，这种递归算法不见得会比运行一遍render快，而我们面临的大多数情况都是这种性能最差的情况。所以递归对比不太靠谱，其实如果你对这些数据心里有数，没有循环引用什么的，你可以考虑直接将两个对象转化为字符串来进行对比，也就是 JSON.stringify(this.props[field]) !== JSON.stringify(nextProps[field]) 注意，这种方式只适用于你对props数据了解，没有循环引用，没有变化的Symbol，函数之类的属性，因为JSON.stringify执行时会丢掉Symbol和函数，所以我说他是歪门邪道性能优化。 将这个转化为字符串比较的shouldComponentUpdate加到背景格子的组件上，性能得到了明显增强，点击相应速度从7.5秒下降到了5.3秒左右。 按需渲染 上面我们用shouldComponentUpdate阻止了7000个背景格子的更新，响应时间下降了两秒多，但是还是需要5秒多时间，这也很难接受，还需要进一步优化。按照我们之前说的如果还能阻止另外1399个事件的更新那就更好了，但是经过对他数据结构的分析，我们发现他的数据结构跟我们前面举的列表例子还不一样。我们列表的例子所有数据都在items里面，是否选中是item的一个属性，而react-big-calendar的数据结构里面event和selectedEvent是两个不同的属性，每个事件通过判断自己的event是否等于selectedEvent来判断自己是否被选中。这造成的结果就是每次我们选中一个事件，selectedEvent的值都会变化，每个事件的属性都会变化，也就是会更新，运行render函数。如果不改这种数据结构，是阻止不了另外1399个事件更新的。但是改这个数据结构改动太大，对于一个第三方库，我们又不想动这么多，怎么办呢？ 这条路走不通了，我们完全可以换一个思路，背景7000个格子，再加上1400个事件，用户屏幕有那么大吗，看得完吗？肯定是看不完的，既然看不完，那我们只渲染他能看到部分不就可以了！按照这个思路，我们找到了一个库：react-visibility-sensor。这个库使用方法也很简单： function MyComponent (props) { return ( {({isVisible}) => I am {isVisible ? 'visible' : 'invisible'} } ); } 结合我们前面说的，我们可以将VisibilitySensor套在Background上面： class Background extends PureComponent { render() { return ( {({isVisible}) => } ) } } 然后Event组件如果发现自己处于不可见状态，就不用渲染了，只有当自己可见时才渲染： class Event extends Component { render() { const { selected } = this.context; const { isVisible, event } = this.props; return ( { isVisible ? ( 复杂内容 ) : null} ) } } Event.contextType = SelectContext; 按照这个思路我们又改了一下，发现性能又提升了，整体时间下降到了大概4.1秒： 仔细看上图，我们发现渲染事件Rendering时间从1秒左右下降到了43毫秒，快了二十几倍，这得益于渲染内容的减少，但是Scripting时间，也就是脚本执行时间仍然高达4.1秒，还需要进一步优化。 砍掉mousedown事件 渲染这块已经没有太多办法可以用了，只能看看Scripting了，我们发现性能图上鼠标事件有点刺眼： 一次点击同时触发了三个点击事件：mousedown，mouseup，click。如果我们能干掉mousedown，mouseup是不是时间又可以省一半，先去看看他注册这两个事件时干什么的吧。可以直接在代码里面全局搜mousedown，最终发现都是在Selection.js，通过对这个类代码的阅读，发现他是个典型的观察者模式，然后再搜new Selection找到使用的地方，发现mousedown，mouseup主要是用来实现事件的拖拽功能的，mousedown标记拖拽开始，mouseup标记拖拽结束。如果我把它去掉，拖拽功能就没有了。经过跟产品经理沟通，我们后面是需要拖拽的，所以这个不能删。 事情进行到这里，我也没有更多办法了，但是响应时间还是有4秒，真是让人头大 反正没啥好办法了，我就随便点着玩，突然，我发现mousedown的调用栈好像有点问题： 这个调用栈我用数字分成了三块： 这里面有很多熟悉的函数名啊，像啥performUnitOfWork，beginWork，这不都是我在React Fiber这篇文章中提过的吗?所以这些是React自己内部的函数调用 render函数，这是某个组件的渲染函数 这个render里面又调用了renderEvents函数，看起来是用来渲染事件列表的，主要的时间都耗在这里了 mousedown监听本身我是干不掉了，但是里面的执行是不是可以优化呢？renderEvents已经是库自己写的代码了，所以可以直接全局搜，看看在哪里执行的。最终发现是在TimeGrid.js的render函数被执行了，其实这个是不需要执行的，我们直接把前面歪门邪道的shouldComponentUpdate复制过来就可以阻止他的执行。然后再看下性能数据呢： 我们发现Scripting下降到了3.2秒左右，比之前减少约800毫秒，而mousedown的时间也从之前的几百毫秒下降到了50毫秒，在图上几乎都看不到了，mouseup事件也不怎么看得到了，又算进了一步吧~ 忍痛阉割功能 到目前为止，我们的性能优化都没有阉割功能，响应速度从7.5秒下降到了3秒多一点，优化差不多一倍。但是，目前这速度还是要三秒多，别说作为一个工程师了，作为一个用户我都忍不了。咋办呢？我们是真的有点黔驴技穷了。。。 看看上面那个性能图，主要消耗时间的有两个，一个是click事件，还有个timer。timer到现在我还不知道他哪里来的，但是click事件我们是知道的，就是用户点击某个事件后，更改SelectContext的selected属性，然后selected属性从顶层节点传入触发下面组件的更新，中间儿子节点通过shouldComponentUpdate跳过更新，孙子节点直接连接SelectContext获取selected属性更新自己的状态。这个流程是我们前面优化过的，但是，等等，这个貌似还有点问题。 在我们的场景中，中间儿子节点其实包含了高达7000个背景格子，虽然我们通过shouldComponentUpdate跳过了render的执行，但是7000个shouldComponentUpdate本省执行也是需要时间的啊！有没有办法连shouldComponentUpdate的执行也跳过呢？这貌似是个新的思路，但是经过我们的讨论，发现没办法在保持功能的情况下做到，但是可以适度阉割一个功能就可以做到，那阉割的功能是哪个呢？那就是暴露给外部的受控selected属性！ 前面我们提到过选中一个事件有两个途径： 用户通过点击某个事件来改变selected的值 开发者可以在外部直接修改selected的值来选中某个事件 之所以selected要放在顶层组件上就是为了实现第二个功能，让外部开发者可以通过这个受控的selected属性来改变选中的事件。但是经过我们评估，外部修改selected这个并不是我们的需求，我们的需求都是用户点击来选中，也就是说外部修改selected这个功能我们可以不要。 如果不要这个功能那就有得玩了，selected完全不用放在顶层了，只需要放在事件外层的容器上就行，这样，改变selected值只会触发事件的更新，啥背景格子的更新压根就不会触发，那怎么改呢？在我们前面的Calendar -- Background -- Event模型上再加一层EventContainer，变成Calendar -- Background -- EventContainer -- Event。SelectContext.Provider也不用包裹Calendar了，直接包裹EventContainer就行。代码大概是这个样子： // Calendar.js // Calendar简单了，不用接受selected参数，也不用SelectContext.Provider包裹了 class Calendar extends Component { render() { return ( ) } } // Background.js // Background要不要使用shouldComponentUpdate阻止更新可以看看还有没有其他参数变化，因为selected已经从顶层拿掉了 // 改变selected本来就不会触发Background更新 // Background不再渲染单个事件，而是渲染EventContainer class Background extends PureComponent { render() { const { events } = this.props; return ( 这里面是7000个背景格子 下面是渲染1400个事件 ) } } // EventContainer.js // EventContainer需要SelectContext.Provider包裹 // 代码类似之前的Calendar import SelectContext from './SelectContext'; class EventContainer extends Component { constructor(...args) { super(...args) this.state = { selected: null }; this.setSelected = this.setSelected.bind(this); } setSelected(selected) { this.setState({ selected }) } render() { const { selected } = this.state; const { events } = this.props; const value = { selected, setSelected: this.setSelected } return ( {events.map(event => )} ) } } // Event.js // Event跟之前是一样的，从Context中取selected来决定自己的渲染样式 import SelectContext from './SelectContext'; class Event extends Component { render() { const { selected, setSelected } = this.context; const { event } = this.props; return ( setSelected(event)}> ) } } Event.contextType = SelectContext; // 连接Context 这种结构最大的变化就是当selected变化的时候，更新的节点是EventContainer，而不是顶层Calendar，这样就不会触发Calendar下其他节点的更新。缺点就是Calendar无法从外部接收selected了。 需要注意一点是，如果像我们这样EventContainer下面直接渲染Event列表，selected不用Context也可以，可以直接作为EventContainer的state。但是如果EventContainer和Event中间还有层级，需要穿透传递，仍然需要Context，中间层级和以前的类似，使用shouldComponentUpdate阻止更新。 还有一点，因为selected不在顶层了，所以selected更新也不会触发中间Background更新了，所以Background上的shouldComponentUpdate也可以删掉了。 我们这样优化后，性能又提升了： 现在Scripting时间直接从3.2秒降到了800毫秒，其中click事件只有163毫秒，现在从我使用来看，卡顿已经不明显了，直接录个动图来对比下吧： 上面这个动图已经基本看不出卡顿了，但是我们性能图上为啥还有800毫秒呢，而且有一个很长的Timer Fired。经过我们的仔细排查，发现这其实是个乌龙，Timer Fired在我一开始录制性能就出现了，那时候我还在切换页面，还没来得及点击呢，如果我们点进去会发现他其实是按需渲染引入的react-visibility-sensor的一个检查元素可见性的定时任务，并不是我们点击事件的响应时间。把这块去掉，我们点击事件的响应时间其实不到200毫秒。 从7秒多优化到不到200毫秒，三十多倍的性能优化，终于可以交差了，哈哈😃 总结 本文分享的是我工作中实际遇到的一个案例，实现的效果是将7秒左右的响应时间优化到了不到200毫秒，优化了三十几倍，优化的代价是牺牲了一个不常用的功能。 本来想着要是优化好了可以给这个库提个PR，造福大家的。但是优化方案确实有点歪门邪道： 使用了JSON.stringify来进行shouldComponentUpdate的对比优化，对于函数，Symbol属性的改变没法监听到，不适合开放使用，只能在数据自己可控的情况下小规模使用。 牺牲了一个暴露给外部的受控属性selected，破坏了功能。 基于这两点，PR我们就没提了，而是将修改后的代码放到了自己的私有NPM仓库。 下面再来总结下本文面临的问题和优化思路： 遇到的问题 我们需求是要做一个体育场馆的管理日历，所以我们使用了react-big-calendar这个库。我们需求的数据量是渲染7000个背景格子，然后在这个背景格子上渲染1400个事件。这近万个组件渲染后，我们发现仅仅一次点击就需要7秒多，完全不能用。经过细致排查，我们发现慢的原因是点击事件的时候会改变一个属性selected。这个属性是从顶层传下来的，改变后会导致所有组件更新，也就是所有组件都会运行render函数。 第一步优化 为了阻止不必要的render运行，我们引入了Context，将selected放到Context上进行透传。中间层级因为不需要使用selected属性，所以可以使用shouldComponentUpdate来阻止render的运行，底层需要使用selected的组件自行连接Context获取。 第一步优化的效果 响应时间从7秒多下降到5秒多。 第一步优化的问题 底层事件仍然有1400个，获取selected属性后，1400个组件更新仍然要花大量的时间。 第二步优化 为了减少点击后更新的事件数量，我们为事件引入按需渲染，只渲染用户可见的事件组件。同时我们还对mousedown和mouseup进行了优化，也是使用shouldComponentUpdate阻止了不必要的更新。 第二步优化效果 响应时间从5秒多下降到3秒多。 第二步优化的问题 响应时间仍然有三秒多，经过分析发现，背景7000个格子虽然使用shouldComponentUpdate阻止了render函数的运行，但是shouldComponentUpdate本身运行7000次也要费很长时间。 第三步优化 为了让7000背景格子连shouldComponentUpdate都不运行，我们忍痛阉割了顶层受控的selected属性，直接将它放到了事件的容器上，它的更新再也不会触发背景格子的更新了，也就是连shouldComponentUpdate都不运行了。 第三步优化效果 响应时间从3秒多下降到不到200毫秒。 第三步优化的问题 功能被阉割了，其他完美！ 参考资料： react-big-calendar仓库 high-performance-redux "},"Articles/Node/Node.html":{"url":"Articles/Node/Node.html","title":"Node.js","keywords":"","body":"本章节包括如下内容： 模块加载机制，手写require 使用Node.js原生API写一个web服务器 手写Express.js源码 手写Koa源码 手写@koa/router源码 "},"Articles/Node/DeepInNodeModules.html":{"url":"Articles/Node/DeepInNodeModules.html","title":"模块加载机制，手写require","keywords":"","body":"模块是Node.js里面一个很基本也很重要的概念，各种原生类库是通过模块提供的，第三方库也是通过模块进行管理和引用的。本文会从基本的模块原理出发，到最后我们会利用这个原理，自己实现一个简单的模块加载机制，即自己实现一个require。 简单例子 老规矩，讲原理前我们先来一个简单的例子，从这个例子入手一步一步深入原理。Node.js里面如果要导出某个内容，需要使用module.exports，使用module.exports几乎可以导出任意类型的JS对象，包括字符串，函数，对象，数组等等。我们先来建一个a.js导出一个最简单的hello world: // a.js module.exports = \"hello world\"; 然后再来一个b.js导出一个函数： // b.js function add(a, b) { return a + b; } module.exports = add; 然后在index.js里面使用他们，即require他们，require函数返回的结果就是对应文件module.exports的值： // index.js const a = require('./a.js'); const add = require('./b.js'); console.log(a); // \"hello world\" console.log(add(1, 2)); // b导出的是一个加法函数，可以直接使用，这行结果是3 require会先运行目标文件 当我们require某个模块时，并不是只拿他的module.exports，而是会从头开始运行这个文件，module.exports = XXX其实也只是其中一行代码，我们后面会讲到，这行代码的效果其实就是修改模块里面的exports属性。比如我们再来一个c.js： // c.js let c = 1; c = c + 1; module.exports = c; c = 6; 在c.js里面我们导出了一个c，这个c经过了几步计算，当运行到module.exports = c;这行时c的值为2，所以我们require的c.js的值就是2，后面将c的值改为了6并不影响前面的这行代码: const c = require('./c.js'); console.log(c); // c的值是2 前面c.js的变量c是一个基本数据类型，所以后面的c = 6;不影响前面的module.exports，那他如果是一个引用类型呢？我们直接来试试吧： // d.js let d = { num: 1 }; d.num++; module.exports = d; d.num = 6; 然后在index.js里面require他： const d = require('./d.js'); console.log(d); // { num: 6 } 我们发现在module.exports后面给d.num赋值仍然生效了，因为d是一个对象，是一个引用类型，我们可以通过这个引用来修改他的值。其实对于引用类型来说，不仅仅在module.exports后面可以修改他的值，在模块外面也可以修改，比如index.js里面就可以直接改： const d = require('./d.js'); d.num = 7; console.log(d); // { num: 7 } require和module.exports不是黑魔法 我们通过前面的例子可以看出来，require和module.exports干的事情并不复杂，我们先假设有一个全局对象{}，初始情况下是空的，当你require某个文件时，就将这个文件拿出来执行，如果这个文件里面存在module.exports，当运行到这行代码时将module.exports的值加入这个对象，键为对应的文件名，最终这个对象就长这样： { \"a.js\": \"hello world\", \"b.js\": function add(){}, \"c.js\": 2, \"d.js\": { num: 2 } } 当你再次require某个文件时，如果这个对象里面有对应的值，就直接返回给你，如果没有就重复前面的步骤，执行目标文件，然后将它的module.exports加入这个全局对象，并返回给调用者。这个全局对象其实就是我们经常听说的缓存。所以require和module.exports并没有什么黑魔法，就只是运行并获取目标文件的值，然后加入缓存，用的时候拿出来用就行。再看看这个对象，因为d.js是一个引用类型，所以你在任何地方获取了这个引用都可以更改他的值，如果不希望自己模块的值被更改，需要自己写模块时进行处理，比如使用Object.freeze()，Object.defineProperty()之类的方法。 模块类型和加载顺序 这一节的内容都是一些概念，比较枯燥，但是也是我们需要了解的。 模块类型 Node.js的模块有好几种类型，前面我们使用的其实都是文件模块，总结下来，主要有这两种类型： 内置模块：就是Node.js原生提供的功能，比如fs，http等等，这些模块在Node.js进程起来时就加载了。 文件模块：我们前面写的几个模块，还有第三方模块，即node_modules下面的模块都是文件模块。 加载顺序 加载顺序是指当我们require(X)时，应该按照什么顺序去哪里找X，在官方文档上有详细伪代码，总结下来大概是这么个顺序： 优先加载内置模块，即使有同名文件，也会优先使用内置模块。 不是内置模块，先去缓存找。 缓存没有就去找对应路径的文件。 不存在对应的文件，就将这个路径作为文件夹加载。 对应的文件和文件夹都找不到就去node_modules下面找。 还找不到就报错了。 加载文件夹 前面提到找不到文件就找文件夹，但是不可能将整个文件夹都加载进来，加载文件夹的时候也是有一个加载顺序的： 先看看这个文件夹下面有没有package.json，如果有就找里面的main字段，main字段有值就加载对应的文件。所以如果大家在看一些第三方库源码时找不到入口就看看他package.json里面的main字段吧，比如jquery的main字段就是这样：\"main\": \"dist/jquery.js\"。 如果没有package.json或者package.json里面没有main就找index文件。 如果这两步都找不到就报错了。 支持的文件类型 require主要支持三种文件类型： .js：.js文件是我们最常用的文件类型，加载的时候会先运行整个JS文件，然后将前面说的module.exports作为require的返回值。 .json：.json文件是一个普通的文本文件，直接用JSON.parse将其转化为对象返回就行。 .node：.node文件是C++编译后的二进制文件，纯前端一般很少接触这个类型。 手写require 前面其实我们已经将原理讲的七七八八了，下面来到我们的重头戏，自己实现一个require。实现require其实就是实现整个Node.js的模块加载机制，我们再来理一下需要解决的问题： 通过传入的路径名找到对应的文件。 执行找到的文件，同时要注入module和require这些方法和属性，以便模块文件使用。 返回模块的module.exports 本文的手写代码全部参照Node.js官方源码，函数名和变量名尽量保持一致，其实就是精简版的源码，大家可以对照着看，写到具体方法时我也会贴上对应的源码地址。总体的代码都在这个文件里面：https://github.com/nodejs/node/blob/c6b96895cc74bc6bd658b4c6d5ea152d6e686d20/lib/internal/modules/cjs/loader.js Module类 Node.js模块加载的功能全部在Module类里面，整个代码使用面向对象的思想，如果你对JS的面向对象还不是很熟悉可以先看看这篇文章。Module类的构造函数也不复杂，主要是一些值的初始化，为了跟官方Module名字区分开，我们自己的类命名为MyModule： function MyModule(id = '') { this.id = id; // 这个id其实就是我们require的路径 this.path = path.dirname(id); // path是Node.js内置模块，用它来获取传入参数对应的文件夹路径 this.exports = {}; // 导出的东西放这里，初始化为空对象 this.filename = null; // 模块对应的文件名 this.loaded = false; // loaded用来标识当前模块是否已经加载 } require方法 我们一直用的require其实是Module类的一个实例方法，内容很简单，先做一些参数检查，然后调用Module._load方法，源码看这里：https://github.com/nodejs/node/blob/c6b96895cc74bc6bd658b4c6d5ea152d6e686d20/lib/internal/modules/cjs/loader.js#L970。精简版的代码如下： MyModule.prototype.require = function (id) { return Module._load(id); } MyModule._load MyModule._load是一个静态方法，这才是require方法的真正主体，他干的事情其实是： 先检查请求的模块在缓存中是否已经存在了，如果存在了直接返回缓存模块的exports。 如果不在缓存中，就new一个Module实例，用这个实例加载对应的模块，并返回模块的exports。 我们自己来实现下这两个需求，缓存直接放在Module._cache这个静态变量上，这个变量官方初始化使用的是Object.create(null)，这样可以使创建出来的原型指向null，我们也这样做吧： MyModule._cache = Object.create(null); MyModule._load = function (request) { // request是我们传入的路劲参数 const filename = MyModule._resolveFilename(request); // 先检查缓存，如果缓存存在且已经加载，直接返回缓存 const cachedModule = MyModule._cache[filename]; if (cachedModule !== undefined) { return cachedModule.exports; } // 如果缓存不存在，我们就加载这个模块 // 加载前先new一个MyModule实例，然后调用实例方法load来加载 // 加载完成直接返回module.exports const module = new MyModule(filename); // load之前就将这个模块缓存下来，这样如果有循环引用就会拿到这个缓存，但是这个缓存里面的exports可能还没有或者不完整 MyModule._cache[filename] = module; module.load(filename); return module.exports; } 上述代码对应的源码看这里：https://github.com/nodejs/node/blob/c6b96895cc74bc6bd658b4c6d5ea152d6e686d20/lib/internal/modules/cjs/loader.js#L735 可以看到上述源码还调用了两个方法：MyModule._resolveFilename和MyModule.prototype.load，下面我们来实现下这两个方法。 MyModule._resolveFilename MyModule._resolveFilename从名字就可以看出来，这个方法是通过用户传入的require参数来解析到真正的文件地址的，源码中这个方法比较复杂，因为按照前面讲的，他要支持多种参数：内置模块，相对路径，绝对路径，文件夹和第三方模块等等，如果是文件夹或者第三方模块还要解析里面的package.json和index.js。我们这里主要讲原理，所以我们就只实现通过相对路径和绝对路径来查找文件，并支持自动添加js和json两种后缀名: MyModule._resolveFilename = function (request) { const filename = path.resolve(request); // 获取传入参数对应的绝对路径 const extname = path.extname(request); // 获取文件后缀名 // 如果没有文件后缀名，尝试添加.js和.json if (!extname) { const exts = Object.keys(MyModule._extensions); for (let i = 0; i 上述源码中我们还用到了一个静态变量MyModule._extensions，这个变量是用来存各种文件对应的处理方法的，我们后面会实现他。 MyModule._resolveFilename对应的源码看这里：https://github.com/nodejs/node/blob/c6b96895cc74bc6bd658b4c6d5ea152d6e686d20/lib/internal/modules/cjs/loader.js#L822 MyModule.prototype.load MyModule.prototype.load是一个实例方法，这个方法就是真正用来加载模块的方法，这其实也是不同类型文件加载的一个入口，不同类型的文件会对应MyModule._extensions里面的一个方法： MyModule.prototype.load = function (filename) { // 获取文件后缀名 const extname = path.extname(filename); // 调用后缀名对应的处理函数来处理 MyModule._extensions[extname](this, filename); this.loaded = true; } 注意这段代码里面的this指向的是module实例，因为他是一个实例方法。对应的源码看这里: https://github.com/nodejs/node/blob/c6b96895cc74bc6bd658b4c6d5ea152d6e686d20/lib/internal/modules/cjs/loader.js#L942 加载js文件: MyModule._extensions['.js'] 前面我们说过不同文件类型的处理方法都挂载在MyModule._extensions上面的，我们先来实现.js类型文件的加载： MyModule._extensions['.js'] = function (module, filename) { const content = fs.readFileSync(filename, 'utf8'); module._compile(content, filename); } 可以看到js的加载方法很简单，只是把文件内容读出来，然后调了另外一个实例方法_compile来执行他。对应的源码看这里：https://github.com/nodejs/node/blob/c6b96895cc74bc6bd658b4c6d5ea152d6e686d20/lib/internal/modules/cjs/loader.js#L1098 编译执行js文件：MyModule.prototype._compile MyModule.prototype._compile是加载JS文件的核心所在，也是我们最常使用的方法，这个方法需要将目标文件拿出来执行一遍，执行之前需要将它整个代码包裹一层，以便注入exports, require, module, __dirname, __filename，这也是我们能在JS文件里面直接使用这几个变量的原因。要实现这种注入也不难，假如我们require的文件是一个简单的Hello World，长这样： module.exports = \"hello world\"; 那我们怎么来给他注入module这个变量呢？答案是执行的时候在他外面再加一层函数，使他变成这样： function (module) { // 注入module变量，其实几个变量同理 module.exports = \"hello world\"; } 所以我们如果将文件内容作为一个字符串的话，为了让他能够变成上面这样，我们需要再给他拼接上开头和结尾，我们直接将开头和结尾放在一个数组里面: MyModule.wrapper = [ '(function (exports, require, module, __filename, __dirname) { ', '\\n});' ]; 注意我们拼接的开头和结尾多了一个()包裹，这样我们后面可以拿到这个匿名函数，在后面再加一个()就可以传参数执行了。然后将需要执行的函数拼接到这个方法中间： MyModule.wrap = function (script) { return MyModule.wrapper[0] + script + MyModule.wrapper[1]; }; 这样通过MyModule.wrap包装的代码就可以获取到exports, require, module, __filename, __dirname这几个变量了。知道了这些就可以来写MyModule.prototype._compile了: MyModule.prototype._compile = function (content, filename) { const wrapper = Module.wrap(content); // 获取包装后函数体 // vm是nodejs的虚拟机沙盒模块，runInThisContext方法可以接受一个字符串并将它转化为一个函数 // 返回值就是转化后的函数，所以compiledWrapper是一个函数 const compiledWrapper = vm.runInThisContext(wrapper, { filename, lineOffset: 0, displayErrors: true, }); // 准备exports, require, module, __filename, __dirname这几个参数 // exports可以直接用module.exports，即this.exports // require官方源码中还包装了一层，其实最后调用的还是this.require // module不用说，就是this了 // __filename直接用传进来的filename参数了 // __dirname需要通过filename获取下 const dirname = path.dirname(filename); compiledWrapper.call(this.exports, this.exports, this.require, this, filename, dirname); } 上述代码要注意我们注入进去的几个参数和通过call传进去的this: this:compiledWrapper是通过call调用的，第一个参数就是里面的this，这里我们传入的是this.exports，也就是module.exports，也就是说我们js文件里面this是对module.exports的一个引用。 exports: compiledWrapper正式接收的第一个参数是exports，我们传的也是this.exports,所以js文件里面的exports也是对module.exports的一个引用。 require: 这个方法我们传的是this.require，其实就是MyModule.prototype.require，也就是MyModule._load。 module: 我们传入的是this，也就是当前模块的实例。 __filename：文件所在的绝对路径。 __dirname: 文件所在文件夹的绝对路径。 到这里，我们的JS文件其实已经记载完了，对应的源码看这里:https://github.com/nodejs/node/blob/c6b96895cc74bc6bd658b4c6d5ea152d6e686d20/lib/internal/modules/cjs/loader.js#L1043 加载json文件: MyModule._extensions['.json'] 加载json文件就简单多了，只需要将文件读出来解析成json就行了： MyModule._extensions['.json'] = function (module, filename) { const content = fs.readFileSync(filename, 'utf8'); module.exports = JSONParse(content); } exports和module.exports的区别 网上经常有人问，node.js里面的exports和module.exports到底有什么区别，其实前面我们的手写代码已经给出答案了，我们这里再就这个问题详细讲解下。exports和module.exports这两个变量都是通过下面这行代码注入的。 compiledWrapper.call(this.exports, this.exports, this.require, this, filename, dirname); 初始状态下，exports === module.exports === {}，exports是module.exports的一个引用，如果你一直是这样使用的: exports.a = 1; module.exports.b = 2; console.log(exports === module.exports); // true 上述代码中，exports和module.exports都是指向同一个对象{}，你往这个对象上添加属性并没有改变这个对象本身的引用地址，所以exports === module.exports一直成立。 但是如果你哪天这样使用了: exports = { a: 1 } 或者这样使用了: module.exports = { b: 2 } 那其实你是给exports或者module.exports重新赋值了，改变了他们的引用地址，那这两个属性的连接就断开了，他们就不再相等了。需要注意的是，你对module.exports的重新赋值会作为模块的导出内容，但是你对exports的重新赋值并不能改变模块导出内容，只是改变了exports这个变量而已，因为模块始终是module，导出内容是module.exports。 循环引用 Node.js对于循环引用是进行了处理的，下面是官方例子： a.js: console.log('a 开始'); exports.done = false; const b = require('./b.js'); console.log('在 a 中，b.done = %j', b.done); exports.done = true; console.log('a 结束'); b.js: console.log('b 开始'); exports.done = false; const a = require('./a.js'); console.log('在 b 中，a.done = %j', a.done); exports.done = true; console.log('b 结束'); main.js: console.log('main 开始'); const a = require('./a.js'); const b = require('./b.js'); console.log('在 main 中，a.done=%j，b.done=%j', a.done, b.done); 当 main.js 加载 a.js 时， a.js 又加载 b.js。 此时， b.js 会尝试去加载 a.js。 为了防止无限的循环，会返回一个 a.js 的 exports 对象的 未完成的副本 给 b.js 模块。 然后 b.js 完成加载，并将 exports 对象提供给 a.js 模块。 那么这个效果是怎么实现的呢？答案就在我们的MyModule._load源码里面，注意这两行代码的顺序: MyModule._cache[filename] = module; module.load(filename); 上述代码中我们是先将缓存设置了，然后再执行的真正的load，顺着这个思路我能来理一下这里的加载流程: main加载a，a在真正加载前先去缓存中占一个位置 a在正式加载时加载了b b又去加载了a，这时候缓存中已经有a了，所以直接返回a.exports，即使这时候的exports是不完整的。 总结 require不是黑魔法，整个Node.js的模块加载机制都是JS实现的。 每个模块里面的exports, require, module, __filename, __dirname五个参数都不是全局变量，而是模块加载的时候注入的。 为了注入这几个变量，我们需要将用户的代码用一个函数包裹起来，拼一个字符串然后调用沙盒模块vm来实现。 初始状态下，模块里面的this, exports, module.exports都指向同一个对象，如果你对他们重新赋值，这种连接就断了。 对module.exports的重新赋值会作为模块的导出内容，但是你对exports的重新赋值并不能改变模块导出内容，只是改变了exports这个变量而已，因为模块始终是module，导出内容是module.exports。 为了解决循环引用，模块在加载前就会被加入缓存，下次再加载会直接返回缓存，如果这时候模块还没加载完，你可能拿到未完成的exports。 Node.js实现的这套加载机制叫CommonJS。 参考资料 Node.js模块加载源码：https://github.com/nodejs/node/blob/c6b96895cc74bc6bd658b4c6d5ea152d6e686d20/lib/internal/modules/cjs/loader.js Node.js模块官方文档：http://nodejs.cn/api/modules.html "},"Articles/Node/HttpServer.html":{"url":"Articles/Node/HttpServer.html","title":"使用Node.js原生API写一个web服务器","keywords":"","body":"Node.js是JavaScript基础上发展起来的语言，所以前端开发者应该天生就会一点。一般我们会用它来做CLI工具或者Web服务器，做Web服务器也有很多成熟的框架，比如Express和Koa。但是Express和Koa都是对Node.js原生API的封装，所以其实不借助任何框架，只用原生API我们也能写一个Web服务器出来。本文要讲的就是不借助框架，只用原生API怎么写一个Web服务器。因为在我的计划中，后面会写Express和Koa的源码解析，他们都是使用原生API来实现的。所以本文其实是这两个源码解析的前置知识，可以帮我们更好的理解Express和Koa这种框架的意义和源码。本文仅为说明原生API的使用方法，代码较丑，请不要在实际工作中模仿！ Hello World 要搭建一个简单的Web服务器，使用原生的http模块就够了，一个简单的Hello World程序几行代码就够了： const http = require('http') const port = 3000 const server = http.createServer((req, res) => { res.statusCode = 200 res.setHeader('Content-Type', 'text/plain') res.end('Hello World') }) server.listen(port, () => { console.log(`Server is running on http://127.0.0.1:${port}/`) }) 这个例子就很简单，直接用http.createServer创建了一个服务器，这个服务器也没啥逻辑，只是在访问的时候返回Hello World。服务器创建后，使用server.listen运行在3000端口就行。 这个例子确实简单，但是他貌似除了输出一个Hello World之外，啥也干不了，离我们一般使用的Web服务器还差了很远，主要是差了这几块： 不支持HTTP动词，比如GET，POST等 不支持路由 没有静态资源托管 不能持久化数据 前面三点是一个Web服务器必备的基础功能，第四点是否需要要看情况，毕竟目前很多Node的Web服务器只是作为一个中间层，真正跟数据库打交道做持久化的还是各种微服务，但是我们也应该知道持久化怎么做。 所以下面我们来写一个真正能用的Web服务器，也就是说把前面缺的几点都补上。 处理路由和HTTP动词 前面我们的那个Hello World也不是完全不能用，因为代码位置还是得在http.createServer里面，我们就在里面添加路由的功能。为了跟后面的静态资源做区分，我们的API请求都以/api开头。要做路由匹配也不难，最简单的就是直接用if条件判断就行。为了能拿到请求地址，我们需要使用url模块来解析传过来的地址。而Http动词直接可以用req.method拿到。所以http.createServer改造如下： const url = require('url'); const server = http.createServer((req, res) => { // 获取url的各个部分 // url.parse可以将req.url解析成一个对象 // 里面包含有pathname和querystring等 const urlObject = url.parse(req.url); const { pathname } = urlObject; // api开头的是API请求 if (pathname.startsWith('/api')) { // 再判断路由 if (pathname === '/api/users') { // 获取HTTP动词 const method = req.method; if (method === 'GET') { // 写一个假数据 const resData = [ { id: 1, name: '小明', age: 18 }, { id: 2, name: '小红', age: 19 } ]; res.setHeader('Content-Type', 'application/json') res.end(JSON.stringify(resData)); return; } } } }); 现在我们访问/api/users就可以拿到用户列表了： 支持静态文件 上面说了API请求是以/api开头，也就是说不是以这个开头的可以认为都是静态文件，不同文件有不同的Content-Type，我们这个例子里面暂时只支持一种.jpg吧。其实就是给我们的if (pathname.startsWith('/api'))加一个else就行。返回静态文件需要： 使用fs模块读取文件。 返回文件的时候根据不同的文件类型设置不同的Content-Type。 所以我们这个else就长这个样子： // ... 省略前后代码 ... else { // 使用path模块获取文件后缀名 const extName = path.extname(pathname); if (extName === '.jpg') { // 使用fs模块读取文件 fs.readFile(pathname, (err, data) => { res.setHeader('Content-Type', 'image/jpeg'); res.write(data); res.end(); }) } } 然后我们在同级目录下放一个图片试一下： 数据持久化 数据持久化的方式有好几种，一般都是存数据库，少数情况下也有存文件的。存数据库比较麻烦，还需要创建和连接数据库，我们这里不好demo，我们这里演示一个存文件的例子。一般POST请求是用来存新数据的，我们在前面的基础上再添加一个POST /api/users来新增一条数据，只需要在前面的if (method === 'GET')后面加一个POST的判断就行： // ... 省略其他代码 ... else if (method === 'POST') { // 注意数据传过来可能有多个chunk // 我们需要拼接这些chunk let postData = ''; req.on('data', chunk => { postData = postData + chunk; }) req.on('end', () => { // 数据传完后往db.txt插入内容 fs.appendFile(path.join(__dirname, 'db.txt'), postData, () => { res.end(postData); // 数据写完后将数据再次返回 }); }) } 然后我们测试一下这个API: 再去看看文件里面写进去没有： 总结 到这里我们就完成了一个具有基本功能的web服务器，代码不复杂，但是对于帮我们理解Node web服务器的原理很有帮助。但是上述代码还有个很大的问题就是：代码很丑！所有代码都写在一堆，而且HTTP动词和路由匹配全部是使用if条件判断，如果有几百个API，再配合十来个动词，那代码简直就是个灾难！所以我们应该将路由处理，HTTP动词，静态文件，数据持久化这些功能全部抽离出来，让整个应用变得更优雅，更好扩展。这就是Express和Koa这些框架存在的意义，下一篇文章我们就去Express的源码看看他是怎么解决这个问题的，点个关注不迷路~ "},"Articles/Node/Express.html":{"url":"Articles/Node/Express.html","title":"手写Express.js源码","keywords":"","body":"上一篇文章我们讲了怎么用Node.js原生API来写一个web服务器，虽然代码比较丑，但是基本功能还是有的。但是一般我们不会直接用原生API来写，而是借助框架来做，比如本文要讲的Express。通过上一篇文章的铺垫，我们可以猜测，Express其实也没有什么黑魔法，也仅仅是原生API的封装，主要是用来提供更好的扩展性，使用起来更方便，代码更优雅。本文照例会从Express的基本使用入手，然后自己手写一个Express来替代他，也就是源码解析。 简单示例 使用Express搭建一个最简单的Hello World也是几行代码就可以搞定，下面这个例子来源官方文档： const express = require('express'); const app = express(); const port = 3000; app.get('/', (req, res) => { res.send('Hello World!'); }); app.listen(port, () => { console.log(`Example app listening at http://localhost:${port}`); }); 可以看到Express的路由可以直接用app.get这种方法来处理，比我们之前在http.createServer里面写一堆if优雅多了。我们用这种方式来改写下上一篇文章的代码： const path = require(\"path\"); const express = require(\"express\"); const fs = require(\"fs\"); const url = require(\"url\"); const app = express(); const port = 3000; app.get(\"/\", (req, res) => { res.end(\"Hello World\"); }); app.get(\"/api/users\", (req, res) => { const resData = [ { id: 1, name: \"小明\", age: 18, }, { id: 2, name: \"小红\", age: 19, }, ]; res.setHeader(\"Content-Type\", \"application/json\"); res.end(JSON.stringify(resData)); }); app.post(\"/api/users\", (req, res) => { let postData = \"\"; req.on(\"data\", (chunk) => { postData = postData + chunk; }); req.on(\"end\", () => { // 数据传完后往db.txt插入内容 fs.appendFile(path.join(__dirname, \"db.txt\"), postData, () => { res.end(postData); // 数据写完后将数据再次返回 }); }); }); app.listen(port, () => { console.log(`Server is running on http://localhost:${port}/`); }); Express还支持中间件，我们写个中间件来打印出每次请求的路径： app.use((req, res, next) => { const urlObject = url.parse(req.url); const { pathname } = urlObject; console.log(`request path: ${pathname}`); next(); }); Express也支持静态资源托管，不过他的API是需要指定一个文件夹来单独存放静态资源的，比如我们新建一个public文件夹来存放静态资源，使用express.static中间件配置一下就行： app.use(express.static(path.join(__dirname, 'public'))); 然后就可以拿到静态资源了： 手写源码 手写源码才是本文的重点，前面的不过是铺垫，本文手写的目标就是自己写一个express来替换前面用到的express api，其实就是源码解析。在开始之前，我们先来看看用到了哪些API： express()，第一个肯定是express函数，这个运行后会返回一个app的实例，后面用的很多方法都是这个app上的。 app.listen，这个方法类似于原生的server.listen，用来启动服务器。 app.get，这是处理路由的API，类似的还有app.post等。 app.use，这是中间件的调用入口，所有中间件都要通过这个方法来调用。 express.static，这个中间件帮助我们做静态资源托管，其实是另外一个库了，叫serve-static，因为跟Express架构关系不大，本文就先不讲他的源码了。 本文所有手写代码全部参照官方源码写成，方法名和变量名尽量与官方保持一致，大家可以对照着看，写到具体的方法时我也会贴出官方源码的地址。 express() 首先需要写的肯定是express()，这个方法是一切的开始，他会创建并返回一个app，这个app就是我们的web服务器。 // express.js var mixin = require('merge-descriptors'); var proto = require('./application'); // 创建web服务器的方法 function createApplication() { // 这个app方法其实就是传给http.createServer的回调函数 var app = function (req, res) { }; mixin(app, proto, false); return app; } exports = module.exports = createApplication; 上述代码就是我们在运行express()的时候执行的代码，其实就是个空壳，返回的app暂时是个空函数，真正的app并没在这里，而是在proto上，从上述代码可以看出proto其实就是application.js，然后通过下面这行代码将proto上的东西都赋值给了app： mixin(app, proto, false); 这行代码用到了一个第三方库merge-descriptors，这个库总共没有几行代码，做的事情也很简单，就是将proto上面的属性挨个赋值给app，对merge-descriptors源码感兴趣的可以看这里：https://github.com/component/merge-descriptors/blob/master/index.js。 Express这里之所以使用mixin，而不是普通的面向对象来继承，是因为它除了要mixin proto外，还需要mixin其他库，也就是需要多继承，我这里省略了，但是官方源码是有的。 express.js对应的源码看这里：https://github.com/expressjs/express/blob/master/lib/express.js app.listen 上面说了，express.js只是一个空壳，真正的app在application.js里面，所以app.listen也是在这里。 // application.js var app = exports = module.exports = {}; app.listen = function listen() { var server = http.createServer(this); return server.listen.apply(server, arguments); }; 上面代码就是调用原生http模块创建了一个服务器，但是传的参数是this，这里的this是什么呢？回想一下我们使用express的时候是这样用的： const app = express(); app.listen(3000); 所以listen方法的实际调用者是express()的返回值，也就是上面express.js里面createApplication的返回值，也就是这个函数: var app = function (req, res) { }; 所以这里的this也是这个函数，所以我在express.js里面就加了注释，这个函数是http.createServer的回调函数。现在这个函数是空的，实际上他应该是整个web服务器的处理入口，所以我们给他加上处理的逻辑，在里面再加一行代码： var app = function(req, res) { app.handle(req, res); // 这是真正的服务器处理入口 }; app.handle app.handle也是挂载在app下面的，所以他实际也在application.js这个文件里面，下面我们来看看他干了什么： app.handle = function handle(req, res) { var router = this._router; // 最终的处理方法 var done = finalhandler(req, res); // 如果没有定义router // 直接结束返回 if (!router) { done(); return; } // 有router，就用router来处理 router.handle(req, res, done); } 上面代码可以看出，实际处理路由的是router，这是Router的一个实例，并且挂载在this上的，我们这里还没有给他赋值，如果没有赋值的话，会直接运行finalhandler并且结束处理。finalhandler也是一个第三方库，GitHub链接在这里：https://github.com/pillarjs/finalhandler。这个库的功能也不复杂，就是帮你处理一些收尾的工作，比如所有路由都没匹配上，你可能需要返回404并记录下error log，这个库就可以帮你做。 app.get 上面说了，在具体处理网络请求时，实际上是用app._router来处理的，那么app._router是在哪里赋值的呢？事实上app._router的赋值有多个地方，一个地方就是HTTP动词处理方法上，比如我们用到的app.get或者app.post。无论是app.get还是app.post都是调用的router方法来处理，所以可以统一用一个循环来写这一类的方法。 // HTTP动词的方法 var methods = ['get', 'post']; methods.forEach(function (method) { app[method] = function (path) { this.lazyrouter(); var route = this._router.route(path); route[method].apply(route, Array.prototype.slice.call(arguments, 1)); return this; } }); 上面代码HTTP动词都放到了一个数组里面，官方源码中这个数组也是一个第三方库维护的，名字就叫methods，GitHub地址在这里：https://github.com/jshttp/methods。我这个例子因为只需要两个动词，就简化了，直接用数组了。这段代码其实给app创建了跟每个动词同名的函数，所有动词的处理函数都是一样的，都是去调router里面的对应方法来处理。这种将不同部分抽取出来，从而复用共同部分的代码，有点像我之前另一篇文章写过的设计模式----享元模式。 我们注意到上面代码除了调用router来处理路由外，还有一行代码： this.lazyrouter(); lazyrouter方法其实就是我们给this._router赋值的地方，代码也比较简单，就是检测下有没有_router，如果没有就给他赋个值，赋的值就是Router的一个实例： app.lazyrouter = function lazyrouter() { if (!this._router) { this._router = new Router(); } } app.listen，app.handle和methods处理方法都在application.js里面，application.js源码在这里:https://github.com/expressjs/express/blob/master/lib/application.js Router 写到这里我们发现我们已经使用了Router的多个API，比如： router.handle router.route route[method] 所以我们来看下Router这个类，下面的代码是从源码中简化出来的： // router/index.js var setPrototypeOf = require('setprototypeof'); var proto = module.exports = function () { function router(req, res, next) { router.handle(req, res, next); } setPrototypeOf(router, proto); return router; } 这段代码对我来说是比较奇怪的，我们在执行new Router()的时候其实执行的是new proto()，new proto()并不是我奇怪的地方，奇怪的是他设置原型的方式。我之前在讲JS的面向对象的文章提到过如果你要给一个类加上类方法可以这样写： function Class() {} Class.prototype.method1 = function() {} var instance = new Class(); 这样instance.__proto__就会指向Class.prototype，你就可使用instance.method1了。 Express.js的上述代码其实也是实现了类似的效果，setprototypeof又是一个第三方库，作用类似Object.setPrototypeOf(obj, prototype)，就是给一个对象设置原型，setprototypeof存在的意义就是兼容老标准的JS，也就是加了一些polyfill，他的代码在这里。所以： setPrototypeOf(router, proto); 这行代码的意思就是让router.__proto__指向proto，router是你在new proto()时的返回对象，执行了上面这行代码，这个router就可以拿到proto上的全部方法了。像router.handle这种方法就可以挂载到proto上了，成为proto.handle。 绕了一大圈，其实就是JS面向对象的使用，给router添加类方法，但是为什么使用这么绕的方式，而不是像我上面那个Class那样用呢？这我就不是很清楚了，可能有什么历史原因吧。 路由架构 Router的基本结构知道了，要理解Router的具体代码，我们还需要对Express的路由架构有一个整体的认识。就以我们这两个示例API来说： get /api/users post /api/users 我们发现他们的path是一样的，都是/api/users，但是他们的请求方法，也就是method不一样。Express里面将path这一层提取出来作为了一个类，叫做Layer。但是对于一个Layer，我们只知道他的path，不知道method的话，是不能确定一个路由的，所以Layer上还添加了一个属性route，这个route上也存了一个数组，数组的每个项存了对应的method和回调函数handle。整个结构你可以理解成这个样子： const router = { stack: [ // 里面很多layer { path: '/api/users' route: { stack: [ // 里面存了多个method和回调函数 { method: 'get', handle: function1 }, { method: 'post', handle: function2 } ] } } ] } 知道了这个结构我们可以猜到，整个流程可以分成两部分：注册路由和匹配路由。当我们写app.get和app.post这些方法时，其实就是在router上添加layer和route。当一个网络请求过来时，其实就是遍历layer和route，找到对应的handle拿出来执行。 注意route数组里面的结构，每个项按理来说应该使用一种新的数据结构来存储，比如routeItem之类的。但是Express并没有这样做，而是将它和layer合在一起了，给layer添加了method和handle属性。这在初次看源码的时候可能造成困惑，因为layer同时存在于router的stack上和route的stack上，肩负了两种职责。 router.route 这个方法是我们前面注册路由的时候调用的一个方法，回顾下前面的注册路由的方法，比如app.get： app.get = function (path) { this.lazyrouter(); var route = this._router.route(path); route.get.apply(route, Array.prototype.slice.call(arguments, 1)); return this; } 结合上面讲的路由架构，我们在注册路由的时候，应该给router添加对应的layer和route，router.route的代码就不难写出了： proto.route = function route(path) { var route = new Route(); var layer = new Layer(path, route.dispatch.bind(route)); // 参数是path和回调函数 layer.route = route; this.stack.push(layer); return route; } Layer和Route构造函数 上面代码新建了Route和Layer实例，这两个类的构造函数其实也挺简单的。只是参数的申明和初始化： // layer.js module.exports = Layer; function Layer(path, fn) { this.path = path; this.handle = fn; this.method = ''; } // route.js module.exports = Route; function Route() { this.stack = []; this.methods = {}; // 一个加快查找的hash表 } route.get 前面我们看到了app.get其实通过下面这行代码，最终调用的是route.get： route.get.apply(route, Array.prototype.slice.call(arguments, 1)); 也知道了route.get这种动词处理函数，其实就是往route.stack上添加layer，那我们的route.get也可以写出来了： var methods = [\"get\", \"post\"]; methods.forEach(function (method) { Route.prototype[method] = function () { // 支持传入多个回调函数 var handles = flatten(slice.call(arguments)); // 为每个回调新建一个layer，并加到stack上 for (var i = 0; i 这样，其实整个router的结构就构建出来了，后面就看看怎么用这个结构来处理请求了，也就是router.handle方法。 router.handle 前面说了app.handle实际上是调用的router.handle，也知道了router的结构是在stack上添加了layer和router，所以router.handle需要做的就是从router.stack上找出对应的layer和router并执行回调函数： // 真正处理路由的函数 proto.handle = function handle(req, res, done) { var self = this; var idx = 0; var stack = self.stack; // next方法来查找对应的layer和回调函数 next(); function next() { // 使用第三方库parseUrl获取path，如果没有path，直接返回 var path = parseUrl(req).pathname; if (path == null) { return done(); } var layer; var match; var route; while (match !== true && idx 上面代码还用到了几个Layer和Route的实例方法： layer.match(path): 检测当前layer的path是否匹配。 route._handles_method(method)：检测当前route的method是否匹配。 layer.handle_request(req, res, next)：使用layer的回调函数来处理请求。 这几个方法看起来并不复杂，我们后面一个一个来实现。 到这里其实还有个疑问。从他整个的匹配流程来看，他寻找的其实是router.stack.layer这一层，但是最终应该执行的回调却是在router.stack.layer.route.stack.layer.handle。这是怎么通过router.stack.layer找到最终的router.stack.layer.route.stack.layer.handle来执行的呢？ 这要回到我们前面的router.route方法： proto.route = function route(path) { var route = new Route(); var layer = new Layer(path, route.dispatch.bind(route)); layer.route = route; this.stack.push(layer); return route; } 这里我们new Layer的时候给的回调其实是route.dispatch.bind(route)，这个方法会再去route.stack上找到正确的layer来执行。所以router.handle真正的流程其实是： 找到path匹配的layer 拿出layer上的route，看看有没有匹配的method layer和method都有匹配的，再调用route.dispatch去找出真正的回调函数来执行。 所以又多了一个需要实现的函数,route.dispatch。 layer.match layer.match是用来检测当前path是否匹配的函数，用到了一个第三方库path-to-regexp，这个库可以将path转为正则表达式，方便后面的匹配，这个库在之前写过的react-router源码中也出现过。 var pathRegexp = require(\"path-to-regexp\"); module.exports = Layer; function Layer(path, fn) { this.path = path; this.handle = fn; this.method = \"\"; // 添加一个匹配正则 this.regexp = pathRegexp(path); // 快速匹配/ this.regexp.fast_slash = path === \"/\"; } 然后就可以添加match实例方法了： Layer.prototype.match = function match(path) { var match; if (path != null) { if (this.regexp.fast_slash) { return true; } match = this.regexp.exec(path); } // 没匹配上，返回false if (!match) { return false; } // 不然返回true return true; }; layer.handle_request layer.handle_request是用来调用具体的回调函数的方法，其实就是拿出layer.handle来执行： Layer.prototype.handle_request = function handle(req, res, next) { var fn = this.handle; fn(req, res, next); }; route._handles_method route._handles_method就是检测当前route是否包含需要的method，因为之前添加了一个methods对象，可以用它来进行快速查找： Route.prototype._handles_method = function _handles_method(method) { var name = method.toLowerCase(); return Boolean(this.methods[name]); }; route.dispatch route.dispatch其实是router.stack.layer的回调函数，作用是找到对应的router.stack.layer.route.stack.layer.handle并执行。 Route.prototype.dispatch = function dispatch(req, res, done) { var idx = 0; var stack = this.stack; // 注意这个stack是route.stack // 如果stack为空，直接done // 这里的done其实是router.stack.layer的next // 也就是执行下一个router.stack.layer if (stack.length === 0) { return done(); } var method = req.method.toLowerCase(); // 这个next方法其实是在router.stack.layer.route.stack上寻找method匹配的layer // 找到了就执行layer的回调函数 next(); function next() { var layer = stack[idx++]; if (!layer) { return done(); } if (layer.method && layer.method !== method) { return next(); } layer.handle_request(req, res, next); } }; 到这里其实Express整体的路由结构，注册和执行流程都完成了，贴下对应的官方源码： Router类：https://github.com/expressjs/express/blob/master/lib/router/index.js Layer类：https://github.com/expressjs/express/blob/master/lib/router/layer.js Route类：https://github.com/expressjs/express/blob/master/lib/router/route.js 中间件 其实我们前面已经隐含了中间件，从前面的结构可以看出，一个网络请求过来，会到router的第一个layer，然后调用next到到第二个layer，匹配上layer的path就执行回调，然后一直这样把所有的layer都走完。所以中间件是啥？中间件就是一个layer，他的path默认是/，也就是对所有请求都生效。按照这个思路，代码就简单了： // application.js // app.use就是调用router.use app.use = function use(fn) { var path = \"/\"; this.lazyrouter(); var router = this._router; router.use(path, fn); }; 然后在router.use里面再加一层layer就行了： proto.use = function use(path, fn) { var layer = new Layer(path, fn); this.stack.push(layer); }; 总结 Express也是用原生APIhttp.createServer来实现的。 Express的主要工作是将http.createServer的回调函数拆出来了，构建了一个路由结构Router。 这个路由结构由很多层layer组成。 一个中间件就是一个layer。 路由也是一个layer，layer上有一个path属性来表示他可以处理的API路径。 path可能有不同的method，每个method对应layer.route上的一个layer。 layer.route上的layer虽然名字和router上的layer一样，但是功能侧重点并不一样，这也是源码中让人困惑的一个点。 layer.route上的layer的主要参数是method和handle，如果method匹配了，就执行对应的handle。 整个路由匹配过程其实就是遍历router.layer的一个过程。 每个请求来了都会遍历一遍所有的layer，匹配上就执行回调，一个请求可能会匹配上多个layer。 总体来看，Express代码给人的感觉并不是很完美，特别是Layer类肩负两种职责，跟软件工程强调的单一职责原则不符，这也导致Router，Layer，Route三个类的调用关系有点混乱。而且对于继承和原型的使用都是很老的方式。可能也是这种不完美催生了Koa的诞生，下一篇文章我们就来看看Koa的源码吧。 Express其实还对原生的req和res进行了扩展，让他们变得更好用，但是这个其实只相当于一个语法糖，对整体架构没有太大影响，所以本文就没涉及了。 参考资料 Express官方文档：http://expressjs.com/ Express官方源码：https://github.com/expressjs/express/tree/master/lib "},"Articles/Node/Koa.html":{"url":"Articles/Node/Koa.html","title":"手写Koa源码","keywords":"","body":"用Node.js写一个web服务器，我前面已经写过两篇文章了： 第一篇是不使用任何框架也能搭建一个web服务器，主要是熟悉Node.js原生API的使用：使用Node.js原生API写一个web服务器 第二篇文章是看了Express的基本用法，更主要的是看了下他的源码：手写Express.js源码 Express的源码还是比较复杂的，自带了路由处理和静态资源支持等等功能，功能比较全面。与之相比，本文要讲的Koa就简洁多了，Koa虽然是Express的原班人马写的，但是设计思路却不一样。Express更多是偏向All in one的思想，各种功能都集成在一起，而Koa本身的库只有一个中间件内核，其他像路由处理和静态资源这些功能都没有，全部需要引入第三方中间件库才能实现。下面这张图可以直观的看到Express和koa在功能上的区别，此图来自于官方文档： 基于Koa的这种架构，我计划会分几篇文章来写，全部都是源码解析： Koa的核心架构会写一篇文章，也就是本文。 对于一个web服务器来说，路由是必不可少的，所以@koa/router会写一篇文章。 另外可能会写一些常用中间件，静态文件支持或者bodyparser等等，具体还没定，可能会有一篇或多篇文章。 简单示例 我写源码解析，一般都遵循一个简单的套路：先引入库，写一个简单的例子，然后自己手写源码来替代这个库，并让我们的例子顺利运行。本文也是遵循这个套路，由于Koa的核心库只有中间件，所以我们写出的例子也比较简单，也只有中间件。 Hello World 第一个例子是Hello World，随便请求一个路径都返回Hello World。 const Koa = require(\"koa\"); const app = new Koa(); app.use((ctx) => { ctx.body = \"Hello World\"; }); const port = 3001; app.listen(port, () => { console.log(`Server is running on http://127.0.0.1:${port}/`); }); logger 然后再来一个logger吧，就是记录下处理当前请求花了多长时间： app.use(async (ctx, next) => { const start = Date.now(); await next(); const ms = Date.now() - start; console.log(`${ctx.method} ${ctx.url} - ${ms}ms`); }); 注意这个中间件应该放到Hello World的前面。 从上面两个例子的代码来看，Koa跟Express有几个明显的区别： ctx替代了req和res 可以使用JS的新API了，比如async和await 手写源码 手写源码前我们看看用到了哪些API，这些就是我们手写的目标： new Koa()：首先肯定是Koa这个类了，因为他使用new进行实例化，所以我们认为他是一个类。 app.use：app是Koa的一个实例，app.use看起来是一个添加中间件的实例方法。 app.listen：启动服务器的实例方法 ctx：这个是Koa的上下文，看起来替代了以前的req和res async和await：支持新的语法，而且能使用await next()，说明next()返回的很可能是一个promise。 本文的手写源码全部参照官方源码写成，文件名和函数名尽量保持一致，写到具体的方法时我也会贴上官方源码地址。Koa这个库代码并不多，主要都在这个文件夹里面：https://github.com/koajs/koa/tree/master/lib，下面我们开始吧。 Koa类 从Koa项目的package.json里面的main这行代码可以看出，整个应用的入口是lib/application.js这个文件： \"main\": \"lib/application.js\", lib/application.js这个文件就是我们经常用的Koa类，虽然我们经常叫他Koa类，但是在源码里面这个类叫做Application。我们先来写一下这个类的壳吧： // application.js const Emitter = require(\"events\"); // module.exports 直接导出Application类 module.exports = class Application extends Emitter { // 构造函数先运行下父类的构造函数 // 再进行一些初始化工作 constructor() { super(); // middleware实例属性初始化为一个空数组，用来存储后续可能的中间件 this.middleware = []; } }; 这段代码我们可以看出，Koa直接使用class关键字来申明类了，看过我之前Express源码解析的朋友可能还有印象，Express源码里面还是使用的老的prototype来实现面向对象的。所以Koa项目介绍里面的Expressive middleware for node.js using ES2017 async functions并不是一句虚言，它不仅支持ES2017新的API，而且在自己的源码里面里面也是用的新API。我想这也是Koa要求运行环境必须是node v7.6.0 or higher的原因吧。所以到这里我们其实已经可以看出Koa和Express的一个重大区别了，那就是：Express使用老的API，兼容性更强，可以在老的Node.js版本上运行；Koa因为使用了新API，只能在v7.6.0或者更高版本上运行了。 这段代码还有个点需要注意，那就是Application继承自Node.js原生的EventEmitter类，这个类其实就是一个发布订阅模式，可以订阅和发布消息，我在另一篇文章里面详细讲过他的源码。所以他有些方法如果在application.js里面找不到，那可能就是继承自EventEmitter，比如下图这行代码： 这里有this.on这个方法，看起来他应该是Application的一个实例方法，但是这个文件里面没有，其实他就是继承自EventEmitter，是用来给error这个事件添加回调函数的。这行代码if里面的this.listenerCount也是EventEmitter的一个实例方法。 Application类完全是JS面向对象的运用，如果你对JS面向对象还不是很熟悉，可以先看看这篇文章：https://juejin.im/post/6844904069887164423。 app.use 从我们前面的使用示例可以看出app.use的作用就是添加一个中间件，我们在构造函数里面也初始化了一个变量middleware，用来存储中间件，所以app.use的代码就很简单了，将接收到的中间件塞到这个数组就行： use(fn) { // 中间件必须是一个函数，不然就报错 if (typeof fn !== \"function\") throw new TypeError(\"middleware must be a function!\"); // 处理逻辑很简单，将接收到的中间件塞入到middleware数组就行 this.middleware.push(fn); return this; } 注意app.use方法最后返回了this，这个有点意思，为什么要返回this呢？这个其实我之前在其他文章讲过的：类的实例方法返回this可以实现链式调用。比如这里的app.use就可以连续点点点了，像这样： app.use(middlewaer1).use(middlewaer2).use(middlewaer3) 为什么会有这种效果呢？因为这里的this其实就是当前实例，也就是app，所以app.use()的返回值就是app，app上有个实例方法use，所以可以继续点app.use().use()。 app.use的官方源码看这里: https://github.com/koajs/koa/blob/master/lib/application.js#L122 app.listen 在前面的示例中，app.listen的作用是用来启动服务器，看过前面用原生API实现web服务器的朋友都知道，要启动服务器需要调用原生的http.createServer，所以这个方法就是用来调用http.createServer的。 listen(...args) { const server = http.createServer(this.callback()); return server.listen(...args); } 这个方法本身其实没有太多可说的，只是调用http模块启动服务而已，主要的逻辑都在this.callback()里面了。 app.listen的官方源码看这里：https://github.com/koajs/koa/blob/master/lib/application.js#L79 app.callback this.callback()是传给http.createServer的回调函数，也是一个实例函数，这个函数必须符合http.createServer的参数形式，也就是 http.createServer(function(req, res){}) 所以this.callback()的返回值必须是一个函数，而且是这种形式function(req, res){}。 除了形式必须符合外，this.callback()具体要干什么呢？他是http模块的回调函数，所以他必须处理所有的网络请求，所有处理逻辑都必须在这个方法里面。但是Koa的处理逻辑是以中间件的形式存在的，对于一个请求来说，他必须一个一个的穿过所有的中间件，具体穿过的逻辑，你当然可以遍历middleware这个数组，将里面的方法一个一个拿出来处理，当然也可以用业界更常用的方法：compose。 compose一般来说就是将一系列方法合并成一个方法来方便调用，具体实现的形式并不是固定的，有面试中常见的用reduce实现的compose，也有像Koa这样根据自己需求单独实现的compose。Koa的compose也单独封装了一个库koa-compose，这个库源码也是我们必须要看的，我们一步一步来，先把this.callback写出来吧。 callback() { // compose来自koa-compose库，就是将中间件合并成一个函数 // 我们需要自己实现 const fn = compose(this.middleware); // callback返回值必须符合http.createServer参数形式 // 即 (req, res) => {} const handleRequest = (req, res) => { const ctx = this.createContext(req, res); return this.handleRequest(ctx, fn); }; return handleRequest; } 这个方法先用koa-compose将中间件都合成了一个函数fn，然后在http.createServer的回调里面使用req和res创建了一个Koa常用的上下文ctx，然后再调用this.handleRequest来真正处理网络请求。注意这里的this.handleRequest是个实例方法，和当前方法里面的局部变量handleRequest并不是一个东西。这几个方法我们一个一个来看下。 this.callback对应的官方源码看这里：https://github.com/koajs/koa/blob/master/lib/application.js#L143 koa-compose koa-compose虽然被作为了一个单独的库，但是他的作用却很关键，所以我们也来看看他的源码吧。koa-compose的作用是将一个中间件组成的数组合并成一个方法以便外部调用。我们先来回顾下一个Koa中间件的结构： function middleware(ctx, next) {} 这个数组就是有很多这样的中间件： [ function middleware1(ctx, next) {}, function middleware2(ctx, next) {} ] Koa的合并思路并不复杂，就是让compose再返回一个函数，返回的这个函数会开始这个数组的遍历工作： function compose(middleware) { // 参数检查，middleware必须是一个数组 if (!Array.isArray(middleware)) throw new TypeError(\"Middleware stack must be an array!\"); // 数组里面的每一项都必须是一个方法 for (const fn of middleware) { if (typeof fn !== \"function\") throw new TypeError(\"Middleware must be composed of functions!\"); } // 返回一个方法，这个方法就是compose的结果 // 外部可以通过调用这个方法来开起中间件数组的遍历 // 参数形式和普通中间件一样，都是context和next return function (context, next) { return dispatch(0); // 开始中间件执行，从数组第一个开始 // 执行中间件的方法 function dispatch(i) { let fn = middleware[i]; // 取出需要执行的中间件 // 如果i等于数组长度，说明数组已经执行完了 if (i === middleware.length) { fn = next; // 这里让fn等于外部传进来的next，其实是进行收尾工作，比如返回404 } // 如果外部没有传收尾的next，直接就resolve if (!fn) { return Promise.resolve(); } // 执行中间件，注意传给中间件接收的参数应该是context和next // 传给中间件的next是dispatch.bind(null, i + 1) // 所以中间件里面调用next的时候其实调用的是dispatch(i + 1)，也就是执行下一个中间件 try { return Promise.resolve(fn(context, dispatch.bind(null, i + 1))); } catch (err) { return Promise.reject(err); } } }; } 上面代码主要的逻辑就是这行： return Promise.resolve(fn(context, dispatch.bind(null, i + 1))); 这里的fn就是我们自己写的中间件，比如文章开始那个logger，我们稍微改下看得更清楚: const logger = async (ctx, next) => { const start = Date.now(); await next(); const ms = Date.now() - start; console.log(`${ctx.method} ${ctx.url} - ${ms}ms`); }; app.use(logger); 那我们compose里面执行的其实是: logger(context, dispatch.bind(null, i + 1)); 也就是说logger接收到的next其实是dispatch.bind(null, i + 1)，你调用next()的时候，其实调用的是dispatch(i + 1)，这样就达到了执行数组下一个中间件的效果。 另外由于中间件在返回前还包裹了一层Promise.resolve，所以我们所有自己写的中间件，无论你是否用了Promise，next调用后返回的都是一个Promise，所以你可以使用await next()。 koa-compose的源码看这里：https://github.com/koajs/compose/blob/master/index.js app.createContext 上面用到的this.createContext也是一个实例方法。这个方法根据http.createServer传入的req和res来构建ctx这个上下文，官方源码长这样： 这段代码里面context，ctx，response，res，request，req，app这几个变量相互赋值，头都看晕了。其实完全没必要陷入这堆面条里面去，我们只需要将他的思路和骨架拎清楚就行，那怎么来拎呢？ 首先搞清楚他这么赋值的目的，他的目的其实很简单，就是为了使用方便。通过一个变量可以很方便的拿到其他变量，比如我现在只有request，但是我想要的是req，怎么办呢？通过这种赋值后，直接用request.req就行。其他的类似，这种面条式的赋值我很难说好还是不好，但是使用时确实很方便，缺点就是看源码时容易陷进去。 那request和req有啥区别？这两个变量长得这么像，到底是干啥的？这就要说到Koa对于原生req的扩展，我们知道http.createServer的回调里面会传入req作为请求对象的描述，里面可以拿到请求的header啊，method啊这些变量。但是Koa觉得这个req提供的API不好用，所以他在这个基础上扩展了一些API，其实就是一些语法糖，扩展后的req就变成了request。之所以扩展后还保留的原始的req，应该也是想为用户提供更多选择吧。所以这两个变量的区别就是request是Koa包装过的req，req是原生的请求对象。response和res也是类似的。 既然request和response都只是包装过的语法糖，那其实Koa没有这两个变量也能跑起来。所以我们拎骨架的时候完全可以将这两个变量踢出去，这下骨架就清晰了。 那我们踢出response和request后再来写下createContext这个方法： // 创建上下文ctx对象的函数 createContext(req, res) { const context = Object.create(this.context); context.app = this; context.req = req; context.res = res; return context; } 这下整个世界感觉都清爽了，context上的东西也一目了然了。但是我们的context最初是来自this.context的，这个变量还必须看下。 app.createContext对应的官方源码看这里：https://github.com/koajs/koa/blob/master/lib/application.js#L177 context.js 上面的this.context其实就是来自context.js，所以我们先在Application构造函数里面添加这个变量： // application.js const context = require(\"./context\"); // 构造函数里面 constructor() { // 省略其他代码 this.context = context; } 然后再来看看context.js里面有啥，context.js的结构大概是这个样子： const delegate = require(\"delegates\"); module.exports = { inspect() {}, toJSON() {}, throw() {}, onerror() {}, }; const proto = module.exports; delegate(proto, \"response\") .method(\"set\") .method(\"append\") .access(\"message\") .access(\"body\"); delegate(proto, \"request\") .method(\"acceptsLanguages\") .method(\"accepts\") .access(\"querystring\") .access(\"socket\"); 这段代码里面context导出的是一个对象proto，这个对象本身有一些方法，inspect，toJSON之类的。然后还有一堆delegate().method()，delegate().access()之类的。嗯，这个是干啥的呢？要知道这个的作用，我们需要去看delegates这个库：https://github.com/tj/node-delegates，这个库也是tj大神写的。一般使用是这样的： delegate(proto, target).method(\"set\"); 这行代码的作用是，当你调用proto.set()方法时，其实是转发给了proto[target]，实际调用的是proto[target].set()。所以就是proto代理了对target的访问。 那用在我们context.js里面是啥意思呢？比如这行代码： delegate(proto, \"response\") .method(\"set\"); 这行代码的作用是，当你调用proto.set()时，实际去调用proto.response.set()，将proto换成ctx就是：当你调用ctx.set()时，实际调用的是ctx.response.set()。这么做的目的其实也是为了使用方便，可以少写一个response。而且ctx不仅仅代理response，还代理了request，所以你还可以通过ctx.accepts()这样来调用到ctx.request.accepts()。一个ctx就囊括了response和request，所以这里的context也是一个语法糖。因为我们前面已经踢了response和request这两个语法糖，context作为包装了这两个语法糖的语法糖，我们也一起踢掉吧。在Application的构造函数里面直接将this.context赋值为空对象： // application.js constructor() { // 省略其他代码 this.context = {}; } 现在语法糖都踢掉了，整个Koa的结构就更清晰了，ctx上面也只有几个必须的变量： ctx = { app, req, res } context.js对应的源码看这里:https://github.com/koajs/koa/blob/master/lib/context.js app.handleRequest 现在我们ctx和fn都构造好了，那我们处理请求其实就是调用fn，ctx是作为参数传给他的，所以app.handleRequest代码就可以写出来了: // 处理具体请求 handleRequest(ctx, fnMiddleware) { const handleResponse = () => respond(ctx); // 调用中间件处理 // 所有处理完后就调用handleResponse返回请求 return fnMiddleware(ctx) .then(handleResponse) .catch((err) => { console.log(\"Somethis is wrong: \", err); }); } 我们看到compose库返回的fn虽然支持第二个参数用来收尾，但是Koa并没有用他，如果不传的话，所有中间件执行完返回的就是一个空的promise，所以可以用then接着他后面处理。后面要进行的处理就只有一个了，就是将处理结果返回给请求者的，这也就是respond需要做的。 app.handleRequest对应的源码看这里:https://github.com/koajs/koa/blob/master/lib/application.js#L162 respond respond是一个辅助方法，并不在Application类里面，他要做的就是将网络请求返回： function respond(ctx) { const res = ctx.res; // 取出res对象 const body = ctx.body; // 取出body return res.end(body); // 用res返回body } 大功告成 现在我们可以用自己写的Koa替换官方的Koa来运行我们开头的例子了，不过logger这个中间件运行的时候会有点问题，因为他下面这行代码用到了语法糖： console.log(`${ctx.method} ${ctx.url} - ${ms}ms`); 这里的ctx.method和ctx.url在我们构建的ctx上并不存在，不过没关系，他不就是个req的语法糖嘛，我们从ctx.req上拿就行，所以上面这行代码改为： console.log(`${ctx.req.method} ${ctx.req.url} - ${ms}ms`); 总结 通过一层一层的抽丝剥茧，我们成功拎出了Koa的代码骨架，自己写了一个迷你版的Koa。 最后我们再来总结下本文的要点吧： Koa是Express原班人马写的一个新框架。 Koa使用了JS的新API，比如async和await。 Koa的架构和Express有很大区别。 Express的思路是大而全，内置了很多功能，比如路由，静态资源等，而且Express的中间件也是使用路由同样的机制实现的，整个代码更复杂。Express源码可以看我之前这篇文章：手写Express.js源码 Koa的思路看起来更清晰，Koa本身的库只是一个内核，只有中间件功能，来的请求会依次经过每一个中间件，然后再出来返回给请求者，这就是大家经常听说的“洋葱模型”。 想要Koa支持其他功能，必须手动添加中间件。作为一个web服务器，路由可以算是基本功能了，所以下一遍文章我们会来看看Koa官方的路由库@koa/router，敬请关注。 参考资料 Koa官方文档：https://github.com/koajs/koa Koa源码地址：https://github.com/koajs/koa/tree/master/lib "},"Articles/Node/KoaRouter.html":{"url":"Articles/Node/KoaRouter.html","title":"手写@koa/router源码","keywords":"","body":"上一篇文章我们讲了Koa的基本架构，可以看到Koa的基本架构只有中间件内核，并没有其他功能，路由功能也没有。要实现路由功能我们必须引入第三方中间件，本文要讲的路由中间件是@koa/router，这个中间件是挂在Koa官方名下的，他跟另一个中间件koa-router名字很像。其实@koa/router是fork的koa-router，因为koa-router的作者很多年没维护了，所以Koa官方将它fork到了自己名下进行维护。这篇文章我们还是老套路，先写一个@koa/router的简单例子，然后自己手写@koa/router源码来替换他。 简单例子 我们这里的例子还是使用之前Express文章中的例子： 访问跟路由返回Hello World get /api/users返回一个用户列表，数据是随便造的 post /api/users写入一个用户信息，用一个文件来模拟数据库 这个例子之前写过几次了，用@koa/router写出来就是这个样子： const fs = require(\"fs\"); const path = require(\"path\"); const Koa = require(\"koa\"); const Router = require(\"@koa/router\"); const bodyParser = require(\"koa-bodyparser\"); const app = new Koa(); const router = new Router(); app.use(bodyParser()); router.get(\"/\", (ctx) => { ctx.body = \"Hello World\"; }); router.get(\"/api/users\", (ctx) => { const resData = [ { id: 1, name: \"小明\", age: 18, }, { id: 2, name: \"小红\", age: 19, }, ]; ctx.body = resData; }); router.post(\"/api/users\", async (ctx) => { // 使用了koa-bodyparser才能从ctx.request拿到body const postData = ctx.request.body; // 使用fs.promises模块下的方法，返回值是promises await fs.promises.appendFile( path.join(__dirname, \"db.txt\"), JSON.stringify(postData) ); ctx.body = postData; }); app.use(router.routes()); const port = 3001; app.listen(port, () => { console.log(`Server is running on http://127.0.0.1:${port}/`); }); 上述代码中需要注意，Koa主要提倡的是promise的用法，所以如果像之前那样使用回调方法可能会导致返回Not Found。比如在post /api/users这个路由中，我们会去写文件，如果我们还是像之前Express那样使用回调函数： fs.appendFile(path.join(__dirname, \"db.txt\"), postData, () => { ctx.body = postData; }); 这会导致这个路由的处理方法并不知道这里需要执行回调，而是直接将外层函数执行完就结束了。而外层函数执行完并没有设置ctx的返回值，所以Koa会默认返回一个Not Found。为了避免这种情况，我们需要让外层函数等待这里执行完，所以我们这里使用fs.promises下面的方法，这下面的方法都会返回promise，我们就可以使用await来等待返回结果了。 手写源码 本文手写源码全部参照官方源码写成，方法名和变量名尽可能与官方代码保持一致，大家可以对照着看，写到具体方法时我也会贴上官方源码地址。手写源码前我们先来看看有哪些API是我们需要解决的： Router类：我们从@koa/router引入的就是这个类，通过new关键字生成一个实例router，后续使用的方法都挂载在这个实例下面。 router.get和router.post：router的实例方法get和post是我们定义路由的方法。 router.routes：这个实例方法的返回值是作为中间件传给app.use的，所以这个方法很可能是生成具体的中间件给Koa调用。 @koa/router的这种使用方法跟我们之前看过的Express.js的路由模块有点像，如果之前看过Express.js源码解析的，看本文应该会有种似曾相识的感觉。 先看看路由架构 Express.js源码解析里面我讲过他的路由架构，本文讲的@koa/router的架构跟他有很多相似之处，但是也有一些改进。在进一步深入@koa/router源码前，我们先来回顾下Express.js的路由架构，这样我们可以有一个整体的认识，可以更好的理解后面的源码。对于我们上面这个例子来说，他有两个API： get /api/users post /api/users 这两个API的path是一样的，都是/api/users，但是他们的method不一样，一个是get，一个是post。Express里面将path这一层提取出来单独作为了一个类----Layer。一个Layer对应一个path，但是同一个path可能对应多个method。所以Layer上还添加了一个属性route，route上也存了一个数组，数组的每个项存了对应的method和回调函数handle。所以整个结构就是这个样子： const router = { stack: [ // 里面很多layer { path: '/api/users' route: { stack: [ // 里面存了多个method和回调函数 { method: 'get', handle: function1 }, { method: 'post', handle: function2 } ] } } ] } 整个路由的执行分为了两部分：注册路由和匹配路由。 注册路由就是构造上面这样一个结构，主要是通过请求动词对应的方法来实现，比如运行router.get('/api/users', function1)其实就会往router上添加一个layer，这个layer的path是/api/users，同时还会在layer.route的数组上添加一个项： { method: 'get', handle: function1 } 匹配路由就是当一个请求来了我们就去遍历router上的所有layer，找出path匹配的layer，再找出layer上method匹配的route，然后将对应的回调函数handle拿出来执行。 @koa/router有着类似的架构，他的代码就是在实现这种架构，先带着这种架构思维，我们可以很容易读懂他的代码。 Router类 首先肯定是Router类，他的构造函数也比较简单，只需要初始化几个属性就行。由于@koa/router模块大量使用了面向对象的思想，如果你对JS的面向对象还不熟悉，可以先看看这篇文章。 module.exports = Router; function Router() { // 支持无new直接调用 if (!(this instanceof Router)) return new Router(); this.stack = []; // 变量名字都跟Express.js的路由模块一样 } 上面代码有一行比较有意思 if (!(this instanceof Router)) return new Router(); 这种使用方法我在其他文章也提到过：支持无new调用。我们知道要实例化一个类，一般要使用new关键字，比如new Router()。但是如果Router构造函数加了这行代码，就可以支持无new调用了，直接Router()可以达到同样的效果。这是因为如果你直接Router()调用，this instanceof Router返回为false，会走到这个if里面去，构造函数会帮你调用一下new Router()。 所以这个构造函数的主要作用就是初始化了一个属性stack，嗯，这个属性名字都跟Express.js路由模块一样。前面的架构已经说了，这个属性就是用来存放layer的。 Router构造函数官方源码:https://github.com/koajs/router/blob/master/lib/router.js#L50 请求动词函数 前面架构讲了，作为一个路由模块，我们主要解决两个问题：注册路由和匹配路由。 先来看看注册路由，注册路由主要是在请求动词函数里面进行的，比如router.get和router.post这种函数。HTTP动词有很多，有一个库专门维护了这些动词：methods。@koa/router也是用的这个库，我们这里就简化下，直接一个将get和post放到一个数组里面吧。 // HTTP动词函数 const methods = [\"get\", \"post\"]; for (let i = 0; i 上面代码直接循环methods数组，将里面的每个值都添加到Router.prototype上成为一个实例方法。这个方法接收path和middleware两个参数，这里的middleware其实就是我们路由的回调函数，因为代码是取的arguments第二个开始到最后所有的参数，所以其实他是支持同时传多个回调函数的。另外官方源码其实是三个参数，还有可选参数name，因为是可选的，跟核心逻辑无关，我这里直接去掉了。 还需要注意这个实例方法最后返回了this，这种操作我们在Koa源码里面也见过，目的是让用户可以连续点点点，比如这样： router.get().post(); 这些实例方法最后其实都是调this.register()去注册路由的，下面我们看看他是怎么写的。 请求动词函数官方源码：https://github.com/koajs/router/blob/master/lib/router.js#L189 router.register() router.register()实例方法是真正注册路由的方法，结合前面架构讲的，注册路由就是构建layer的数据结构可知，router.register()的主要作用就是构建这个数据结构： Router.prototype.register = function (path, methods, middleware) { const stack = this.stack; const route = new Layer(path, methods, middleware); stack.push(route); return route; }; 代码跟预期的一样，就是用path，method和middleware来创建一个layer实例，然后把它塞到stack数组里面去。 router.register官方源码：https://github.com/koajs/router/blob/master/lib/router.js#L553 Layer类 上面代码出现了Layer这个类，我们来看看他的构造函数吧： const { pathToRegexp } = require(\"path-to-regexp\"); module.exports = Layer; function Layer(path, methods, middleware) { // 初始化methods和stack属性 this.methods = []; // 注意这里的stack存放的是我们传入的回调函数 this.stack = Array.isArray(middleware) ? middleware : [middleware]; // 将参数methods一个一个塞进this.methods里面去 for (let i = 0; i 从Layer的构造函数可以看出，他的架构跟Express.js路由模块已经有点区别了。Express.js的Layer上还有Route这个概念。而@koa/router的stack上存的直接是回调函数了，已经没有route这一层了。我个人觉得这种层级结构是比Express的要清晰的，因为Express的route.stack里面存的又是layer，这种相互引用是有点绕的，这点我在Express源码解析中也提出过。 另外我们看到他也用到了path-to-regexp这个库，这个库我在很多处理路由的库里面都见到过，比如React-Router，Express，真想去看看他的源码，加到我的待写文章列表里面去，空了去看看~ Layer构造函数官方源码：https://github.com/koajs/router/blob/master/lib/layer.js#L20 router.routes() 前面架构提到的还有件事情需要做，那就是路由匹配。 对于Koa来说，一个请求来了会依次经过每个中间件，所以我们的路由匹配其实也是在中间件里面做的。而@koa/router的中间件是通过router.routes()返回的。所以router.routes()主要做两件事： 他应该返回一个Koa中间件，以便Koa调用 这个中间件的主要工作是遍历router上的layer，找到匹配的路由，并拿出来执行。 Router.prototype.routes = function () { const router = this; // 这个dispatch就是我们要返回给Koa调用的中间件 let dispatch = function dispatch(ctx, next) { const path = ctx.path; const matched = router.match(path, ctx.method); // 获取所有匹配的layer let layerChain; // 定义一个变量来串联所有匹配的layer ctx.router = router; // 顺手把router挂到ctx上，给其他Koa中间件使用 if (!matched.route) return next(); // 如果一个layer都没匹配上，直接返回，并执行下一个Koa中间件 const matchedLayers = matched.pathAndMethod; // 获取所有path和method都匹配的layer // 下面这段代码的作用是将所有layer上的stack，也就是layer的回调函数都合并到一个数组layerChain里面去 layerChain = matchedLayers.reduce(function (memo, layer) { return memo.concat(layer.stack); }, []); // 这里的compose也是koa-compose这个库，源码在讲Koa源码的时候讲过 // 使用compose将layerChain数组合并成一个可执行的方法，并拿来执行，传入参数是Koa中间件参数ctx, next return compose(layerChain)(ctx, next); }; // 将中间件返回 return dispatch; }; 上述代码中主体返回的是一个Koa中间件，这个中间件里面先是通过router.match方法将所有匹配的layer拿出来，然后将这些layer对应的回调函数通过reduce放到一个数组里面，也就是layerChain。然后用koa-compose将这个数组合并成一个可执行方法，这里就有问题了。之前在Koa源码解析我讲过koa-compose的源码，这里再大致贴一下： function compose(middleware) { // 参数检查，middleware必须是一个数组 if (!Array.isArray(middleware)) throw new TypeError(\"Middleware stack must be an array!\"); // 数组里面的每一项都必须是一个方法 for (const fn of middleware) { if (typeof fn !== \"function\") throw new TypeError(\"Middleware must be composed of functions!\"); } // 返回一个方法，这个方法就是compose的结果 // 外部可以通过调用这个方法来开起中间件数组的遍历 // 参数形式和普通中间件一样，都是context和next return function (context, next) { return dispatch(0); // 开始中间件执行，从数组第一个开始 // 执行中间件的方法 function dispatch(i) { let fn = middleware[i]; // 取出需要执行的中间件 // 如果i等于数组长度，说明数组已经执行完了 if (i === middleware.length) { fn = next; // 这里让fn等于外部传进来的next，其实是进行收尾工作，比如返回404 } // 如果外部没有传收尾的next，直接就resolve if (!fn) { return Promise.resolve(); } // 执行中间件，注意传给中间件接收的参数应该是context和next // 传给中间件的next是dispatch.bind(null, i + 1) // 所以中间件里面调用next的时候其实调用的是dispatch(i + 1)，也就是执行下一个中间件 try { return Promise.resolve(fn(context, dispatch.bind(null, i + 1))); } catch (err) { return Promise.reject(err); } } }; } 这段代码里面fn是我们传入的中间件，在@koa/router这里对应的其实是layerChain里面的一项，执行fn的时候是这样的: fn(context, dispatch.bind(null, i + 1)) 这里传的参数符合我们使用@koa/router的习惯，我们使用@koa/router一般是这样的： router.get(\"/\", (ctx, next) => { ctx.body = \"Hello World\"; }); 上面的fn就是我们传的回调函数，注意我们执行fn时传入的第二个参数dispatch.bind(null, i + 1)，也就是router.get这里的next。所以我们上面回调函数里面再执行下next： router.get(\"/\", (ctx, next) => { ctx.body = \"Hello World\"; next(); // 注意这里 }); 这个回调里面执行next()其实就是把koa-compose里面的dispatch.bind(null, i + 1)拿出来执行，也就是dispatch(i + 1)，对应的就是执行layerChain里面的下一个函数。在这个例子里面并没有什么用，因为匹配的回调函数只有一个。但是如果/这个路径匹配了多个回调函数，比如这样： router.get(\"/\", (ctx, next) => { console.log(\"123\"); }); router.get(\"/\", (ctx, next) => { ctx.body = \"Hello World\"; }); 这里/就匹配了两个回调函数，但是你如果这么写，你会得到一个Not Found。为什么呢？因为你第一个回调里面没有调用next()!前面说了，这里的next()是dispatch(i + 1)，会去调用layerChain里面的下一个回调函数，换一句话说，你这里不调next()就不会运行下一个回调函数了！要想让/返回Hello World，我们需要在第一个回调函数里面调用next，像这样： router.get(\"/\", (ctx, next) => { console.log(\"123\"); next(); // 记得调用next }); router.get(\"/\", (ctx, next) => { ctx.body = \"Hello World\"; }); 所以有朋友觉得@koa/router回调函数里面的next没什么用，如果你一个路由只有一个匹配的回调函数，那确实没什么用，但是如果你一个路径可能匹配多个回调函数，记得调用next。 router.routes官方源码：https://github.com/koajs/router/blob/master/lib/router.js#L335 router.match() 上面router.routes的源码里面我们用到了router.match这个实例方法来查找所有匹配的layer，上面是这么用的： const matched = router.match(path, ctx.method); 所以我们也需要写一下这个函数，这个函数不复杂，通过传入的path和method去router.stack上找到所有匹配的layer就行： Router.prototype.match = function (path, method) { const layers = this.stack; // 取出所有layer let layer; // 构建一个结构来保存匹配结果，最后返回的也是这个matched const matched = { path: [], // path保存仅仅path匹配的layer pathAndMethod: [], // pathAndMethod保存path和method都匹配的layer route: false, // 只要有一个path和method都匹配的layer，就说明这个路由是匹配上的，这个变量置为true }; // 循环layers来进行匹配 for (let i = 0; i 上面代码只是循环了所有的layer，然后将匹配的layer放到一个对象matched里面并返回给外面调用，match.path保存了所有path匹配，但是method并不一定匹配的layer，本文并没有用到这个变量。具体匹配path其实还是调用的layer的实例方法layer.match，我们后面会来看看。 这段代码还有个有意思的点是检测layer.methods里面是否包含method的时候，源码是这样写的： ~layer.methods.indexOf(method) 而一般我们可能是这样写: layer.methods.indexOf(method) > -1 这个源码里面的~是按位取反的意思，达到的效果与我们后面这种写法其实是一样的，因为: ~ -1; // 返回0，也就是false ~ 0; // 返回-1, 注意-1转换为bool是true ~ 1; // 返回-2，转换为bool也是true 这种用法可以少写几个字母，又学会一招，大家具体使用的还是根据自己的情况来吧，选取喜欢的方式。 router.match官方源码：https://github.com/koajs/router/blob/master/lib/router.js#L669 layer.match() 上面用到了layer.match这个方法，我们也来写一下吧。因为我们在创建layer实例的时候，其实已经将path转换为了一个正则，我们直接拿来用就行： Layer.prototype.match = function (path) { return this.regexp.test(path); }; layer.match官方源码：https://github.com/koajs/router/blob/master/lib/layer.js#L54 总结 到这里，我们自己的@koa/router就写完了，使用他替换官方的源码也能正常工作啦~ 最后我们再来总结下本文的要点吧： @koa/router整体是作为一个Koa中间件存在的。 @koa/router是fork的koa-router继续进行维护。 @koa/router的整体思路跟Express.js路由模块很像。 @koa/router也可以分为注册路由和匹配路由两部分。 注册路由主要是构建路由的数据结构，具体来说就是创建很多layer，每个layer上保存具体的path，methods，和回调函数。 @koa/router创建的数据结构跟Express.js路由模块有区别，少了route这个层级，但是个人觉得@koa/router的这种结构反而更清晰。Express.js的layer和route的相互引用反而更让人疑惑。 匹配路由就是去遍历所有的layer，找出匹配的layer，将回调方法拿来执行。 一个路由可能匹配多个layer和回调函数，执行时使用koa-compose将这些匹配的回调函数串起来，一个一个执行。 需要注意的是，如果一个路由匹配了多个回调函数，前面的回调函数必须调用next()才能继续走到下一个回调函数。 参考资料 @koa/router官方文档：https://github.com/koajs/router @koa/router源码地址：https://github.com/koajs/router/tree/master/lib "},"Articles/Node/KoaStatic.html":{"url":"Articles/Node/KoaStatic.html","title":"手写koa-static源码，深入理解静态服务器原理","keywords":"","body":"这篇文章继续前面的Koa源码系列，这个系列已经有两篇文章了： 第一篇讲解了Koa的核心架构和源码：手写Koa.js源码 第二篇讲解了@koa/router的架构和源码：手写@koa/router源码 本文会接着讲一个常用的中间件----koa-static，这个中间件是用来搭建静态服务器的。 其实在我之前使用Node.js原生API写一个web服务器已经讲过怎么返回一个静态文件了，代码虽然比较丑，基本流程还是差不多的： 通过请求路径取出正确的文件地址 通过地址获取对应的文件 使用Node.js的API返回对应的文件，并设置相应的header koa-static的代码更通用，更优雅，而且对大文件有更好的支持，下面我们来看看他是怎么做的吧。本文还是采用一贯套路，先看一下他的基本用法，然后从基本用法入手去读源码，并手写一个简化版的源码来替换他。 基本用法 koa-static使用很简单，主要代码就一行： const Koa = require('koa'); const serve = require('koa-static'); const app = new Koa(); // 主要就是这行代码 app.use(serve('public')); app.listen(3001, () => { console.log('listening on port 3001'); }); 上述代码中的serve就是koa-static，他运行后会返回一个Koa中间件，然后Koa的实例直接引用这个中间件就行了。 serve方法支持两个参数，第一个是静态文件的目录，第二个参数是一些配置项，可以不传。像上面的代码serve('public')就表示public文件夹下面的文件都可以被外部访问。比如我在里面放了一张图片: 跑起来就是这样子： 注意上面这个路径请求的是/test.jpg，前面并没有public，说明koa-static对请求路径进行了判断，发现是文件就映射到服务器的public目录下面，这样可以防止外部使用者探知服务器目录结构。 手写源码 返回的是一个Koa中间件 我们看到koa-static导出的是一个方法serve，这个方法运行后返回的应该是一个Koa中间件，这样Koa才能引用他，所以我们先来写一下这个结构吧： module.exports = serve; // 导出的是serve方法 // serve接受两个参数 // 第一个参数是路径地址 // 第二个是配置选项 function serve(root, opts) { // 返回一个方法，这个方法符合koa中间件的定义 return async function serve(ctx, next) { await next(); } } 调用koa-send返回文件 现在这个中间件是空的，其实他应该做的是将文件返回，返回文件的功能也被单独抽取出来成了一个库----koa-send，我们后面会看他源码，这里先直接用吧。 function serve(root, opts) { // 这行代码如果效果就是 // 如果没传opts，opts就是空对象{} // 同时将它的原型置为null opts = Object.assign(Object.create(null), opts); // 将root解析为一个合法路径，并放到opts上去 // 因为koa-send接收的路径是在opts上 opts.root = resolve(root); // 这个是用来兼容文件夹的，如果请求路径是一个文件夹，默认去取index // 如果用户没有配置index，默认index就是index.html if (opts.index !== false) opts.index = opts.index || 'index.html'; // 整个serve方法的返回值是一个koa中间件 // 符合koa中间件的范式： (ctx, next) => {} return async function serve(ctx, next) { let done = false; // 这个变量标记文件是否成功返回 // 只有HEAD和GET请求才响应 if (ctx.method === 'HEAD' || ctx.method === 'GET') { try { // 调用koa-send发送文件 // 如果发送成功，koa-send会返回路径，赋值给done // done转换为bool值就是true done = await send(ctx, ctx.path, opts); } catch (err) { // 如果不是404，可能是一些400，500这种非预期的错误，将它抛出去 if (err.status !== 404) { throw err } } } // 通过done来检测文件是否发送成功 // 如果没成功，就让后续中间件继续处理他 // 如果成功了，本次请求就到此为止了 if (!done) { await next() } } } opt.defer defer是配置选项opt里面的一个可选参数，他稍微特殊一点，默认为false，如果你传了true，koa-static会让其他中间件先响应，即使其他中间件写在koa-static后面也会让他先响应，自己最后响应。要实现这个，其实就是控制调用next()的时机。在讲Koa源码的文章里面已经讲过了，调用next()其实就是在调用后面的中间件，所以像上面代码那样最后调用next()，就是先执行koa-static然后再执行其他中间件。如果你给defer传了true，其实就是先执行next()，然后再执行koa-static的逻辑，按照这个思路我们来支持下defer吧： function serve(root, opts) { opts = Object.assign(Object.create(null), opts); opts.root = resolve(root); // 如果defer为false，就用之前的逻辑，最后调用next if (!opts.defer) { return async function serve(ctx, next) { let done = false; if (ctx.method === 'HEAD' || ctx.method === 'GET') { try { done = await send(ctx, ctx.path, opts); } catch (err) { if (err.status !== 404) { throw err } } } if (!done) { await next() } } } // 如果defer为true，先调用next，然后执行自己的逻辑 return async function serve(ctx, next) { // 先调用next,执行后面的中间件 await next(); if (ctx.method !== 'HEAD' && ctx.method !== 'GET') return // 如果ctx.body有值了，或者status不是404，说明请求已经被其他中间件处理过了，就直接返回了 if (ctx.body != null || ctx.status !== 404) return // eslint-disable-line // koa-static自己的逻辑还是一样的，都是调用koa-send try { await send(ctx, ctx.path, opts) } catch (err) { if (err.status !== 404) { throw err } } } } koa-static源码总共就几十行：https://github.com/koajs/static/blob/master/index.js koa-send 上面我们看到koa-static其实是包装的koa-send，真正发送文件的操作都是在koa-send里面的。文章最开头说的几件事情koa-static一件也没干，都丢给koa-send了，也就是说他应该把这几件事都干完： 通过请求路径取出正确的文件地址 通过地址获取对应的文件 使用Node.js的API返回对应的文件，并设置相应的header 由于koa-send代码也不多，我就直接在代码中写注释了，通过前面的使用，我们已经知道他的使用形式是： send (ctx, path, opts) 他接收三个参数： ctx：就是koa的那个上下文ctx。 path：koa-static传过来的是ctx.path，看过koa源码解析的应该知道，这个值其实就是req.path opts: 一些配置项，defer前面讲过了，会影响执行顺序，其他还有些缓存控制什么的。 下面直接来写一个send方法吧： const fs = require('fs') const fsPromises = fs.promises; const { stat, access } = fsPromises; const { normalize, basename, extname, resolve, parse, sep } = require('path') const resolvePath = require('resolve-path') // 导出send方法 module.exports = send; // send方法的实现 async function send(ctx, path, opts = {}) { // 先解析配置项 const root = opts.root ? normalize(resolve(opts.root)) : ''; // 这里的root就是我们配置的静态文件目录，比如public const index = opts.index; // 请求文件夹时，会去读取这个index文件 const maxage = opts.maxage || opts.maxAge || 0; // 就是http缓存控制Cache-Control的那个maxage const immutable = opts.immutable || false; // 也是Cache-Control缓存控制的 const format = opts.format !== false; // format默认是true，用来支持/directory这种不带/的文件夹请求 const trailingSlash = path[path.length - 1] === '/'; // 看看path结尾是不是/ path = path.substr(parse(path).root.length) // 去掉path开头的/ path = decode(path); // 其实就是decodeURIComponent， decode辅助方法在后面 if (path === -1) return ctx.throw(400, 'failed to decode'); // 如果请求以/结尾，肯定是一个文件夹，将path改为文件夹下面的默认文件 if (index && trailingSlash) path += index; // resolvePath可以将一个根路径和请求的相对路径合并成一个绝对路径 // 并且防止一些常见的攻击，比如GET /../file.js // GitHub地址：https://github.com/pillarjs/resolve-path path = resolvePath(root, path) // 用fs.stat获取文件的基本信息，顺便检测下文件存在不 let stats; try { stats = await stat(path) // 如果是文件夹，并且format为true，拼上index文件 if (stats.isDirectory()) { if (format && index) { path += `/${index}` stats = await stat(path) } else { return } } } catch (err) { // 错误处理，如果是文件不存在，返回404，否则返回500 const notfound = ['ENOENT', 'ENAMETOOLONG', 'ENOTDIR'] if (notfound.includes(err.code)) { // createError来自http-errors库，可以快速创建HTTP错误对象 // github地址：https://github.com/jshttp/http-errors throw createError(404, err) } err.status = 500 throw err } // 设置Content-Length的header ctx.set('Content-Length', stats.size) // 设置缓存控制header if (!ctx.response.get('Last-Modified')) ctx.set('Last-Modified', stats.mtime.toUTCString()) if (!ctx.response.get('Cache-Control')) { const directives = [`max-age=${(maxage / 1000 | 0)}`] if (immutable) { directives.push('immutable') } ctx.set('Cache-Control', directives.join(',')) } // 设置返回类型和返回内容 if (!ctx.type) ctx.type = extname(path) ctx.body = fs.createReadStream(path) return path } function decode(path) { try { return decodeURIComponent(path) } catch (err) { return -1 } } 上述代码并没有太复杂的逻辑，先拼一个完整的地址，然后使用fs.stat获取文件的基本信息，如果文件不存在，这个API就报错了，直接返回404。如果文件存在，就用fs.stat拿到的信息设置Content-Length和一些缓存控制的header。 koa-send的源码也只有一个文件，百来行代码:https://github.com/koajs/send/blob/master/index.js ctx.type和ctx.body 上述代码我们看到最后并没有直接返回文件，而只是设置了ctx.type和ctx.body这两个值就结束了，为啥设置了这两个值，文件就自动返回了呢？要知道这个原理，我们要结合Koa源码来看。 之前讲Koa源码的时候我提到过，他扩展了Node原生的res，并且在里面给type属性添加了一个set方法： set type(type) { type = getType(type); if (type) { this.set('Content-Type', type); } else { this.remove('Content-Type'); } } 这段代码的作用是当你给ctx.type设置值的时候，会自动给Content-Type设置值，getType其实是另一个第三方库cache-content-type，他可以根据你传入的文件类型，返回匹配的MIME type。我刚看koa-static源码时，找了半天也没找到在哪里设置的Content-Type，后面发现是在Koa源码里面。所以设置了ctx.type其实就是设置了Content-Type。 koa扩展的type属性看这里：https://github.com/koajs/koa/blob/master/lib/response.js#L308 之前讲Koa源码的时候我还提到过，当所有中间件都运行完了，最后会运行一个方法respond来返回结果，在那篇文章里面，respond是简化版的，直接用res.end返回了结果： function respond(ctx) { const res = ctx.res; // 取出res对象 const body = ctx.body; // 取出body return res.end(body); // 用res返回body } 直接用res.end返回结果只能对一些简单的小对象比较合适，比如字符串什么的。对于复杂对象，比如文件，这个就不合适了，因为你如果要用res.write或者res.end返回文件，你需要先把文件整个读入内存，然后作为参数传递，如果文件很大，服务器内存可能就爆了。那要怎么处理呢？回到koa-send源码里面，我们给ctx.body设置的值其实是一个可读流: ctx.body = fs.createReadStream(path) 这种流怎么返回呢？其实Node.js对于返回流本身就有很好的支持。要返回一个值，需要用到http回调函数里面的res，这个res本身其实也是一个流。大家可以再翻翻Node.js官方文档，这里的res其实是http.ServerResponse类的一个实例，而http.ServerResponse本身又继承自Stream类： 所以res本身就是一个流Stream，那Stream的API就可以用了。ctx.body是使用fs.createReadStream创建的，所以他是一个可读流，可读流有一个很方便的API可以直接让内容流动到可写流：readable.pipe，使用这个API，Node.js会自动将可读流里面的内容推送到可写流，数据流会被自动管理，所以即使可读流更快，目标可写流也不会超负荷，而且即使你文件很大，因为不是一次读入内存，而是流式读入，所以也不会爆。所以我们在Koa的respond里面支持下流式body就行了: function respond(ctx) { const res = ctx.res; const body = ctx.body; // 如果body是个流，直接用pipe将它绑定到res上 if (body instanceof Stream) return body.pipe(res); return res.end(body); } Koa源码对于流的处理看这里：https://github.com/koajs/koa/blob/master/lib/application.js#L267 总结 现在，我们可以用自己写的koa-static来替换官方的了，运行效果是一样的。最后我们再来回顾下本文的要点： 本文是Koa常用静态服务中间件koa-static的源码解析。 由于是一个Koa的中间件，所以koa-static的返回值是一个方法，而且需要符合中间件范式: (ctx, next) => {} 作为一个静态服务中间件，koa-static本应该完成以下几件事情： 通过请求路径取出正确的文件地址 通过地址获取对应的文件 使用Node.js的API返回对应的文件，并设置相应的header 但是这几件事情他一件也没干，都扔给koa-send了，所以他官方文档也说了他只是wrapper for koa-send. 作为一个wrapper他还支持了一个比较特殊的配置项opt.defer，这个配置项可以控制他在所有Koa中间件里面的执行时机，其实就是调用next的时机。如果你给这个参数传了true，他就先调用next，让其他中间件先执行，自己最后执行，反之亦然。有了这个参数，你可以将/test.jpg这种请求先作为普通路由处理，路由没匹配上再尝试静态文件，这在某些场景下很有用。 koa-send才是真正处理静态文件，他把前面说的三件事全干了，在拼接文件路径时还使用了resolvePath来防御常见攻击。 koa-send取文件时使用了fs模块的API创建了一个可读流，并将它赋值给ctx.body，同时设置了ctx.type。 通过ctx.type和ctx.body返回给请求者并不是koa-send的功能，而是Koa本身的功能。由于http模块提供和的res本身就是一个可写流，所以我们可以通过可读流的pipe函数直接将ctx.body绑定到res上，剩下的工作Node.js会自动帮我们完成。 使用流(Stream)来读写文件有以下几个优点： 不用一次性将文件读入内存，暂用内存小。 如果文件很大，一次性读完整个文件，可能耗时较长。使用流，可以一点一点读文件，读到一点就可以返回给response，有更快的响应时间。 Node.js可以在可读流和可写流之间使用管道进行数据传输，使用也很方便。 参考资料： koa-static文档：https://github.com/koajs/static koa-static源码：https://github.com/koajs/static/blob/master/index.js koa-send文档：https://github.com/koajs/send koa-send源码：https://github.com/koajs/send/blob/master/index.js "},"Articles/DesignPatterns/DesignPatterns.html":{"url":"Articles/DesignPatterns/DesignPatterns.html","title":"设计模式","keywords":"","body":"本章节包括如下内容： 从发布订阅模式入手读懂Node.js的EventEmitter源码 封装代码的设计模式：工厂，建造者，单例，原型 提高复用性的设计模式：桥接，享元，模板方法 提高扩展性的设计模式：职责链，观察者，装饰器，适配器，命令，访问者 提高代码质量的设计模式：策略/状态，外观，迭代器，备忘录 "},"Articles/DesignPatterns/PubSub.html":{"url":"Articles/DesignPatterns/PubSub.html","title":"从发布订阅模式入手读懂Node.js的EventEmitter源码","keywords":"","body":"前面一篇文章setTimeout和setImmediate到底谁先执行，本文让你彻底理解Event Loop详细讲解了浏览器和Node.js的异步API及其底层原理Event Loop。本文会讲一下不用原生API怎么达到异步的效果，也就是发布订阅模式。发布订阅模式在面试中也是高频考点，本文会自己实现一个发布订阅模式，弄懂了他的原理后，我们就可以去读Node.js的EventEmitter源码，这也是一个典型的发布订阅模式。 为什么要用发布订阅模式 在没有Promise之前，我们使用异步API的时候经常会使用回调，但是如果有几个互相依赖的异步API调用，回调层级太多可能就会陷入“回调地狱”。下面代码演示了假如我们有三个网络请求，第二个必须等第一个结束才能发出，第三个必须等第二个结束才能发起，如果我们使用回调就会变成这样： const request = require(\"request\"); request('https://www.baidu.com', function (error, response) { if (!error && response.statusCode == 200) { console.log('get times 1'); request('https://www.baidu.com', function(error, response) { if (!error && response.statusCode == 200) { console.log('get times 2'); request('https://www.baidu.com', function(error, response) { if (!error && response.statusCode == 200) { console.log('get times 3'); } }) } }) } }); 由于浏览器端ajax会有跨域问题，上述例子我是用Node.js运行的。这个例子里面有三层回调，我们已经有点晕了，如果再多几层，那真的就是“地狱”了。 发布订阅模式 发布订阅模式是一种设计模式，并不仅仅用于JS中，这种模式可以帮助我们解开“回调地狱”。他的流程如下图所示： 消息中心：负责存储消息与订阅者的对应关系，有消息触发时，负责通知订阅者 订阅者：去消息中心订阅自己感兴趣的消息 发布者：满足条件时，通过消息中心发布消息 有了这种模式，前面处理几个相互依赖的异步API就不用陷入\"回调地狱\"了，只需要让后面的订阅前面的成功消息，前面的成功后发布消息就行了。 自己实现一个发布订阅模式 知道了原理，我们自己来实现一个发布订阅模式，这次我们使用ES6的class来实现，如果你对JS的面向对象或者ES6的class还不熟悉，请看这篇文章: class PubSub { constructor() { // 一个对象存放所有的消息订阅 // 每个消息对应一个数组，数组结构如下 // { // \"event1\": [cb1, cb2] // } this.events = {} } subscribe(event, callback) { if(this.events[event]) { // 如果有人订阅过了，这个键已经存在，就往里面加就好了 this.events[event].push(callback); } else { // 没人订阅过，就建一个数组，回调放进去 this.events[event] = [callback] } } publish(event, ...args) { // 取出所有订阅者的回调执行 const subscribedEvents = this.events[event]; if(subscribedEvents && subscribedEvents.length) { subscribedEvents.forEach(callback => { callback.call(this, ...args); }); } } unsubscribe(event, callback) { // 删除某个订阅，保留其他订阅 const subscribedEvents = this.events[event]; if(subscribedEvents && subscribedEvents.length) { this.events[event] = this.events[event].filter(cb => cb !== callback) } } } 解决回调地狱 有了我们自己的PubSub，我们就可以用它来解决前面的毁掉地狱问题了: const request = require(\"request\"); const pubSub = new PubSub(); request('https://www.baidu.com', function (error, response) { if (!error && response.statusCode == 200) { console.log('get times 1'); // 发布请求1成功消息 pubSub.publish('request1Success'); } }); // 订阅请求1成功的消息，然后发起请求2 pubSub.subscribe('request1Success', () => { request('https://www.baidu.com', function (error, response) { if (!error && response.statusCode == 200) { console.log('get times 2'); // 发布请求2成功消息 pubSub.publish('request2Success'); } }); }) // 订阅请求2成功的消息，然后发起请求3 pubSub.subscribe('request2Success', () => { request('https://www.baidu.com', function (error, response) { if (!error && response.statusCode == 200) { console.log('get times 3'); // 发布请求3成功消息 pubSub.publish('request3Success'); } }); }) Node.js的EventEmitter Node.js的EventEmitter思想跟我们前面的例子是一样的，不过他有更多的错误处理和更多的API，源码在GitHub上都有：https://github.com/nodejs/node/blob/master/lib/events.js。我们挑几个API看一下： 构造函数 代码传送门: https://github.com/nodejs/node/blob/master/lib/events.js#L64 构造函数很简单，就一行代码，主要逻辑都在EventEmitter.init里面: EventEmitter.init里面也是做了一些初始化的工作，this._events跟我们自己写的this.events功能是一样的，用来存储订阅的事件。核心代码我在图上用箭头标出来了。这里需要注意一点，如果一个类型的事件只有一个订阅,this._events就直接是那个函数了，而不是一个数组，在源码里面我们会多次看到对这个进行判断，这样写是为了提高性能。 订阅事件 代码传送门: https://github.com/nodejs/node/blob/master/lib/events.js#L405 EventEmitter订阅事件的API是on和addListener，从源码中我们可以看出这两个方法是完全一样的： 这两个方法都是调用了_addListener，这个方法对参数进行了判断和错误处理，核心代码仍然是往this._events里面添加事件: 发布事件 代码传送门：https://github.com/nodejs/node/blob/master/lib/events.js#L263 EventEmitter发布事件的API是emit，这个API里面会对\"error\"类型的事件进行特殊处理，也就是抛出错误： 如果不是错误类型的事件，就把订阅的回调事件拿出来执行: 取消订阅 代码传送门：https://github.com/nodejs/node/blob/master/lib/events.js#L450 EventEmitter里面取消订阅的API是removeListener和off，这两个是完全一样的。EventEmitter的取消订阅API不仅仅会删除对应的订阅，在删除后还会emit一个removeListener事件来通知外界。这里也会对this._events里面对应的type进行判断，如果只有一个，也就是说这个type的类型是function，会直接删除这个键，如果有多个订阅，就会找出这个订阅，然后删掉他。如果所有订阅都删完了，就直接将this._events置空： 观察者模式 这里再提一个很相似的设计模式：观察者模式，有些文章认为他和发布订阅模式是一样的，有些认为他们是有区别的。笔者认为他更像一个低配版的发布订阅模式，我们来实现一个看看： class Subject { constructor() { // 一个数组存放所有的订阅者 // 每个消息对应一个数组，数组结构如下 // [ // { // observer: obj, // action: () => {} // } // ] this.observers = []; } addObserver(observer, action) { // 将观察者和回调放入数组 this.observers.push({observer, action}); } notify(...args) { // 执行每个观察者的回调 this.observers.forEach(item => { const {observer, action} = item; action.call(observer, ...args); }) } } const subject = new Subject(); // 添加一个观察者 subject.addObserver({name: 'John'}, function(msg){ console.log(this.name, 'got message: ', msg); }) // 再添加一个观察者 subject.addObserver({name: 'Joe'}, function(msg) { console.log(this.name, 'got message: ', msg); }) // 通知所有观察者 subject.notify('tomorrow is Sunday'); 上述代码的输出是： 通过这个输出可以看出一旦调了通知的方法notify，所有观察者都会收到通知，而且会收到同样的信息。而发布订阅模式还可以自定义需要接受的通知，所以说观察者模式是低配版的发布订阅模式。 总结 本文讲解了发布订阅模式的原理，并自己实现了一个简单的发布订阅模式。在了解了原理后，还去读了Node.js的EventEmitter模块的源码，进一步学习了生产环境的发布订阅模式的写法。总结下来发布订阅模式有以下特点： 解决了“回调地狱” 将多个模块进行了解耦，自己执行时，不需要知道另一个模块的存在，只需要关心发布出来的事件就行 因为多个模块可以不知道对方的存在，自己关心的事件可能是一个很遥远的旮旯发布出来的，也不能通过代码跳转直接找到发布事件的地方，debug的时候可能会有点困难。 观察者模式是低配版的发布订阅模式，一旦发布通知，所有观察者都会收到消息，不能做到发布订阅那样精细的控制。 "},"Articles/DesignPatterns/Encapsulate.html":{"url":"Articles/DesignPatterns/Encapsulate.html","title":"封装代码的设计模式：工厂，建造者，单例，原型","keywords":"","body":"为什么要封装代码？ 我们经常听说：“写代码要有良好的封装，要高内聚，低耦合”。那怎样才算良好的封装，我们为什么要封装呢？其实封装有这样几个好处： 封装好的代码，内部变量不会污染外部。 可以作为一个模块给外部调用。外部调用者不需要知道实现的细节，只需要按照约定的规范使用就行了。 对扩展开放，对修改关闭，即开闭原则。外部不能修改模块，既保证了模块内部的正确性，又可以留出扩展接口，使用灵活。 怎么封装代码？ JS生态已经有很多模块了，有些模块封装得非常好，我们使用起来很方便，比如jQuery，Vue等。如果我们仔细去看这些模块的源码，我们会发现他们的封装都是有规律可循的。这些规律总结起来就是设计模式，用于代码封装的设计模式主要有工厂模式，创建者模式，单例模式，原型模式四种。下面我们结合一些框架源码来看看这四种设计模式： 工厂模式 工厂模式的名字就很直白，封装的模块就像一个工厂一样批量的产出需要的对象。常见工厂模式的一个特征就是调用的时候不需要使用new，而且传入的参数比较简单。但是调用次数可能比较频繁，经常需要产出不同的对象，频繁调用时不用new也方便很多。一个工厂模式的代码结构如下所示: function factory(type) { switch(type) { case 'type1': return new Type1(); case 'type2': return new Type2(); case 'type3': return new Type3(); } } 上述代码中，我们传入了type，然后工厂根据不同的type来创建不同的对象。 实例: 弹窗组件 下面来看看用工厂模式的例子，假如我们有如下需求： 我们项目需要一个弹窗，弹窗有几种：消息型弹窗，确认型弹窗，取消型弹窗，他们的颜色和内容可能是不一样的。 针对这几种弹窗，我们先来分别建一个类： function infoPopup(content, color) {} function confirmPopup(content, color) {} function cancelPopup(content, color) {} 如果我们直接使用这几个类，就是这样的: let infoPopup1 = new infoPopup(content, color); let infoPopup2 = new infoPopup(content, color); let confirmPopup1 = new confirmPopup(content, color); ... 每次用的时候都要去new对应的弹窗类，我们用工厂模式改造下，就是这样： // 新加一个方法popup把这几个类都包装起来 function popup(type, content, color) { switch(type) { case 'infoPopup': return new infoPopup(content, color); case 'confirmPopup': return new confirmPopup(content, color); case 'cancelPopup': return new cancelPopup(content, color); } } 然后我们使用popup就不用new了，直接调用函数就行: let infoPopup1 = popup('infoPopup', content, color); 改造成面向对象 上述代码虽然实现了工厂模式，但是switch始终感觉不是很优雅。我们使用面向对象改造下popup，将它改为一个类，将不同类型的弹窗挂载在这个类上成为工厂方法： function popup(type, content, color) { // 如果是通过new调用的，返回对应类型的弹窗 if(this instanceof popup) { return new this[type](content, color); } else { // 如果不是new调用的，使用new调用，会走到上面那行代码 return new popup(type, content, color); } } // 各种类型的弹窗全部挂载在原型上成为实例方法 popup.prototype.infoPopup = function(content, color) {} popup.prototype.confirmPopup = function(content, color) {} popup.prototype.cancelPopup = function(content, color) {} 封装成模块 这个popup不仅仅让我们调用的时候少了一个new，他其实还把相关的各种弹窗都封装在了里面，这个popup可以直接作为模块export出去给别人调用，也可以挂载在window上作为一个模块给别人调用。因为popup封装了弹窗的各种细节，即使以后popup内部改了，或者新增了弹窗类型，或者弹窗类的名字变了，只要保证对外的接口参数不变，对外面都没有影响。挂载在window上作为模块可以使用自执行函数： (function(){ function popup(type, content, color) { if(this instanceof popup) { return new this[type](content, color); } else { return new popup(type, content, color); } } popup.prototype.infoPopup = function(content, color) {} popup.prototype.confirmPopup = function(content, color) {} popup.prototype.cancelPopup = function(content, color) {} window.popup = popup; })() // 外面就直接可以使用popup模块了 let infoPopup1 = popup('infoPopup', content, color); jQuery的工厂模式 jQuery也是一个典型的工厂模式，你给他一个参数，他就给你返回符合参数DOM对象。那jQuery这种不用new的工厂模式是怎么实现的呢？其实就是jQuery内部帮你调用了new而已，jQuery的调用流程简化了就是这样: (function(){ var jQuery = function(selector) { return new jQuery.fn.init(selector); // new一下init, init才是真正的构造函数 } jQuery.fn = jQuery.prototype; // jQuery.fn就是jQuery.prototype的简写 jQuery.fn.init = function(selector) { // 这里面实现真正的构造函数 } // 让init和jQuery的原型指向同一个对象，便于挂载实例方法 jQuery.fn.init.prototype = jQuery.fn; // 最后将jQuery挂载到window上 window.$ = window.jQuery = jQuery; })(); 上述代码结构来自于jQuery源码，从中可以看出，你调用时省略的new在jQuery里面帮你调用了，目的是为了使大量调用更方便。但是这种结构需要借助一个init方法，最后还要将jQuery和init的原型绑在一起，其实还有一种更加简便的方法可以实现这个需求: var jQuery = function(selector) { if(!(this instanceof jQuery)) { return new jQuery(selector); } // 下面进行真正构造函数的执行 } 上述代码就简洁多了，也可以实现不用new直接调用，这里利用的特性是this在函数被new调用时，指向的是new出来的对象，new出来的对象自然是类的instance，这里的this instanceof jQuery就是true。如果是普通调用，他就是false，我们就帮他new一下。 建造者模式 建造者模式是用于比较复杂的大对象的构建，比如Vue，Vue内部包含一个功能强大，逻辑复杂的对象，在构建的时候也需要传很多参数进去。像这种需要创建的情况不多，创建的对象本身又很复杂的时候就适用建造者模式。建造者模式的一般结构如下： function Model1() {} // 模块1 function Model2() {} // 模块2 // 最终使用的类 function Final() { this.model1 = new Model1(); this.model2 = new Model2(); } // 使用时 var obj = new Final(); 上述代码中我们最终使用的是Final，但是Final里面的结构比较复杂，有很多个子模块，Final就是将这些子模块组合起来完成功能，这种需要精细化构造的就适用于建造者模式。 实例：编辑器插件 假设我们有这样一个需求： 写一个编辑器插件，初始化的时候需要配置大量参数，而且内部的功能很多很复杂，可以改变字体颜色和大小，也可以前进后退。 一般一个页面就只有一个编辑器，而且里面的功能可能很复杂，可能需要调整颜色，字体等。也就是说这个插件内部可能还会调用其他类，然后将他们组合起来实现功能，这就适合建造者模式。我们来分析下做这样一个编辑器需要哪些模块: 编辑器本身肯定需要一个类，是给外部调用的接口 需要一个控制参数初始化和页面渲染的类 需要一个控制字体的类 需要一个状态管理的类 // 编辑器本身，对外暴露 function Editor() { // 编辑器里面就是将各个模块组合起来实现功能 this.initer = new HtmlInit(); this.fontController = new FontController(); this.stateController = new StateController(this.fontController); } // 初始化参数，渲染页面 function HtmlInit() { } HtmlInit.prototype.initStyle = function() {} // 初始化样式 HtmlInit.prototype.renderDom = function() {} // 渲染DOM // 字体控制器 function FontController() { } FontController.prototype.changeFontColor = function() {} // 改变字体颜色 FontController.prototype.changeFontSize = function() {} // 改变字体大小 // 状态控制器 function StateController(fontController) { this.states = []; // 一个数组，存储所有状态 this.currentState = 0; // 一个指针，指向当前状态 this.fontController = fontController; // 将字体管理器注入，便于改变状态的时候改变字体 } StateController.prototype.saveState = function() {} // 保存状态 StateController.prototype.backState = function() {} // 后退状态 StateController.prototype.forwardState = function() {} // 前进状态 上面的代码其实就将一个编辑器插件的架子搭起来了，具体实现功能就是往这些方法里面填入具体的内容就行了，其实就是各个模块的相互调用，比如我们要实现后退状态的功能就可以这样写: StateController.prototype.backState = function() { var state = this.states[this.currentState - 1]; // 取出上一个状态 this.fontController.changeFontColor(state.color); // 改回上次颜色 this.fontController.changeFontSize(state.size); // 改回上次大小 } 单例模式 单例模式适用于全局只能有一个实例对象的场景，单例模式的一般结构如下： function Singleton() {} Singleton.getInstance = function() { if(this.instance) { return this.instance; } this.instance = new Singleton(); return this.instance; } 上述代码中，Singleton类挂载了一个静态方法getInstance，如果要获取实例对象只能通过这个方法拿，这个方法会检测是不是有现存的实例对象，如果有就返回，没有就新建一个。 实例：全局数据存储对象 假如我们现在有这样一个需求: 我们需要对一个全局的数据对象进行管理，这个对象只能有一个，如果有多个会导致数据不同步。 这个需求要求全局只有一个数据存储对象，是典型的适合单例模式的场景，我们可以直接套用上面的代码模板，但是上面的代码模板获取instance必须要调getInstance才行，要是某个使用者直接调了Singleton()或者new Singleton()就会出问题，这次我们换一种写法，让他能够兼容Singleton()和new Singleton()，使用起来更加傻瓜化: function store() { if(store.instance) { return store.instance; } store.instance = this; } 上述代码支持使用new store()的方式调用，我们使用了一个静态变量instance来记录是否有进行过实例化，如果实例化了就返回这个实例，如果没有实例化说明是第一次调用，那就把this赋给这个这个静态变量，因为是使用new调用，这时候的this指向的就是实例化出来的对象，并且最后会隐式的返回this。 如果我们还想支持store()直接调用，我们可以用前面工厂模式用过的方法，检测this是不是当前类的实例，如果不是就帮他用new调用就行了： function store() { // 加一个instanceof检测 if(!(this instanceof store)) { return new store(); } // 下面跟前面一样的 if(store.instance) { return store.instance; } store.instance = this; } 然后我们用两种方式调用来检测下: 实例：vue-router vue-router其实也用到了单例模式，因为如果一个页面有多个路由对象，可能造成状态的冲突，vue-router的单例实现方式又有点不一样，下列代码来自vue-router源码： let _Vue; function install(Vue) { if (install.installed && _Vue === Vue) return; install.installed = true _Vue = Vue } 每次我们调用vue.use(vueRouter)的时候其实都会去执行vue-router模块的install方法，如果用户不小心多次调用了vue.use(vueRouter)就会造成install的多次执行，从而产生不对的结果。vue-router的install在第一次执行时，将installed属性写成了true，并且记录了当前的Vue，这样后面在同一个Vue里面再次执行install就会直接return了，这也是一种单例模式。 可以看到我们这里三种代码都是单例模式，他们虽然形式不一样，但是核心思想都是一样的，都是用一个变量来标记代码是否已经执行过了，如果执行过了就返回上次的执行结果，这样就保证了多次调用也会拿到一样的结果。 原型模式 原型模式最典型的应用就是JS本身啊，JS的原型链就是原型模式。JS中可以使用Object.create指定一个对象作为原型来创建对象: const obj = { x: 1, func: () => {} } // 以obj为原型创建一个新对象 const newObj = Object.create(obj); console.log(newObj.__proto__ === obj); // true console.log(newObj.x); // 1 上述代码我们将obj作为原型，然后用Object.create创建的新对象都会拥有这个对象上的属性和方法，这其实就算是一种原型模式。还有JS的面向对象其实更加是这种模式的体现，比如JS的继承可以这样写: function Parent() { this.parentAge = 50; } function Child() {} Child.prototype = new Parent(); Child.prototype.constructor = Child; // 注意重置constructor const obj = new Child(); console.log(obj.parentAge); // 50 这里的继承其实就是让子类Child.prototype.__proto__的指向父类的prototype，从而获取父类的方法和属性。JS中面向对象的内容较多，我这里不展开了，有一篇文章专门讲这个问题。 总结 很多用起来顺手的开源库都有良好的封装，封装可以将内部环境和外部环境隔离，外部用起来更顺手。 针对不同的场景可以有不同的封装方案。 需要大量产生类似实例的组件可以考虑用工厂模式来封装。 内部逻辑较复杂，外部使用时需要的实例也不多，可以考虑用建造者模式来封装。 全局只能有一个实例的需要用单例模式来封装。 新老对象之间可能有继承关系的可以考虑用原型模式来封装，JS本身就是一个典型的原型模式。 使用设计模式时不要生搬硬套代码模板，更重要的是掌握思想，同一个模式在不同的场景可以有不同的实现方案。 "},"Articles/DesignPatterns/Reusability.html":{"url":"Articles/DesignPatterns/Reusability.html","title":"提高复用性的设计模式：桥接，享元，模板方法","keywords":"","body":"本文是设计模式的第二篇文章，第一篇文章是不知道怎么封装代码？看看这几种设计模式吧！，后面还会有提高扩展性，提高代码质量的设计模式，点个关注不迷路，哈哈~ 想必大家都听说过DRY原则，其实就是Don't repeat yourself(不要重复你自己)，意思就是不要重复写一样的代码，换句话说就是要提高代码的复用性。那什么样的代码才算有好的复用性呢？ 对象可以重复利用。这个其实有点像我们关系型数据库的设计原则，数据表和关系表是分开的，数据表就是单纯的数据，没有跟其他表的关系，也没有业务逻辑，关系表才是存储具体的对应关系。当我们需要某个数据时，直接读这个表就行，而不用担心这个表会有其他的业务在里面。类似设计的还有redux，redux的store里面就是单纯的数据，并不对应具体的业务逻辑，业务如果需要改变数据需要发action才行。正是因为这种数据很单纯，所以我们需要的地方都可以拿来用，复用性非常高。所以我们设计数据或对象时，也要尽量让他可以复用。 重复代码少。如果你写的代码重复度很高的话，说明你代码的抽象度不够。很多时候我们重复代码的产生都是因为我们可能需要写一个跟已经存在的功能类似的功能，于是我们就把之前的代码拷贝过来，把其中两行代码改了完事。这样做虽然功能实现了，但是却制造了大量重复代码，本文要讲的几种设计模式就是用来解决这个问题的，提高代码的抽象度，减少重复代码。 模块功能单一。这意味着一个模块就专注于一个功能，我们需要做一个大功能时，就将多个模块组合起来就行。这就像乐高积木，功能单一的模块就像乐高积木的一小块，我们可以用10个小块拼成一个小汽车，也可以用20个小块拼成一个大卡车。但是如果我们模块本身做复杂了，做成了小汽车，我们是不能用两个小汽车拼成一个大卡车的，这复用性就降低了。 提高复用性的设计模式主要有桥接模式，享元模式，模板方法模式，下面我们分别来看下。 桥接模式 桥接模式人如其名，其实就相当于一个桥梁，把不同维度的变量桥接在一起来实现功能。假设我们需要实现三种形状（长方形，圆形，三角形），每种形状有三种颜色（红色，绿色，蓝色），这个需求有两个方案，一个方案写九个方法，每个方法实现一个图形： function redRectangle() {} function greenRectangle() {} function blueRectangle() {} function redCircle() {} function greenCircle() {} function blueCircle() {} function redTriangle() {} function greenTriangle() {} function blueTriangle() {} 上述代码虽然功能实现了，但是如果我们需求变了，我们要求再加一个颜色，那我们就得再加三个方法，每个形状加一个。这么多方法看着就很重复，意味着他有优化的空间。我们仔细看下这个需求，我们最终要画的图形有颜色和形状两个变量，这两个变量其实是没有强的逻辑关系的，完全是两个维度的变量。那我们可以将这两个变量拆开，最终要画图形的时候再桥接起来，就是这样： function rectangle(color) { // 长方形 showColor(color); } function circle(color) { // 圆形 showColor(color); } function triangle(color) { // 三角形 showColor(color); } function showColor(color) { // 显示颜色的方法 } // 使用时，需要一个红色的圆形 let obj = new circle('red'); 使用桥接模式后我们的方法从3 * 3变成了3 + 1，而且如果后续颜色增加了，我们只需要稍微修改showColor方法，让他支持新颜色就行了。如果我们变量的维度不是2，而是3，这种优势会更加明显，前一种需要的方法是x * y * z个，桥接模式优化后是x + y + z个，这直接就是指数级的优化。所以这里桥接模式优化的核心思想是观察重复代码能不能拆成多个维度，如果可以的话就把不同维度拆出来，使用时再将这些维度桥接起来。 实例：毛笔和蜡笔 桥接模式其实我最喜欢的例子就是毛笔和蜡笔，因为这个例子非常直观，好理解。这个例子的需求是要画细，中,粗三种型号的线，每种型号的线需要5种颜色，如果我们用蜡笔来画就需要15支蜡笔，如果我们换毛笔来画，只需要3支毛笔就行了，每次用不同颜色的墨水，用完换墨水就行。写成代码就是这样，跟上面那个有点像: // 先来三个笔的类 function smallPen(color) { this.color = color; } smallPen.prototype.draw = function() { drawWithColor(this.color); // 用color颜色来画画 } function middlePen(color) { this.color = color; } middlePen.prototype.draw = function() { drawWithColor(this.color); // 用color颜色来画画 } function bigPen(color) { this.color = color; } bigPen.prototype.draw = function() { drawWithColor(this.color); // 用color颜色来画画 } // 再来一个颜色类 function color(color) { this.color = color; } // 使用时 new middlePen(new color('red')).draw(); // 画一个中号的红线 new bigPen(new color('green')).draw(); // 画一个大号的绿线 上述例子中蜡笔因为大小和颜色都是他本身的属性，没法分开，需要的蜡笔数量是两个维度的乘积，也就是15支，如果再多一个维度，那复杂度是指数级增长的。但是毛笔的大小和颜色这两个维度是分开的，使用时将他们桥接在一起就行，只需要三只毛笔，5瓶墨水，复杂度大大降低了。上面代码的颜色我新建了一个类，而上个例子画图形那里的颜色是直接作为参数传递的，这样做的目的是为了演示即使同一个设计模式也可以有不同的实现方案。具体采用哪种方案要根据我们实际的需求来，如果要桥接的只是颜色这么一个简单变量，完全可以作为参数传递，如果要桥接一个复杂对象，可能就需要一个类了。另外上述代码的三个笔的类看着就很重复，其实进一步优化还可以提取一个模板，也就是笔的基类，具体可以看看后面的模板方法模式。 实例：菜单项 这个例子的需求是：有多个菜单项，每个菜单项文字不一样，鼠标滑入滑出时文字的颜色也不一样。我们一般实现时可能这么写代码: function menuItem(word) { this.dom = document.createElement('div'); this.dom.innerHTML = word; } var menu1 = new menuItem('menu1'); var menu2 = new menuItem('menu2'); var menu3 = new menuItem('menu3'); // 给每个menu设置鼠标滑入滑出事件 menu1.dom.onmouseover = function(){ menu1.dom.style.color = 'red'; } menu2.dom.onmouseover = function(){ menu1.dom.style1.color = 'green'; } menu3.dom.onmouseover = function(){ menu1.dom.style1.color = 'blue'; } menu1.dom.onmouseout = function(){ menu1.dom.style1.color = 'green'; } menu2.dom.onmouseout = function(){ menu1.dom.style1.color = 'blue'; } menu3.dom.onmouseout = function(){ menu1.dom.style1.color = 'red'; } 上述代码看起来都好多重复的，为了消除这些重复代码，我们将事件绑定和颜色设置这两个维度分离开： // 菜单项类多接收一个参数color function menuItem(word, color) { this.dom = document.createElement('div'); this.dom.innerHTML = word; this.color = color; // 将接收的颜色参数作为实例属性 } // 菜单项类添加一个实例方法，用于绑定事件 menuItem.prototype.bind = function() { var that = this; // 这里的this指向menuItem实例对象 this.dom.onmouseover = function() { this.style.color = that.color.colorOver; // 注意这里的this是事件回调里面的this,指向DOM节点 } this.dom.onmouseout = function() { this.style.color = that.color.colorOut; } } // 再建一个类存放颜色，目前这个类的比较简单，后面可以根据需要扩展 function menuColor(colorOver, colorOut) { this.colorOver = colorOver; this.colorOut = colorOut; } // 现在新建菜单项可以直接用一个数组来循环了 var menus = [ {word: 'menu1', colorOver: 'red', colorOut: 'green'}, {word: 'menu2', colorOver: 'green', colorOut: 'blue'}, {word: 'menu3', colorOver: 'blue', colorOut: 'red'}, ] for(var i = 0; i 上述代码也是一样的思路，我们将事件绑定和颜色两个维度分别抽取出来，使用的时候再桥接，从而减少了大量相似的代码。 享元模式 当我们观察到代码中有大量相似的代码块，他们做的事情可能都是一样的，只是每次应用的对象不一样，我们就可以考虑用享元模式。现在假设我们有一个需求是显示多个弹窗，每个弹窗的文字和大小不同： // 已经有一个弹窗类了 function Popup() {} // 弹窗类有一个显示的方法 Popup.prototype.show = function() {} 如果我们不用享元模式，一个一个弹就是这样: var popup1 = new Popup(); popup1.show(); var popup2 = new Popup(); popup2.show(); 我们仔细观察上面的代码，发现这两个实例做的事情都是一样的，都是显示弹窗，但是每个弹窗的大小文字不一样，那show方法是不是就可以提出来公用，把不一样的部分作为参数传进去就行。这种思路其实就是享元模式，我们改造如下: var popupArr = [ {text: 'popup 1', width: 200, height: 400}, {text: 'popup 2', width: 300, height: 300}, ] var popup = new Popup(); for(var i = 0; i 实例：文件上传 我们再来看一个例子，假如我们现在有个需求是上传文件，可能需要上传多个文件，我们一般写代码可能就是这样: // 一个上传的类 function Uploader(fileType, file) { this.fileType = fileType; this.file = file; } Uploader.prototype.init = function() {} // 初始化方法 Uploader.prototype.upload = function() {} // 具体上传的方法 var file1, file2, file3; // 多个需要上传的文件 // 每个文件都实例化一个Uploader new Uploader('img', file1).upload(); new Uploader('txt', file2).upload(); new Uploader('mp3', file3).upload(); 上述代码我们需要上传三个文件于是实例化了三个Uploader，但其实这三个实例只有文件类型和文件数据不一样，其他的都是一样的，我们可以重用一样的部分，不一样的部分作为参数传进去就行了，用享元模式优化如下: // 文件数据扔到一个数组里面 var data = [ {filetype: 'img', file: file1}, {filetype: 'txt', file: file2}, {filetype: 'mp3', file: file3}, ]; // Uploader类改造一下, 构造函数不再接收参数 function Uploader() {} // 原型上的其他方法保持不变 Uploader.prototype.init = function() {} // 文件类型和文件数据其实是上传的时候才用，作为upload的参数 Uploader.prototype.upload = function(fileType, file) {} // 调用时只需要一个实例，循环调用upload就行 var uploader = new Uploader(); for(var i = 0; i 上述代码我们通过参数的抽取将3个实例简化为1个，提高了Uploader类的复用性。上述两个例子其实是类似的，但他们只是享元模式的一种形式，只要是符合这种思想的都可以叫享元模式，比如jQuery里面的extend方法也用到了享元模式。 实例：jQuery的extend方法 jQuery的extend方法是大家经常用的一个方法了，他接收一个或者多个参数： 只有一个参数时，extend会将传入的参数合并到jQuery自己身上。 传入两个参数obj1和obj2时，extend会将obj2合并到obj1上。 根据上述需求，我们很容易自己实现： $.extend = function() { if(arguments.length === 1) { for(var item in arguments[0]) { this[item] = arguments[0][item] } } else if(arguments.length === 2) { for(var item in arguments[1]) { arguments[0][item] = arguments[1][item]; } } } 上述代码的this[item] = arguments[0][item]和arguments[0][item] = arguments[1][item]看着就很像，我们想想能不能优化下他，仔细看着两行代码，他们不同的地方是拷贝的目标和来源不一样，但是拷贝的操作却是一样的。所以我们用享元模式优化下，将不同的地方抽出来，保持共用的拷贝不变: $.extend = function() { // 不同的部分抽取出两个变量 var target = this; // 默认为this，即$本身 var source = arguments[0]; // 默认为第一个变量 // 如果有两个参数, 改变target和source if(arguments.length === 2) { target = arguments[0]; source = arguments[1]; } // 共同的拷贝操作保持不变 for(var item in source) { target[item] = source[item]; } } 模板方法模式 模板方法模式其实类似于继承，就是我们先定义一个通用的模板骨架，然后后面在这个基础上继续扩展。我们通过一个需求来看下他的基本结构，假设我们现在需要实现一个导航组件，但是这个导航类型还比较多，有的带消息提示，有的是横着的，有的是竖着的，而且后面还可能会新增类型： // 先建一个基础的类 function baseNav() { } baseNav.prototype.action = function(callback){} //接收一个回调进行特异性处理 上述代码我们先建了一个基础的类，里面只有最基本的属性和方法，其实就相当于一个模板，而且在具体的方法里面还可以接收回调，这样后面派生出来的类可以根据自己的需求传入回调。模板方法模式其实就是类似于面向对象的基类和派生类的关系，下面我们再来看一个例子。 实例：弹窗 还是之前用过的弹窗例子，我们要做一个大小文字可能不同的弹窗组件，只是这次我们的弹窗还有取消和确定两个按钮，这两个按钮在不同场景下可能有不同的行为，比如发起请求什么的。但是他们也有一个共同的操作，就是点击这两个按钮后弹窗都会消失，这样我们就可以把共同的部分先写出来，作为一个模板： function basePopup(word, size) { this.word = word; this.size = size; this.dom = null; } basePopup.prototype.init = function() { // 初始化DOM元素 var div = document.createElement('div'); div.innerHTML = this.word; div.style.width = this.size.width; div.style.height = this.size.height; this.dom = div; } // 取消的方法 basePopup.prototype.cancel = function() { this.dom.style.display = 'none'; } // 确认的方法 basePopup.prototype.confirm = function() { this.dom.style.display = 'none'; } 现在我们有了一个基础的模板，那假如我们还需要在点击取消或者确认后再进行其他操作，比如发起请求，我们可以以这个模板为基础再加上后面需要的操作就行： // 先继承basePopup function ajaxPopup(word, size) { basePopup.call(this, word, size); } ajaxPopup.prototype = new basePopup(); ajaxPopup.prototype.constructor = ajaxPopup; // 上面是一个继承的标准写法，其实就相当于套用了模板 // 下面来加上需要的发起网络请求的操作 var cancel = ajaxPopup.prototype.cancel; // 先缓存模板上的cancel方法 ajaxPopup.prototype.cancel = function() { // 先调模板的cancel cancel.call(this); // 再加上特殊的处理，比如发起请求 $.ajax(); } // confirm方法是一样的处理 var confirm = ajaxPopup.prototype.confirm; ajaxPopup.prototype.confirm = function() { confirm.call(this); $.ajax(); } 上面这个例子是通过继承实现了模板方法模式，但是这个模式并不是一定要用继承的，他强调的是将一些基础部分提取出来作为模板，后面更多的操作可以在这个基础上进行扩展。 实例：算法计算器 这个例子我们就不用继承了，他的需求是我们现在有一系列的算法，但是这些算法在具体用的时候可能还会添加一些不同的计算操作，需要添加的操作可能在这个算法前执行，也可能在这个算法后执行。 // 先定义一个基本的类 function counter() { } // 类上有一个计算方法 counter.prototype.count = function(num) { // 里面有一个算法本身的基本计算方法 function baseCount(num) { // 这里的算法是什么不重要，我们这里就加1吧 num += 1; return num; } } 根据需求我们要解决的问题是在基本算法计算时可能还有其他计算操作，这些操作可能在基本计算前，也可能在基本计算之后，所以我们要在这个计算类上留出可扩展的接口： function counter() { // 添加两个队列，用于基本算法前或者后执行 this.beforeCounting = []; this.afterCounting = []; } // 添加一个接口，接收基本算法计算前应该进行的计算 counter.prototype.before = function(fn) { this.beforeCounting.push(fn); // 直接将方法放进数组里面 } // 再添加一个接口，接收基本算法计算后应该进行的计算 counter.prototype.after = function(fn) { this.afterCounting.push(fn); } // 改造计算方法，让他按照计算前-基本计算-计算后执行 counter.prototype.count = function(num) { function baseCount(num) { num += 1; return num; } var result = num; var arr = [baseCount]; // 将需要进行的计算都放到这个数组里面 arr = this.beforeCounting.concat(arr); // 计算前操作放到数组前面 arr = arr.concat(this.afterCounting); // 计算后操作放到数组后面 // 将数组全部按顺序拿出来执行 while(arr.length > 0) { result = arr.shift()(result); } return result; } // 现在counter就可以直接使用了 var counterIntance = new counter(); counterIntance.before(num => num + 10); // 计算前先加10 counterIntance.after(num => num - 5); // 计算后再减5 counterIntance.count(2); // 2 + 10 + 1 - 5 = 8 这次我们没有用继承了，但是我们仍然是先定义了一个基本的操作骨架，然后在这个骨架上去扩展不同地方需要的特殊操作。 总结 如果我们的代码中出现了大量相似的代码块，往往意味着有进一步的优化空间。 如果这些重复代码块可以拆分成不同的维度，那可以试试桥接模式，先将维度拆开，再桥接这些维度来使用。 如果这些重复代码有一部分操作是一样的，但是每次操作的对象不一样，我们可以考虑用享元模式将公有操作提取成方法，将私有部分作为参数传进去。 如果这些重复代码有一些基本操作是一样的，但是具体应用时需要的功能更多，我们可以考虑将这些基本操作提取成模板，然后在模板上留出扩展接口，需要的地方可以通过这些接口来扩展功能，有点类似于继承，但实现方式并不仅限于继承。 我们将重复部分提取出来，其他地方也可以用，其实就是提高了代码的复用性。 还是那句话，设计模式没有固定的范式，主要还是要理解他的思想，代码在不同地方可以有不同的实现方式。 "},"Articles/DesignPatterns/Extendability.html":{"url":"Articles/DesignPatterns/Extendability.html","title":"提高扩展性的设计模式：职责链，观察者，装饰器，适配器，命令，访问者","keywords":"","body":"为什么要提高代码扩展性 我们写的代码都是为了一定的需求服务的，但是这些需求并不是一成不变的，当需求变更了，如果我们代码的扩展性很好，我们可能只需要简单的添加或者删除模块就行了，如果扩展性不好，可能所有代码都需要重写，那就是一场灾难了，所以提高代码的扩展性是势在必行的。怎样才算有好的扩展性呢？好的扩展性应该具备以下特征: 需求变更时，代码不需要重写。 局部代码的修改不会引起大规模的改动。有时候我们去重构一小块代码，但是发现他跟其他代码都是杂糅在一起的，里面各种耦合，一件事情拆在几个地方做，要想改这一小块必须要改很多其他代码。那说明这些代码的耦合太高，扩展性不强。 可以很方便的引入新功能和新模块。 怎么提高代码扩展性？ 当然是从优秀的代码身上学习了，本文会深入Axios，Node.js，Vue等优秀框架，从他们源码总结几种设计模式出来，然后再用这些设计模式尝试解决下工作中遇到的问题。本文主要会讲职责链模式，观察者模式，适配器模式，装饰器模式。下面一起来看下吧： 职责链模式 职责链模式顾名思义就是一个链条，这个链条上串联了很多的职责，一个事件过来，可以被链条上的职责依次处理。他的好处是链条上的各个职责，只需要关心自己的事情就行了，不需要知道自己的上一步是什么，下一步是什么，跟上下的职责都不耦合，这样当上下职责变化了，自己也不受影响，往链条上添加或者减少职责也非常方便。 实例：Axios拦截器 用过Axios的朋友应该知道，Axios的拦截器有请求拦截器和响应拦截器，执行的顺序是请求拦截器 -> 发起请求 -> 响应拦截器，这其实就是一个链条上串起了三个职责。下面我们来看看这个链条怎么实现： // 先从用法入手，一般我们添加拦截器是这样写的 // instance.interceptors.request.use(fulfilled, rejected) // 根据这个用法我们先写一个`Axios`类。 function Axios() { // 实例上有个interceptors对象，里面有request和response两个属性 // 这两个属性都是InterceptorManager的实例 this.interceptors = { request: new InterceptorManager(), response: new InterceptorManager() }; } // 然后是实现InterceptorManager类 function InterceptorManager() { // 实例上有一个数组，存储拦截器方法 this.handlers = []; } // InterceptorManager有一个实例方法use InterceptorManager.prototype.use = function(fulfilled, rejected) { // 这个方法很简单，把传入的回调放到handlers里面就行 this.handlers.push({ fulfilled, rejected }) } 上面的代码其实就完成了拦截器创建和use的逻辑，并不复杂，那这些拦截器方法都是什么时候执行呢？当然是我们调用instance.request的时候，调用instance.request的时候真正执行的就是请求拦截器 -> 发起请求 -> 响应拦截器链条，所以我们还需要来实现下Axios.prototype.request: Axios.prototype.request = function(config) { // chain里面存的就是我们要执行的方法链条 // dispatchRequest是发起网络请求的方法，本文主要讲设计模式，这个方法就不实现了 // chain里面先把发起网络请求的方法放进去，他的位置应该在chain的中间 const chain = [dispatchRequest, undefined]; // chain前面是请求拦截器的方法,从request.handlers里面取出来放进去 this.interceptors.request.handlers.forEach(function unshiftRequestInterceptors(interceptor) { chain.unshift(interceptor.fulfilled, interceptor.rejected); }); // chain后面是响应拦截器的方法，从response.handlers里面取出来放进去 this.interceptors.response.handlers.forEach(function pushResponseInterceptors(interceptor) { chain.push(interceptor.fulfilled, interceptor.rejected); }); // 经过上述代码的组织，chain这时候是这样的： // [request.fulfilled, request.rejected, dispatchRequest, undefined, response.fulfilled, // response.rejected] // 这其实已经按照请求拦截器 -> 发起请求 -> 响应拦截器的顺序排好了，拿来执行就行 let promise = Promise.resolve(config); // 先来个空的promise，好开启then while (chain.length) { // 用promise.then进行链式调用 promise = promise.then(chain.shift(), chain.shift()); } return promise; } 上述代码是从Axios源码中精简出来的，可以看出他巧妙的运用了职责链模式，将需要做的任务组织成一个链条，这个链条上的任务相互不影响，拦截器可有可无，而且可以有多个，兼容性非常强。 实例：职责链组织表单验证 看了优秀框架对职责链模式的运用，我们再看看在我们平时工作中这个模式怎么运用起来。现在假设有这样一个需求是做一个表单验证，这个验证需要前端先对格式等内容进行校验，然后API发给后端进行合法性校验。我们先分析下这个需求，前端校验是同步的，后端验证是异步的，整个流程是同步异步交织的，为了能兼容这种情况，我们的每个验证方法的返回值都需要包装成promise才行 // 前端验证先写个方法 function frontEndValidator(inputValue) { return Promise.resolve(inputValue); // 注意返回值是个promise } // 后端验证也写个方法 function backEndValidator(inputValue) { return Promise.resolve(inputValue); } // 写一个验证器 function validator(inputValue) { // 仿照Axios，将各个步骤放入一个数组 const validators = [frontEndValidator, backEndValidator]; // 前面Axios是循环调用promise.then来执行的职责链，我们这里换个方式，用async来执行下 async function runValidate() { let result = inputValue; while(validators.length) { result = await validators.shift()(result); } return result; } // 执行runValidate，注意返回值也是一个promise runValidate().then((res) => {console.log(res)}); } // 上述代码已经可以执行了，只是我们没有具体的校验逻辑，输入值会原封不动的返回 validator(123); // 输出: 123 上述代码我们用职责链模式组织了多个校验逻辑，这几个校验之间相互之间没有依赖，如果以后需要减少某个校验，只需要将它从validators数组中删除即可，如果要添加就往这个数组添加就行了。这几个校验器之间的耦合度就大大降低了，而且他们封装的是promise，完全还可以用到其他模块去，其他模块根据需要组织自己的职责链就行了。 观察者模式 观察者模式还有个名字叫发布订阅模式，这在JS的世界里可是大名鼎鼎，大家或多或少都用到过，最常见的就是事件绑定了，有些面试还会要求面试者手写一个事件中心，其实就是一个观察者模式。观察者模式的优点是可以让事件的产生者和消费者相互不知道，只需要产生和消费相应的事件就行，特别适合事件的生产者和消费者不方便直接调用的情况，比如异步中。我们来手写一个看看： class PubSub { constructor() { // 一个对象存放所有的消息订阅 // 每个消息对应一个数组，数组结构如下 // { // \"event1\": [cb1, cb2] // } this.events = {} } subscribe(event, callback) { if(this.events[event]) { // 如果有人订阅过了，这个键已经存在，就往里面加就好了 this.events[event].push(callback); } else { // 没人订阅过，就建一个数组，回调放进去 this.events[event] = [callback] } } publish(event, ...args) { // 取出所有订阅者的回调执行 const subscribedEvents = this.events[event]; if(subscribedEvents && subscribedEvents.length) { subscribedEvents.forEach(callback => { callback.call(this, ...args); }); } } unsubscribe(event, callback) { // 删除某个订阅，保留其他订阅 const subscribedEvents = this.events[event]; if(subscribedEvents && subscribedEvents.length) { this.events[event] = this.events[event].filter(cb => cb !== callback) } } } // 使用的时候 const pubSub = new PubSub(); pubSub.subscribe('event1', () => {}); // 注册事件 pubSub.publish('event1'); // 发布事件 实例：Node.js的EventEmitter 观察者模式的一个典型应用就是Node.js的EventEmitter，我有另一篇文章从发布订阅模式入手读懂Node.js的EventEmitter源码从异步应用的角度详细讲解了观察者模式的原理和Node.js的EventEmitter源码，我这里就不重复书写了，上面的手写代码也是来自这篇文章。 实例：转圈抽奖 一样的，看了优秀框架的源码，我们自己也要试着来用一下，这里的例子是转圈抽奖。想必很多朋友都在网上抽过奖，一个转盘，里面各种奖品，点一下抽奖，然后指针开始旋转，最后会停留到一个奖品那里。我们这个例子就是要实现这样一个Demo，但是还有一个要求是每转一圈速度就加快一点。我们来分析下这个需求: 要转盘抽奖，我们肯定先要把转盘画出来。 抽奖肯定会有个结果，有奖还是没奖，具体是什么奖品，一般这个结果都是API返回的，很多实现方案是点击抽奖就发起API请求拿到结果了，转圈动画只是个效果而已。 我们写一点代码让转盘动起来，需要一个运动效果 每转一圈我们需要加快速度，所以还需要控制运动的速度 通过上面的分析我们发现一个问题，转盘运动是需要一些时间的，当他运动完了需要告诉控制转盘的模块加快速度进行下一圈的运动，所以运动模块和控制模块需要一个异步通信，这种异步通信就需要我们的观察者模式来解决了。最终效果如下，由于只是个DEMO，我就用几个DIV块来代替转盘了： 下面是代码： // 先把之前的发布订阅模式拿过来 class PubSub { constructor() { this.events = {} } subscribe(event, callback) { if(this.events[event]) { this.events[event].push(callback); } else { this.events[event] = [callback] } } publish(event, ...args) { const subscribedEvents = this.events[event]; if(subscribedEvents && subscribedEvents.length) { subscribedEvents.forEach(callback => { callback.call(this, ...args); }); } } unsubscribe(event, callback) { const subscribedEvents = this.events[event]; if(subscribedEvents && subscribedEvents.length) { this.events[event] = this.events[event].filter(cb => cb !== callback) } } } // 实例化一个事件中心 const pubSub = new PubSub(); // 总共有 初始化页面 -> 获取最终结果 -> 运动效果 -> 运动控制 四个模块 // 初始化页面 const domArr = []; function initHTML(target) { // 总共10个可选奖品，也就是10个DIV for(let i = 0; i { // 每次移动给当前元素加上边框,移除上一个的边框 if(current !== 0) { lastIndex = current - 1; } domArr[lastIndex].setAttribute('class', 'item'); domArr[current].setAttribute('class', 'item item-on'); current++; if(current === moveConfig.times) { clearInterval(timer); // 转完了一圈广播事件 if(moveConfig.times === 10) { pubSub.publish('finish'); } } }, moveConfig.speed); } // 运动控制模块，控制每圈的参数 function moveController() { let allTimes = getFinal(); let circles = Math.floor(allTimes / 10, 0); let stopNum = allTimes % circles; let speed = 250; let ranCircle = 0; move({ times: 10, speed }); // 手动开启第一次旋转 // 监听事件，每次旋转完成自动开启下一次旋转 pubSub.subscribe('finish', () => { let time = 0; speed -= 50; ranCircle++; if(ranCircle 上述代码的难点就在于运动模块的运动是异步的，需要在每圈运动完了之后通知运动控制模块进行下一次转动，观察者模式很好的解决了这个问题。 装饰器模式 装饰器模式针对的情况是我有一些老代码，但是这些老代码功能不够，需要添加功能，但是我又不能去改老代码，比如Vue 2.x需要监听数组的改变，给他添加响应式，但是他又不能直接修改Array.prototype。这种情况下，就特别适合使用装饰者模式，给老方法重新装饰下，变成一个新方法来使用。 基本结构 装饰器模式的结构也很简单，就是先调用一下原来的方法，然后加上更多的操作，就是装饰一下。 var a = { b: function() {} } function myB() { // 先调用以前的方法 a.b(); // 再加上自己的新操作 console.log('新操作'); } 实例：Vue数组的监听 熟悉Vue响应式原理的朋友都知道(不熟悉的朋友可以看这里)，Vue 2.x对象的响应式是通过Object.defineProperty实现的，但是这个方法不能监听数组的改变，那数组怎么监听的呢？数组操作一般就是push，shift这些方法，这些方法是数组原生的方法，我们当然不能去改他，那会了装饰器模式，我们完全可以在保持他之前功能的基础上给他扩展功能： var arrayProto = Array.prototype; // 先拿到原生数组的原型 var arrObj = Object.create(arrayProto); // 用原生数组的原型创建一个新对象，免得污染原生数组 var methods = ['push', 'shift']; // 需要扩展的方法，这里只写了两个，但是不止这两个 // 循环methods数组，扩展他们 methods.forEach(function(method) { // 用扩展的方法替换arrObj上的方法 arrObj[method] = function() { var result = arrayProto[method].apply(this, arguments); // 先执行老方法 dep.notify(); // 这个是Vue的方法，用来做响应式 return result; } }); // 对于用户定义的数组，手动将它的原型指向扩展了的arrObj var a = [1, 2, 3]; a.__proto__ = arrObj; 上述代码是从Vue源码精简过来的，其实就是一个典型的使用装饰器扩展原有方法的功能的例子，因为Vue只扩展了数组方法，如果你不通过这些方法，而是直接通过下标来操作数组，响应式就不起作用了。 实例：扩展已有的事件绑定 老规矩，学习了人家的代码，我们自己也来试试。这个例子面临的需求是我们需要对已有的DOM点击事件上增加一些操作。 // 我们以前的点击事件只需要打印1 dom.onclick = function() { console.log(1); } 但是我们现在的需求要求还要输出一个2，我们当然可以返回原来的代码将他改掉，但是我们也可以用装饰者模式给他添加功能： var oldFunc = dom.onclick; // 先将老方法拿出来 dom.onclick = function() { // 重新绑定事件 oldFunc.apply(this, arguments); // 先执行老的方法 // 然后添加新的方法 console.log(2); } 上述代码就扩展了dom的点击事件，但是如果需要修改的DOM元素很多，我们要一个一个的去重新绑定事件，又会有大量相似代码，我们学设计模式的目的之一就是要避免重复代码，于是我们可以将公用的绑定操作提取出来，作为一个装饰器： var decorator = function(dom, fn) { var oldFunc = dom.onclick; if(typeof oldFunc === 'function'){ dom.onclick = function() { oldFunc.apply(this, arguments); fn(); } } } // 调用装饰器，传入参数就可以扩展了 decorator(document.getElementById('test'), function() { console.log(2); }) 这种方式特别适合我们引入的第三方UI组件，有些UI组件自己封装了很多功能，但是并没有暴露出接口，如果我们要添加功能，又不能直接修改他的源码，最好的方法就是这样使用装饰器模式来扩展，而且有了装饰工厂之后，我们还可以快速批量修改。 适配器模式 适配器想必大家都用过，我家里的老显卡只有HDMI接口，但是显示器是DP接口，这两个插不上，怎么办呢？答案就是买个适配器，将DP接口转换为HDMI的就行了。这里的适配器模式原理类似，当我们面临接口不通用，接口参数不匹配等情况，我们可以在他外面再包一个方法，这个方法接收我们现在的名字和参数，里面调用老方法传入以前的参数形式。 基本结构 适配器模式的基本结构就是下面这样，假设我们要用的打log的函数叫mylog，但是具体方法我们又想调用现成的window.console.log实现，那我们就可以给他包一层。 var mylog = (function(){ return window.console.log; })() 如果觉得上面的结构太简单了，仍然不知道怎么运用，我们下面再通过一个例子来看下。 实例：框架变更了 假如我们现在面临的一个问题是公司以前一直使用的A框架，但是现在决定换成jQuery了，这两个框架大部分接口是兼容的，但是部分接口不适配，我们需要解决这个问题。 // 一个修改css的接口 $.css(); // jQuery叫css A.style(); // A框架叫style // 一个绑定事件的接口 $.on(); // jQuery叫on A.bind(); // A框架叫bind 当然我们全局搜索把使用的地方改掉也行，但是如果使用适配器修改可能更优雅: // 直接把以前用的A替换成$ window.A = $; // 适配A.style A.style = function() { return $.css.apply(this, arguments); // 保持this不变 } // 适配A.bind A.bind = function() { return $.on.apply(this, arguments); } 适配器就是这么简单，接口不一样，包一层改成一样就行了。 实例：参数适配 适配器模式不仅仅可以像上面那样来适配接口不一致的情况，还可以用来适配参数的多样性。假如我们的一个方法需要接收一个很复杂的对象参数，比如webpack的配置，可能有很多选项，但是用户可能只用到部分，或者用户可能传入不支持的配置，那我们需要一个将用户传入的配置适配到标准配置的过程，这个做起来其实也很简单： // func方法接收一个很复杂的config function func(config) { var defaultConfig = { name: 'hong', color: 'red', // ...... }; // 为了将用户的配置适配到标准配置，我们直接循环defaultConfig // 如果用户传入了配置，就用用户的，如果没传就用默认的 for(var item in defaultConfig) { defaultConfig[item] = config[item] || defaultConfig[item]; } } 访问者模式 定义一个访问者，访问者作为中介来访问数据，请求者不直接访问数据，而是通过访问者间接来访问数据。 实例：不同角色访问数据 // 报表数据 function report() { this.cost = 10; this.income = 20; this.profit = 10; } // 角色：老板,只关心利润 function boss() {} boss.prototype.get = function(profit){} // 角色：财务，只关心收入和支出 function account() {} account.prototype.get = function(num1, num2){} // 中介访问者 function vistor(data, man) { var handers = { boss: function(data) { man.get(data.profit); }, boss: function(data) { man.get(data.income, data.cost); }, } return handers[man.constructor.name]; } // 老板要看报表了 vistor(new report(), new boss()); // 财务要看报表了 vistor(new report(), new account()); 有时候我们需要用现有方法，但是现有方法与需求不太吻合，需要进行部分修改，但是改原方法影响面又太大，我们就可以考虑使用下列两种设计模式，适配器模式和装饰器模式。 命令模式 前面两种模式可以让我们在不修改原方法的情况下将它用于当前特异性的需求，保证了以前代码不受影响，也相当于扩展了原来方法的适用范围。这里再来讲一种可以解耦实现和调用的设计模式----命令模式，这种模式可以在实现或者调用单个变化时不影响另一个，一般适用于调用方式可能会变化的情况。 目的：解耦实现和调用，让双方互不干扰 应用场景：调用的命令充满不确定性 基本结构 命令模式的一般结构是一个自执行方法里面返回一个execute方法，这个execute可以访问到action对象，这个对象才是真正执行功能的地方，execute根据传入的命令调用对应的action。 var commander = (function(){ var action = { }; return function execute(command){} })(command) 实例：绘图命令 这个例子讲的是封装一系列的canvas绘图命令，常规的代码我们可以这样写： var myCanvas = function() { } myCanvas.prototype.drawCircle = function() {} myCanvas.prototype.drawRect = function() {} // 使用时 var mycanvas = new myCanvas(); mycanvas.drawCircle(); mycanvas.drawRect(); 上述代码，外部调用画画是直接调用了myCanvas里面的API，这样外面的调用和里面的实现时是强耦合的，如果里面的方法名变了，外部调用的地方都需要修改。为了解除这种强耦合，我们可以使用命令模式来包装下。 var canvasCommander = (function(){ var action = { drawCircle: function() {}, drawRect: function() {}, }; return function execute(commands){ commands.forEach((item) => { action[item.command](item.config); }); } })(commands) // 上面的canvasCommander参数接收一个数组，使用时就是这样 canvasCommander([ {command: 'drawCircle', config: {}}, {command: 'drawRect', config: {}} ]); 总结 扩展性的核心其实就是高内聚，低耦合，各个模块都专注在自己的功能，尽量减少对外部的直接依赖。 职责链模式和观察者模式主要是用来降低模块间耦合的，耦合低了就可以很方便的对他们进行组织，给他们扩展功能，适配器模式和装饰器模式主要是用来在不影响原有代码的基础上进行扩展的。 如果我们需要对某个对象进行一系列的操作，这些操作可以组织成一个链条，那我们可以考虑使用职责链模式。链条上的具体任务不需要知道其他任务的存在，只专注自己的工作，消息的传递由链条负责。使用了职责链模式，链条上的任务可以很方便的增加，删除或者重新组织成新的链条，就像一个流水线一样。 如果我们有两个对象在不确定的时间点需要异步通讯，我们可以考虑使用观察者模式，使用者不需要一直关注其他特定的对象，他只要在消息中心注册一个消息，当这个消息出现时，消息中心会负责来通知他。 如果我们已经拿到了一些旧代码，但是这些旧代码不能满足我们的需求，我们又不能随意更改他，我们可以考虑使用装饰器模式来增强他的功能。 对于旧代码改造或者新模块引入，我们可能面临接口不通用的情况，这时候我们可以考虑写一个适配器来适配他们。适配器模式同样适用于参数适配的情况。 还是那句话，设计模式更注重的是思想，不用生搬硬套代码模板。也不要在所有地方硬套设计模式，而是在真正需要的时候使用他来增加我们代码的可扩展性。 访问者模式其实是加了一个访问者中介，数据的请求者不直接请求数据，而是通过中介来请求，让请求者和数据脱耦。 命令模式是通过命令来调用具体的方法，调用者不直接调用具体的方法，而是只发出命令，让调用者和具体实现脱耦。 本文是设计模式的第三篇文章，主要讲提高扩展性的设计模式，前两篇是： （480赞！）不知道怎么封装代码？看看这几种设计模式吧！ 不知道怎么提高代码复用性？看看这几种设计模式吧 后面还有一篇提高代码质量的设计模式。 "},"Articles/DesignPatterns/Quality.html":{"url":"Articles/DesignPatterns/Quality.html","title":"提高代码质量的设计模式：策略/状态，外观，迭代器，备忘录","keywords":"","body":"提高代码质量的目的 程序猿的本职工作就是写代码，写出高质量的代码应该是我们的追求和对自己的要求，因为： 高质量的代码往往意味着更少的BUG，更好的模块化，是我们扩展性，复用性的基础 高质量的代码也意味着更好的书写，更好的命名，有利于我们的维护 什么代码算好的质量 怎样来定义代码质量的\"好\"，业界有很多标准，本文认为好的代码应该有以下特点： 代码整洁，比如缩进之类的，现在有很多工具可以自动解决这个问题，比如eslint。 结构规整，没有漫长的结构，函数拆分合理，不会来一个几千行的函数，也不会有几十个if...else。这要求写代码的人有一些优化的经验，本文会介绍几种模式来优化这些情况。 阅读起来好理解，不会出现一堆a,b,c这种命名，而是应该尽量语义化，变量名和函数名都尽量有意义，最好是代码即注释，让别人看你的代码就知道你在干嘛。 本文介绍的设计模式主要有策略/状态模式，外观模式，迭代器模式，备忘录模式。 策略/状态模式 策略模式基本结构 假如我们需要做一个计算器，需要支持加减乘除，为了判断用户具体需要进行哪个操作，我们需要4个if...else来进行判断，如果支持更多操作，那if...else会更长，不利于阅读，看着也不优雅。所以我们可以用策略模式优化如下： function calculator(type, a, b) { const strategy = { add: function(a, b) { return a + b; }, minus: function(a, b) { return a - b; }, division: function(a, b) { return a / b; }, times: function(a, b) { return a * b; } } return strategy[type](a, b); } // 使用时 calculator('add', 1, 1); 上述代码我们用一个对象取代了多个if...else，我们需要的操作都对应这个对象里面的一个属性，这个属性名字对应我们传入的type，我们直接用这个属性名字就可以获取对应的操作。 状态模式基本结构 状态模式和策略模式很像，也是有一个对象存储一些策略，但是还有一个变量来存储当前的状态，我们根据当前状态来获取具体的操作： function stateFactor(state) { const stateObj = { status: '', state: { state1: function(){}, state2: function(){}, }, run: function() { return this.state[this.status]; } } stateObj.status = state; return stateObj; } // 使用时 stateFactor('state1').run(); if...else其实是根据不同的条件来改变代码的行为，而策略模式和状态模式都可以根据传入的策略或者状态的不同来改变行为，所有我们可以用这两种模式来替代if...else。 实例：访问权限 这个例子的需求是我们的页面需要根据不同的角色来渲染不同的内容，如果我们用if...else写就是这样: // 有三个模块需要显示，不同角色看到的模块应该不同 function showPart1() {} function showPart2() {} function showPart3() {} // 获取当前用户的角色，然后决定显示哪些部分 axios.get('xxx').then((role) => { if(role === 'boss'){ showPart1(); showPart2(); showPart3(); } else if(role === 'manager') { showPart1(); showPart2(); } else if(role === 'staff') { showPart3(); } }); 上述代码中我们通过API请求获得了当前用户的角色，然后一堆if...else去判断应该显示哪些模块，如果角色很多，这里的if...else就可能很长，我们可以尝试用状态模式优化下： // 先把各种角色都包装到一个ShowController类里面 function ShowController() { this.role = ''; this.roleMap = { boss: function() { showPart1(); showPart2(); showPart3(); }, manager: function() { showPart1(); showPart2(); }, staff: function() { showPart3(); } } } // ShowController上添加一个实例方法show，用来根据角色展示不同的内容 ShowController.prototype.show = function() { axios.get('xxx').then((role) => { this.role = role; this.roleMap[this.role](); }); } // 使用时 new ShowController().show(); 上述代码我们通过一个状态模式改写了访问权限模块，去掉了if...else，而且不同角色的展示都封装到了roleMap里面，后面要增加或者减少都会方便很多。 实例：复合运动 这个例子的需求是我们现在有一个小球，我们需要控制他移动，他移动的方向可以是上下左右，还可以是左上，右下之类的复合运动。如果我们也用if...else来写，这头都会写大： // 先来四个方向的基本运动 function moveUp() {} function moveDown() {} function moveLeft() {} function moveRight() {} // 具体移动的方法，可以接收一个或两个参数，一个就是基本操作，两个参数就是左上，右下这类操作 function move(...args) { if(args.length === 1) { if(args[0] === 'up') { moveUp(); } else if(args[0] === 'down') { moveDown(); } else if(args[0] === 'left') { moveLeft(); } else if(args[0] === 'right') { moveRight(); } } else { if(args[0] === 'left' && args[1] === 'up') { moveLeft(); moveUp(); } else if(args[0] === 'right' && args[1] === 'down') { moveRight(); moveDown(); } // 后面还有很多if... } } 可以看到这里if...else看得我们头都大了，还是用策略模式来优化下吧： // 建一个移动控制类 function MoveController() { this.status = []; this.moveHanders = { // 写上每个指令对应的方法 up: moveUp, dowm: moveDown, left: moveLeft, right: moveRight } } // MoveController添加一个实例方法来触发运动 MoveController.prototype.run = function(...args) { this.status = args; this.status.forEach((move) => { this.moveHanders[move](); }); } // 使用时 new MoveController().run('left', 'up') 上述代码我们也是将所有的策略都封装到了moveHanders里面，然后通过实例方法run传入的方法来执行具体的策略。 外观模式 基本结构 当我们设计一个模块时，里面的方法可以会设计得比较细，但是暴露给外面使用的时候，不一定非得直接暴露这些细小的接口，外部使用者需要的可能是组合部分接口来实现某个功能，我们暴露的时候其实就可以将这个组织好。这就像餐厅里面的菜单，有很多菜，用户可以一个一个菜去点，也可以直接点一个套餐，外观模式提供的就类似于这样一个组织好的套餐： function model1() {} function model2() {} // 可以提供一个更高阶的接口，组合好了model1和model2给外部使用 function use() { model2(model1()); } 实例：常见的接口封装 外观模式说起来其实非常常见，很多模块内部都很复杂，但是对外的接口可能都是一两个，我们无需知道复杂的内部细节，只需要调用统一的高级接口就行，比如下面的选项卡模块: // 一个选项卡类，他内部可能有多个子模块 function Tab() {} Tab.prototype.renderHTML = function() {} // 渲染页面的子模块 Tab.prototype.bindEvent = function() {} // 绑定事件的子模块 Tab.prototype.loadCss = function() {} // 加载样式的子模块 // 对外不需要暴露上面那些具体的子模块，只需要一个高级接口就行 Tab.prototype.init = function(config) { this.loadCss(); this.renderHTML(); this.bindEvent(); } 上述代码这种封装模式非常常见，其实也是用到了外观模式，他当然也可以暴露具体的renderHTML，bindEvent，loadCss这些子模块，但是外部使用者可能并不关心这些细节，只需要给一个统一的高级接口就行，就相当于改变了外观暴露出来，所以叫外观模式。 实例：方法的封装 这个例子也很常见，就是把一些类似的功能封装成一个方法，而不是每个地方去写一遍。在以前还是IE主导天下的时候，我们需要做很多兼容的工作，仅仅是一个绑定事件就有addEventListener，attachEvent,onclick等，为了避免每次都进行这些检测，我们可以将他们封装成一个方法： function addEvent(dom, type, fn) { if(dom.addEventListener) { return dom.addEventListener(type, fn, false); } else if(dom.attachEvent) { return dom.attachEvent(\"on\" + type, fn); } else { dom[\"on\" + type] = fn; } } 然后将addEvent暴露出去给外面使用，其实我们在实际编码时经常这样封装方法，只是我们自己可能没意识到这个是外观模式。 迭代器模式 基本结构 迭代器模式模式在JS里面很常见了，数组自带的forEach就是迭代器模式的一个应用，我们也可以实现一个类似的功能： function Iterator(items) { this.items = items; } Iterator.prototype.dealEach = function(fn) { for(let i = 0; i 上述代码我们新建了一个迭代器类，构造函数接收一个数组，实例方法dealEach可以接收一个回调，对实例上的items每一项都执行这个回调。 实例：数据迭代器 其实JS数组很多原生方法都用了迭代器模式，比如find，find接收一个测试函数，返回符合这个测试函数的第一个数据。这个例子要做的是扩展这个功能，返回所有符合这个测试函数的数据项，而且也可以接收两个参数，第一个参数是属性名，第二个参数是值，同样返回所有该属性与值匹配的项： // 外层用一个工厂模式封装下，调用时不用写new function iteratorFactory(data) { function Iterator(data) { this.data = data; } Iterator.prototype.findAll = function(handler, value) { const result = []; let handlerFn; // 处理参数，如果第一个参数是函数，直接拿来用 // 如果不是函数，就是属性名，给一个对比的默认函数 if(typeof handler === 'function') { handlerFn = handler; } else { handlerFn = function(item) { if(item[handler] === value) { return true; } return false; } } // 循环数据里面的每一项，将符合结果的塞入结果数组 for(let i = 0; i item.num >= 2); // [{num: 2}, {num: 3}] 上述代码封装了一个类似数组find的迭代器，扩展了他的功能，这种迭代器非常适合用来处理API返回的大量结构相似的数据。 备忘录模式 基本结构 备忘录模式类似于JS经常使用的缓存函数，内部记录一个状态，也就是缓存，当我们再次访问的时候可以直接拿缓存数据: function memo() { const cache = {}; return function(arg) { if(cache[arg]) { return cache[arg]; } else { // 没缓存的时候先执行方法，得到结果res // 然后将res写入缓存 cache[arg] = res; return res; } } 实例：文章缓存 这个例子在实际项目中也比较常见，用户每次点进一个新文章都需要从API请求数据，如果他下次再点进同一篇文章，我们可能希望直接用上次请求的数据，而不再次请求，这时候就可以用到我们的备忘录模式了，直接拿上面的结构来用就行了： function pageCache(pageId) { const cache = {}; return function(pageId) { // 为了保持返回类型一致，我们都返回一个Promise if(cache[pageId]) { return Promise.solve(cache[pageId]); } else { return axios.get(pageId).then((data) => { cache[pageId] = data; return data; }) } } } 上述代码用了备忘录模式来解决这个问题，但是代码比较简单，实际项目中可能需求会更加复杂一些，但是这个思路还是可以参考的。 实例：前进后退功能 这个例子的需求是，我们需要做一个可以移动的DIV，用户把这个DIV随意移动，但是他有时候可能误操作或者反悔了，想把这个DIV移动回去，也就是将状态回退到上一次，有了回退状态的需求，当然还有配对的前进状态的需求。这种类似的需求我们就可以用备忘录模式实现: function moveDiv() { this.states = []; // 一个数组记录所有状态 this.currentState = 0; // 一个变量记录当前状态位置 } // 移动方法，每次移动记录状态 moveDiv.prototype.move = function(type, num) { changeDiv(type, num); // 伪代码，移动DIV的具体操作，这里并未实现 // 记录本次操作到states里面去 this.states.push({type,num}); this.currentState = this.states.length - 1; // 改变当前状态指针 } // 前进方法，取出状态执行 moveDiv.prototype.forward = function() { // 如果当前不是最后一个状态 if(this.currentState 0) { // 取出后退的状态 this.currentState--; const state = this.states[this.currentState]; // 执行该状态位置 changeDiv(state.type, state.num); } } 上述代码通过一个数组将用户所有操作过的状态都记录下来了，用户可以随时在状态间进行前进和后退。 总结 本文讲的这几种设计模式策略/状态模式，外观模式，迭代器模式，备忘录模式都很好理解，而且在实际工作中也非常常见，熟练使用他们可以有效减少冗余代码，提高我们的代码质量。 策略模式通过将我们的if条件改写为一条条的策略减少了if...else的数量，看起来更清爽，扩展起来也更方便。状态模式跟策略模式很像，只是还多了一个状态，可以根据这个状态来选取具体的策略。 外观模式可能我们已经在无意间使用了，就是将模块一些内部逻辑封装在一个更高级的接口内部，或者将一些类似操作封装在一个方法内部，从而让外部调用更加方便。 迭代器模式在JS数组上有很多实现，我们也可以模仿他们做一下数据处理的工作，特别适合处理从API拿来的大量结构相似的数据。 备忘录模式就是加一个缓存对象，用来记录之前获取过的数据或者操作的状态，后面可以用来加快访问速度或者进行状态回滚。 还是那句话，设计模式的重点在于理解思想，实现方式可以多种多样。 本文是讲设计模式的最后一篇文章，前面三篇是: （500+赞！）不知道怎么封装代码？看看这几种设计模式吧！ （100+赞！)框架源码中用来提高扩展性的设计模式 不知道怎么提高代码复用性？看看这几种设计模式吧 "},"Articles/Architecture/Architecture.html":{"url":"Articles/Architecture/Architecture.html","title":"架构和源码","keywords":"","body":"这个章节主要包括如下内容： 从架构入手读源码 Underscore源码架构 "},"Articles/Architecture/readSourceCode.html":{"url":"Articles/Architecture/readSourceCode.html","title":"从架构入手读源码","keywords":"","body":"不知道有没有朋友有这种经历。雄心勃勃的打开一个开源框架的源码，开始看，一行一行的看下去，看了几行就感觉，“我艹，这什么玩意儿”，然后就看不下去了。如果你有类似的经历，可以看看本文，本文会以几个常见开源库为例讲解几种常见的开源框架的代码架构，从架构出发，帮你轻松读懂框架源码。记住以下两个要点： 不要试图一行一行的往下读 先找入口，再理架构，依流程读下去 jQuery 以jQuery为例，来看看他的基本架构，然后再来一步步看看这个是什么意思，如果大家能够打开代码跟着我一步步走下去，食用效果更佳： 找入口 我们这里用的版本是3.4.1, 我们用npm将jQuery下载下来，然后去node_modules里面找到他。 打开package.json，找到main属性，这个属性是我们程序引入它时查找的路径，通常就是程序的入口文件。如果没有这个属性，入口一般是目录下的index.js文件： \"main\": \"dist/jquery.js\", 理结构 我们打开dist/jquery.js，发现他有上万行代码，瞬间心里有点懵逼，但是不要怕！我们把最外层的函数都折叠起来，外层结构瞬间清晰了： （请忽略图上我的complexity插件。）这个外层结构不就是一个自执行函数吗？他往里面传了两个参数，一个是global，一个是factory。global很好理解，判断一下是不是浏览器，如果是浏览器就把window传进去，如果不是，就传this。这里有个技巧是将window作为参数传进去，而不是直接在函数内部去拿window，这是因为在里面拿会往上找一层才能拿到，会稍微慢一点。 第二个参数factory看名字是个工厂，我们展开上面的函数看看： 先是做了一些检测，兼容CommonJS和node.js，其实核心代码就一行： factory( global ); 将global作为参数调用了factory，看来jQuery真正的核心还是这个factory方法，他其实就是外面传进来的第二个参数，我们展开它，发现这个方法有一万行代码，果然是核心，这下又不知道怎么入手了。这时候想想我们使用jQuery的时候是怎么用的，我们都是直接用$就调用了，说明他肯定在window上挂载了一个$，直接在代码里面搜window.$，找到了： 这下我们找到了jQuery真正的对象jQuery，这里可以直接通过编辑器跳转到定义，发现jQuery也是一个很简单的方法. 这个方法直接调用了jQuery.fn.init,这个方法也可以直接在文件里面搜到，我们发现他支持几种selector: 字符串，DOM元素和方法，如果展开他们，你会发现他们都是根据selector去把匹配的结果挂载到this上，然后返回this。如果传入的selector不是支持的类型，他会调用jQuery.makeArray造一个类数组结构挂载在this上，然后返回this。那这时候的this指向谁呢？回到前面图片的代码return new jQuery.fn.init( selector, context );,他是通过new关键字来调用的jQuery.fn.init，那这里面this就指向new出来的实例对象，这个实例对象又作为返回值被jQuery方法返回出去了，成为了我们平时调用$('selector')所拿到的返回值。 那我们平时使用的$('selector').first()和$.ajax又是怎么实现的呢，似乎整个调用流程都没看到这些方法呢。这要回到我们前面jQuery.fn.init，我们发现在init前面还有一个fn，那这个fn是什么东西呢？我们可以直接搜索\"jQuery.fn =\"，看看他在哪里定义的： 瞬间恍然大悟，原来jQuery.fn就是jQuery.prototype，展开他我们就找到了first方法。但是这个是jQuery的实例对象才会继承的方法，我们返回的并不是new jQuery()，而是new jQuery.fn.init。为什么在这个实例里面也能拿到jQuery的原型对象呢？原来在jQuery.fn.init函数定义下面我们还发现了一行代码： 这行代码将jQuery.fn也就是jQuery.prototype又赋值给了jQuery.fn.init.prototype。这就实现了我们通过new jQuery.fn.init()拿到的实例对象，也就是jQuery()返回的对象能够访问到jQuery.prototype上的对象。这就是$('selector').first()的挂载机制。 看到这里是不是感觉有点绕，绕了一圈在jQuery()方法里面其实就是返回了一个jQuery实例嘛，为什么不直接返回new jQuery()呢？比如这样： function jQuery() { return new jQuery(); } window.$ = jQuery; // 使用时 const instance = $(); 上述代码其实有很明显的问题，在构造函数里面又new了一个自身，又会去调用构造函数，构造函数又new一个自身。。。这就死循环了！所以要new另外一个方法，然后将这个方法的原型跟jQuery的原型连接起来，让代码在事实上返回一个jQuery的实例对象。 那$.ajax又是怎么挂载的呢？我们直接在代码里面搜ajax，我们发现他包在了jQuery.extend的参数里面： 那jQuery.extend是我们必须要看的方法： 还好这个方法并没有太多的外部调用，仔细阅读下我们发现了他的功能其实就是一个拷贝： 将传入的对象拷贝到target上 如果没传target，target就是this，也就是调用者jQuery或者jQuery.fn 还有一个可选参数是deep，来控制他是否需要递归拷贝 所以前面的ajax方法就是直接拷贝到了jQuery上成为了他的一个静态方法。网上经常看到有人问，jQuery.extend和jQuery.fn.extend有啥区别。这下看了源码就清清楚楚了，jQuery.extend就是将对象拷贝到jQuery上，成为静态方法，可以直接通过类似$.ajax调用，jQuery.fn.extend就是拷贝到原型链上成为实例方法，通过$('selector').first()这样调用。实例方法一般是用来对jQuery实例，也就是selector对应的DOM进行操作，比如删除，插入，查找，修改样式等。静态方法一般用于不涉及jQuery实例的操作，比如ajax请求，浏览器检测，数组合并等，这些跟具体某个DOM元素没关系，所以直接挂载在jQuery上成为静态方法。 通过上面的的一系列的顺藤摸瓜，其实我们已经知道了jQuery的基本架构了，包括他的实例化，实例方法的挂载，静态方法的挂载，以及jQuery.fn，jQuery.fn.init，jQuery.prototype之间的关系。画下来就是最开始那张图： 有了这张图，我们再去读里面具体的方法心里就更有谱了。这里主要讲怎么入手，怎么理清架构，其他具体的方法篇幅有限这里就不展开了。整个过程中我们可以看到jQuery大量运用了prototype，如果你对prototype还不是很了解可能会看得云里雾里，那可以先看看我这篇讲prototype的文章。 框架套路 从前面jQuery的讲解我们可以看出来，每次你调用$(selector)的时候，jQuery都会返回一个selector对应的实例给你，这其实就是工厂模式。就相当于有一个工厂，你告诉他你要一双鞋子(selector=鞋子)，他就生产一双鞋子给你，你要一双袜子(selector=袜子)，他就生产一双袜子给你。总结起来，开源框架主要有如下几种模式： 工厂模式，比如 jQuery，Zepto 建造者模式，比如vue 2.0，express 函数式，比如loadsh-es 工厂模式：jQuery和Zepto 工厂模式就是我们前面讲的jQuery的模式，你传一个selector，给你返回一个对应的实例对象。工厂模式的一个典型特征是会往window上挂载一个工厂方法，这个方法会返回一个对应的实例对象给你。这种模式的一个好处是使用者不用使用new就能拿到一个实例对象，这个new的调用是框架里面实现了，直接返回给调用者一个new好了的实例，对于需要频繁拿多个实例的框架来说，使用起来更方便。 Zepto是一个跟jQuery很类似的框架，架构也是类似的，我们完全可以按照前面jQuery的思路整理出他的架构。具体流程我就不写了，大家可以根据实例化流程图梳理出来，下面画出我整理的结构图。 从上图可以看出当我们实例化一个Zepto的时候，实际返回的是new Z()的一个实例对象，又因为Z.prototype = $.fn，所以这个实例对象可以访问$.fn上的方法。Zepto跟jQuery最大的区别是扩展实例方法和静态方法的方式不一样。jQuery是通过$.fn.extend和$.extend来做的，而Zepto是通过自执行函数，将Zepto作为参数传进去，然后在自执行函数里面直接对$和$.fn添加属性来实现的。 Zepto扩展实例方法 下图是Zepto 1.2.0的代码截图： 可以看到这个自执行函数将Zepto作为参数传进去了，这个Zepto就是window.Zepto，也就是window.$，然后serialize等方法是直接添加到了$.fn上，也就是Z.prototype上，这样我们new Z()得到的实例对象就能访问serialize方法了。 Zepto扩展静态方法 还是来一张代码截图，下图我只保留了核心代码： 上图可以看出，静态方法的扩展跟实例方法类似，也是一个自执行函数，直接将方法添加到了$上。 其实Zepto也有$.extend方法: 从源码可以看出，$.extend只是将一个对象拷贝到target上，并没有jQuery中默认拷贝到this的功能。所以这个这个extend如果要拿来做扩展，应该这么写： ;(function($){ $.extend($.fn, { foo: function(){ // `this` refers to the current Zepto collection. // When possible, return the Zepto collection to allow chaining. return this.html('bar') } }) })(Zepto) 这也是官方文档的例子。 无论是jQuery的extend扩展方法还是Zepto的自执行方法扩展方法，他们其实都起到了同一个效果，那就是将各个模块分开独立了。每一个模块独立使用一个extend或者自执行函数，既方便了阅读，也方便了维护，不同模块可能是不同人开发的，通过这种方法可以将各个模块集成起来。将这个方式暴露出去，还可以让第三方开发者开发插件。 建造者模式：Vue 2.0 建造者模式暴露出来的是一个类，而不是一个工厂，使用的时候需要用户new一个实例出来。比如Vue(v 2.6.11)，我们在使用的时候就是new Vue()获得一个实例，拿来使用。打开Vue源码，发现他也是一个自执行方法，而且也有一个factory方法，但是这个方法并没有返回一个实例，而是返回了一个Vue方法，这也就是我们真正new的那个Vue。 这个Vue方法也很简单，只有一个必须通过new执行的检测，注意这里的this，如果你直接调用这个方法，那这个this指向调用者或者window，他就不是一个Vue的实例，会抛出警告。如果你通过new来调用，这个方法就成了构造函数，这个this就指向new出来的那个实例对象，这个检测就能通过，然后做一些初始化操作。 Vue的调用层级并没有jQuery和Zepto那么深，函数挂载方式也很明显。在Vue构造函数下面就有几行代码执行了几个mixin。 我们随便打开一个mixin看看，这个mixin其实就是在Vue.prototype上添加了相关的属性，实例方法也是通过这种方式添加上去的。注意有些地方使用了直接赋值，有些地方使用了Object.defineProperty，这是因为Object.defineProperty可以限制属性的修改，可以设置成只读的，具体可以看我这篇文章。 其实Vue也有一些静态方法，比如Vue.extend，这些方法也是直接添加到Vue上的，在源码里面有一个方法initGlobalAPI，这个方法里面就负责了静态方法的创建： 我们打开initExtend看看： 这个方法就直接把extend方法挂载到了Vue上成为了一个静态方法。 函数式：lodash-es 函数式其实就是一堆方法，然后组合使用这些方法来实现功能，也有很多框架是函数式的，比如lodash-es。原因主要有两个，一个是有一种理论是说，“组合大于继承”，如果继承层级过深，或者需要多重继承时，继承关系会比较混乱，后期维护也不方便。如果是不同函数组合完成功能的话，不需要用哪个函数，直接拿掉就行了。还有个比较现实的原因是tree-shaking，这是webpack自带的一个功能，他可以将没有使用的方法从最终生成的包里面拿掉，而只保留用到了的包。但是tree-shaking是基于export的，使用prototype继承或者class继承都没办法进行tree-shaking。考虑如下代码： function jquery() {} jquery.prototype.css = function() {} jquery.prototype.attr = function() {} 如果我们代码只用了css，而没有用attr，最终打包还是会将这两个方法都打包进去的。而如果换一种方法，换成函数式： export function css() {} export function attr() {} 上面的代码在打包时就只会打包css，而不会打包attr。 比较典型的函数式框架是lodash-es，注意是lodash-es，而不是lodash，lodash是比较老的版本，不能支持tree-shaking，因为它仍然是采用的往全局对象(window)上挂载一个复杂对象的方法。而lodash-es就是将单个方法export出来的方法，如果你使用时只import了部分方法，其他没用到的方法并不会打包进去。 总结 工厂模式适用于需要大量获取类似对象的场景，比如jQuery，我们在使用时可能需要获得很多dom的jQuery实例，工厂模式让使用者可以直接$(selector)这样用，而不需要new，使用起来更方便。 建造者模式适用于获取一个或少数几个复杂对象的场景，比如我们使用Vue时，一般一个应用只需要new一个实例就行了。 函数式一般适用于包含多个相互独立的方法的工具库，他们使用函数式可以减小最终包的体积。 通过本文的讲解，我们知道了，开源框架无非就这么几种架构。知道了一个框架的架构，我们就可以将一个复杂的框架进行庖丁解牛，将它分成一个一个的模块，再弄清楚各个模块是怎么通信的，就知道了他的蓝图，就再也不会有无从下手的感觉了。顺着不同的模块，我们可以一个一个将它读下去，读懂，那一个复杂框架的源码也就读懂了。 "},"Articles/Architecture/Undersocre.html":{"url":"Articles/Architecture/Undersocre.html","title":"Underscore源码架构","keywords":"","body":"Underscore.js是很有名的一个工具库，我也经常用他来处理对象，数组等，本文会深入解析Underscore源码架构，跟大家一起学习下他源码的亮点，然后模仿他写一个简单的架子来加深理解。他的源码通读下来，我觉得他的亮点主要有如下几点： 不需要new的构造函数 同时支持静态方法调用和实例方法调用 支持链式调用 外层是一个自执行函数 Underscore外层就是一个自执行函数，在自执行函数里面将_挂载到了window上。这是很多第三方库惯用的套路。如果你还不知道怎么入手看源码，不知道入口在哪里，或者看不懂他的外层结构，请看从架构入手轻松读懂框架源码：以jQuery，Zepto，Vue和lodash-es为例，这篇文章详细讲解了怎么入手看源码。本文主要讲解Underscore源码架构里面的亮点，怎么入手就不再赘述了。 不用new的构造函数 我们在使用第三方库的时候，经常需要先拿一个他们的实例，有些库需要用new来显式的调用，比如原生的Promise，有些库不需要new也可以拿到实例对象，比如jQuery。不用new就返回一个实例原生JS肯定是不支持的，有这些特性的库都是自己封装了一层的。不同的库在封装的时候也有不同的思路，下面我们来讲讲其中两种方案。 jQuery的方案 之前我在另一篇文章从架构入手轻松读懂框架源码：以jQuery，Zepto，Vue和lodash-es为例中详细讲解了jQuery是怎么实现不用new就返回一个实例的。另外还模仿jQuery的这种方案实现了我自己的一个工具库：学以致用：手把手教你撸一个工具库并打包发布，顺便解决JS小数计算不准问题。这里贴一段我工具库文章的代码简单回顾下这种方案： // 首先创建一个fc的函数，我们最终要返回的其实就是一个fc的实例 // 但是我们又不想让用户new，那么麻烦 // 所以我们要在构造函数里面给他new好这个实例，直接返回 function FractionCalculator(numStr, denominator) { // 我们new的其实是fc.fn.init return new FractionCalculator.fn.init(numStr, denominator); } // fc.fn其实就是fc的原型，算是个简写，所有实例都会拥有这上面的方法 FractionCalculator.fn = FractionCalculator.prototype = {}; // 这个其实才是真正的构造函数，这个构造函数也很简单，就是将传入的参数转化为分数 // 然后将转化的分数挂载到this上，这里的this其实就是返回的实例 FractionCalculator.fn.init = function(numStr, denominator) { this.fraction = FractionCalculator.getFraction(numStr, denominator); }; // 前面new的是init，其实返回的是init的实例 // 为了让返回的实例能够访问到fc的方法，将init的原型指向fc的原型 FractionCalculator.fn.init.prototype = FractionCalculator.fn; // 调用的时候就不用new了，直接调用就行 FractionCalculator(); Underscore的方案 jQuery的方案是在构造函数里面new了另外一个对象，然后将这个对象的原型指向jQuery的原型，以便返回的实例能够访问jQuery的实例方法。目的是能够达到的，但是方案显得比较冗长，Underscore的方案就简洁多了： function _(){ if(!(this instanceof _)) { return new _(); } } // 调用的时候直接_()就可以拿到实例对象 const instance = _(); console.log(instance); 上面代码的输出是: 可以看到constructor指向的是_()，说明这真的是一个_的实例，我们来分析下代码执行流程： 调用_()，里面的this指向外层的作用域，我们这里是window，因为window不是_的实例，会走到if里面去。关于this指向，如果你还不是很明白，请看这篇文章。 if里面会调用new _()，这会拿到一个实例对象，并将这个对象return出去。new _()也会调到_()方法，但是因为使用new调用，里面的this指向的就是new出来的实例，所以if进不去，执行结束。 Underscore巧妙应用了this的指向，通过检测this的指向来判断你是new调用的还是普通调用的，如果是普通调用就帮你new一下再返回。 同时支持静态方法和实例方法 用过Underscore的朋友应该有注意到，对于同一个方法来说，Underscore既支持作为静态方法调用，也支持作为实例方法调用，下面是官方的例子： _.map([1, 2, 3], function(n){ return n * 2; }); // map作为静态方法调用 _([1, 2, 3]).map(function(n){ return n * 2; }); // map作为实例方法调用 当我们把方法作为静态方法调用的时候，需要处理的数据就是第一个参数；当把他作为实例方法调用的时候，待处理数据是作为参数传给构造函数的。下面我们来讲讲这是怎么实现的。 其实最简单的方法就是写两个函数，一个是静态方法，一个是实例方法。但是如果我们这样做了，这两个函数内部处理的逻辑其实是高度相似的，可能只是参数稍微有点不同而已。这肯定不是一个优雅的程序员应该做的。Underscore给出的方法就是所有方法先写成静态方法，然后用一个统一的函数来将所有的静态方法挂载到原型上，让他成为一个实例方法。我们试着一步一步的来实现下。 先写一个静态方法 我们先来写一个简单的map方法，将它挂载到_上成为静态方法： _.map = function(array, callback) { var result = []; var length = array.length; for(var i = 0; i 这个方法写完其实就可以直接用了，用上面那个例子调用如下： 映射成实例方法 在Underscore里面是用一个mixin方法来将静态方法映射到原型上的，mixin方法接收一个对象作为参数，然后将这个对象上的方法全部复制到原型上。具体流程如下： 取出参数里面的函数属性，将其塞入一个数组 遍历这个数组，将里面的每个项设置到原型上 设置原型的时候注意处理下实例方法和静态方法的参数 下面来看看代码： _.mixin = function(obj) { // 遍历obj里面的函数属性 _.each(_.functions(obj), function(item){ // 取出每个函数 var func = obj[item]; // 在原型上设置一个同名函数 _.prototype[item] = function() { // 注意这里，实例方法待处理数据是构造函数接收的参数，改造构造函数的代码在后面 // 这里将数据取出来作为静态方法的第一个参数 var value = this._wrapped; var args = [value]; // 将数据和其他参数放到一个数组里面，作为静态方法的参数 Array.prototype.push.apply(args, arguments); // 用处理好的参数来调用静态方法 var res = func.apply(this, args); // 将结果返回 return res; } }); } // 上面的mixin写好后不要忘了调用一下，将_自己作为参数传进去 _.mixin(_); // 构造函数需要接收处理的数据 // 并将它挂载到this上，这里的this是实例对象 function _(value){ if(!(this instanceof _)) { return new _(value); } this._wrapped = value; } 上面的_.mixin(_);调用之后就会将_上的静态方法全部映射到原型上，这样_()返回的实例也有了所有的静态方法，这就让_支持了两种调用方式。可能有朋友注意到，我们上面的代码还有each和functions两个辅助方法，我们也来实现下这两个方法: // functions就是取出对象上所有函数的名字，塞到一个数组里面返回 _.functions = function(obj){ var result = []; for(var key in obj) { if(typeof obj[key] === 'function'){ result.push(key); } } return result; } // each就是对一个数组进行遍历，每个都执行下callback _.each = function(array, callback){ var length = array.length; for(var i = 0; i mixin顺便支持插件 Underscore的mixin不仅让他支持了静态和实例方法两种调用方式，同时因为他自己也是_的一个静态方法，我们也是可以拿来用的。官方支持自定义插件就是用的这个方法，下面是官方例子： _.mixin({ capitalize: function(string) { return string.charAt(0).toUpperCase() + string.substring(1).toLowerCase(); } }); _(\"fabio\").capitalize(); // Fabio 其实我们前面写的那个mixin方法已经支持将自定义方法作为实例方法了，但是还差一点，还差静态方法，所以我们再加一行代码，同时将接收到的参数赋值给_就行了： _.mixin = function(obj) { _.each(_.functions(obj), function(item){ var func = obj[item]; // 注意这里，我们同时将这个方法赋值给_作为静态方法，这下就完全支持自定义插件了 _[item] = func; _.prototype[item] = function() { var value = this.value; var args = [value]; Array.prototype.push.apply(args, arguments); var res = func.apply(this, args); return res; } }); } 支持链式调用 链式调用也很常见，比如jQuery的点点点，我在另一篇文章学以致用：手把手教你撸一个工具库并打包发布，顺便解决JS小数计算不准问题详细讲解过这种实例方法的链式调用怎么实现，关键是每个实例方法计算完成后都返回当前实例，对于实例方法来说，当前实例就是this。这种方式也适用于Underscore，但是Underscore因为自身需求和API结构的原因，他的链式调用需要支持更多场景： Underscore的实例方法还支持直接调用返回结果，不能简单的返回实例 Underscore的静态方法也要支持链式调用 实例方法支持链式调用 我们一步一步来，先来解决实例方法支持链式调用的问题，我们前面已经实现了将静态方法映射成实例方法，前面实现的实例方法的返回值就是静态方法的返回值。为了实现链式调用，我们还需要实例方法计算完后还能够返回当前实例(也就是this)，所以我们需要一个依据来判断应该返回计算结果还是当前实例。这个依据在Underscore里面是要用户给的，也就是显式调用chain方法。依据我们的分析，chain应该很简单，给一个依据来判断实例方法应该返回啥，也就是给当前实例设置一个标志位: _.chain = function() { this._chain = true; return this; } chain就是这么简单，两行代码，然后我们的实例方法里面根据_chain来判断返回计算结果还是当前实例: _.mixin = function(obj) { _.each(_.functions(obj), function(item){ var func = obj[item]; _[item] = func; _.prototype[item] = function() { var value = this._wrapped; var args = [value]; Array.prototype.push.apply(args, arguments); var res = func.apply(this, args); // 检查链式调用标记，如果是链式调用 // 将数据挂载到实例上，返回实例 var isChain = this._chain; if(isChain) { // 注意如果方法是chain本身，不要更新_wrapped，不然_wrapped会被改为chain的返回值，也就是一个实例 // 这里有点丑，后面优化 if(item !== 'chain') { this._wrapped = res; } return this; } return res; } }); } 我们再来写个unique方法来验证下链式调用: _.unique = function(array){ var result = []; var length = array.length; for(var i = 0; i 试下链式调用: 我们发现结果是对的，但是输出的是一个实例，不是我们想要的，所以我们还要一个方法来输出真正的计算结果，这个方法只能挂在原型上，不能写成静态方法，不然还会走到我们的mixin，会返回实例： _.prototype.value = function() { return this._wrapped; } 再来试一下呢: 静态方法支持链式调用 静态方法也要支持链式调用，我们必须要让他的返回值也能够访问到实例方法才行。一般情况下静态方法的返回值是不能返回实例的，但是我们现在已经有了chain方法，我们直接让这个方法构造一个_实例返回就行了，上面的实例方法支持链式调用是利用了现成的实例，返回的this，但是如果chain返回一个新实例，也是兼容上面的，于是chain改为: _.chain = function(obj) { var instance = _(obj); instance._chain = true; return instance; } 这样我们的静态方法chain也可以链式调用了，数据跟其他静态方法一样作为参数传给chain: 优化代码 到这里我们的功能基本实现了，但是mixin函数还有需要优化的地方： var res = func.apply(this, args);这里的this指向的是当前实例，但是一个方法作为静态方法调用时，比如_.map()，方法里面的this指向的是_，所以这里应该改成_。之前这里传this是因为chain里面操作的是this，现在已经改成新建实例，就不用传this，所以改为正确的_。 对item进行了特异性判断，前面之所以这么做，也是因为chain里面操作的是this，所以在apply里面其实已经设置了this._chain为true，所以会走到if里面去，现在新建实例了，走到apply的时候，设置的其实是res._chain，所以不会进到if，要调下一个实例方法的时候，this._chain才会是true，所以这个if可以直接去掉了。 _.mixin = function(obj) { _.each(_.functions(obj), function(item){ var func = obj[item]; _[item] = func; _.prototype[item] = function() { var value = this._wrapped; var args = [value]; Array.prototype.push.apply(args, arguments); var res = func.apply(_, args); var isChain = this._chain; if(isChain) { // if(item !== 'chain') { this._wrapped = res; // } return this; } return res; } }); } Underscore里面还将isChain的判断单独提成了一个方法，我这里没这么做了，放在一起看着还直观点。 总结 本文主要讲解了Underscore源码的架构，并自己实现了一个简单的架子，部分变量名字和方法的具体实现可能不一样，但是原理是一样的。通过搭建这个简单的架子，其实我们学会了： 不用new构造实例对象 mixin怎么扩展静态方法到原型上 通过显式的调用chain来支持静态方法和实例方法的链式调用 "},"Articles/Engineering/Engineering.html":{"url":"Articles/Engineering/Engineering.html","title":"工程化","keywords":"","body":"本章节包括如下内容： 前端负责人/架构师职责 mono-repo + react 手写webpack webpack核心模块tapable用法 webpack核心模块tapable源码解析 "},"Articles/Engineering/leader.html":{"url":"Articles/Engineering/leader.html","title":"前端负责人/架构师职责","keywords":"","body":"本篇文章主要讲作为一个前端负责人应该具备什么知识，在公司应该担任什么样的角色。其实前端负责人除了应该具备普通程序猿应该有的知识和能力之外，还应该知道： 如何做架构设计。 如何定义公司的前端规范。 架构 既然前端负责人要做架构设计，那什么是架构呢？我们先来看看什么是程序？其实从工程的角度来说，一个程序就是能独立完成一系列功能的软件，他可能包含很多模块，各个模块之间以某种方式来交流，最终合作来完成这些功能。所以： 程序 = 模块 + 消息交流 根据程序的定义，我们很容易知道架构设计是干什么的了。架构设计就是划分出低耦合的模块，并高效的设计模块间的沟通。架构师需要从需求出发将系统分成多个模块，让这些模块能够高效，低耦合的工作。我们以一个具体的例子来讲解架构应该怎么拆解，假如我们有这样一个需求： 我们需要制作一个在线编辑器，需要能够调整字体大小和颜色，并且能够前进和后退。 我们分析一下这个需求，来看看需要几个模块。因为是编辑器，肯定需要一个能够写字的地方，其实就是一个DOM元素的初始化，在初始化的时候可能还需要接收一些用户参数。然后是调整字体大小和颜色，那我们还需要一个模块来控制显示的样式。最后还需要支持前进和后退，也就是状态管理。根据这么划分，那我们至少需要三个模块： DOM元素的初始化管理模块 样式控制器 状态管理器 我们尝试用这个划分来写一个简单的架构代码，只写结构，不实现具体代码： // DOM初始化 function initer(styleController, stateController) { this.styleController = styleController; this.stateController = stateController; this.dom = null; } initer.prototype.initConfig = function() {} // 初始化配置 initer.prototype.initDom = function(config) { // 初始化DOM const finalConfig = this.initConfig(config); // 合并用户配置，得到最终配置 // 使用finalConfig,生成this.dom，代码省略 // 给DOM绑定事件，各个模块在这里就是通过事件通信的 // 这里以改变颜色为例 this.dom.onClick = function() { this.styleController.adjustColor('red'); } } // 样式管理器 function styleController() { } styleController.prototype.adjustSize = function() {} // 调整字体大小 styleController.prototype.adjustColor = function() {} // 调整颜色 // 状态控制器 function stateController() { this.stateArr = []; // 存储状态 this.nowState = 0; // 当前状态 } stateController.prototype.addState = function() {} // 添加状态 stateController.prototype.backState = function() {} // 后退状态 stateController.prototype.forwardState = function() {} // 前进状态 // 需要一个整合的方法，这个方法才是最终暴露出去的方法 function writer(config) { this.styleController = new styleController(); this.stateController = new stateController(); this.initer = new initer(this.styleController, this.stateController); this.initer.initDom(config); // 使用用户配置初始化DOM } // 挂载到window，别人new一下就可以用了 window.writer = writer; 将一个程序分成多个模块，可以降低他们的耦合，可以方便以后的更改。比如现在要添加一个改变字体粗细的功能，只需要修改styleController，添加一个方法就行了，而不用修改其他模块。 一个完整架构既包括上面提的业务模块，也有一些支持的库，比如组件库，工具库，共用css。 组件库： 第三方通用库或者自己公司的UI库。使用自己的组件库，可以实现自己特定的功能，比如访问统计，还有可以复用，好维护等优点。 工具库：比如cookie处理，对象拷贝，token验证等模块 公用css：根据设计稿，将统一风格的css，比如颜色，字体大小，将这些提出来也利于后期的维护。 一个优秀的框架，比如jQuery，在架构上就分得很清晰，如下图所示，最下层都是一些支持的工具方法，中间是具体的实现，最上面才是他暴露出给外面用的业务API。 前面说的都是业务架构，一个架构师不仅仅要会做业务架构，还有个很重要的工作就是技术选型，决定用哪个框架，不用哪个框架，这要求架构师对多个框架都有了解才行。不一定每个都了解得非常深入，但是应该知道他的适用场景和优缺点。一个完整的宏观下沟如下图所示，前端架构主要关注业务架构和框架，因为编程语言，应用，操作系统并没有什么选择空间。 规范 前面讲了，架构的工作还有一部分是规范。这里的规范并不是指一纸空文，那并没有什么用。前端需要规范的主要包括以下3个方面： 代码风格 性能 工作流程 这一系列标准并不是写在纸上或者来个大佬人工监督就行，而是要做成自动化的。如果不遵守这些规范，代码就写不了，写了也提交不了。 代码风格 代码风格可以用eslint来自动检测，根据官方网站的指导，写一个配置文件就行。 性能 用户浏览器的性能也是可以监控的，这需要用到一个APIwindow.performance，每个浏览器都有这个。他里面包括了内存使用情况和响应时间情况，每次拿到这个数据都发送给服务器，就可以监控用户的性能了： 工作流程 工作流程我们可以在创建项目或者在项目里面添加文件时进行规范化限制，这可以使用自定义的cli实现。在Jenkins部署时，我们还可以跑一遍单元测试，如果单元测试没过，或者覆盖率不达标，可以直接让Jenkins报错。在git commit时，可以使用husky进行检测，检测不过，直接不能提交代码。 总结 简单总结下初，中，高级工程师之间的路线区别，如下： "},"Articles/Engineering/mono-repo.html":{"url":"Articles/Engineering/mono-repo.html","title":"mono-repo + react","keywords":"","body":"使用mono-repo实现跨项目组件共享 本文会分享一个我在实际工作中遇到的案例，从最开始的需求分析到项目搭建，以及最后落地的架构的整个过程。最终实现的效果是使用mono-repo实现了跨项目的组件共享。在本文中你可以看到： 从接到需求到深入分析并构建架构的整个思考过程。 mono-repo的简单介绍。 mono-repo适用的场景分析。 产出一个可以跨项目共享组件的项目架构。 本文产出的架构模板已经上传到GitHub，如果你刚好需要一个mono-repo + react的模板，直接clone下来吧：https://github.com/dennis-jiang/mono-repo-demo 需求 需求概况 是这么个情况，我还是在那家外企供职，不久前我们接到一个需求：要给外国的政府部门或者他的代理机构开发一个可以缴纳水电费，顺便还能卖卖可乐的网站。主要使用场景是市政厅之类的地方，类似这个样子： 这张图是我在网上随便找的某银行的图片，跟我们使用场景有点类似。他有个自助的ATM机，远处还有人工柜台。我们也会有自助机器，另外也会有人工柜台，这两个地方都可以交水电费，汽车罚款什么的，唯一有个区别是人工那里除了交各种账单，还可能会卖点东西，比如口渴了买个可乐，烟瘾犯了来包中华。 需求分析 上面只是个概况，要做下来还有很多东西需要细化，柜员使用的功能和客户自助使用的功能看起来差不多，细想下来区别还真不少： 无论是交账单还是卖可乐，我们都可以将它视为一个商品，既然卖商品那肯定有上架和下架的功能，也就是商品管理，这个肯定只能做在柜员端。 市政厅人员众多，也会有上下级关系，普通柜员可能没有权限上/下架，他可能只有售卖权限，上/下架可能需要经理才能操作，这意味着柜员界面还需要权限管理。 权限管理的基础肯定是用户管理，所以柜员界面需要做登陆和注册。 客户自助界面只能交账单不能卖可乐很好理解，因为是自助机，旁边无人值守，如果摆几瓶可乐，他可能会拿了可乐不付钱。 那客户自助交水电费需要登陆吗？不需要！跟国内差不多，只需要输入卡号和姓名等基本信息就可以查询到账单，然后线上信用卡就付了。所以客户界面不需要登陆和用户管理。 从上面这几点分析我们可以看出，柜员界面会多很多功能，包括商品管理，用户管理，权限管理等，而客户自助界面只能交账单，其他功能都没有。 原型设计 基于上面几点分析，我们的设计师很快设计了两个界面的原型。 这个是柜员界面的： 柜员界面看起来也很清爽，上面一个头部，左上角显示了当前机构的名称，右上角显示了当前用户的名字和设置入口。登陆/登出相关功能点击用户名可以看到，商品管理，用户管理需要点击设置按钮进行跳转。 这个是客户自助界面的： 这个是客户界面的，看起来基本是一样的，只是少了用户和设置那一块，卖的东西少了可乐，只能交账单。 技术 现在需求基本已经理清楚了，下面就该我们技术出马了，进行技术选型和架构落地。 一个站点还是两个站点？ 首先我们需要考虑的一个问题就是，柜员界面和客户界面是做在一个网站里面，还是单独做两个网站？因为两个界面高度相似，所以我们完全可以做在一起，在客户自助界面隐藏掉右上角的用户和设置就行了。 但是这里面其实还隐藏着一个问题：柜员界面是需要登陆的，所以他的入口其实是登陆页；客户界面不需要登陆，他的入口应该直接就是售卖页。如果将他们做在一起，因为不知道是柜员使用还是客户使用，所以入口只能都是登录页，柜员直接登陆进入售卖页，对于客户可以单独加一个“客户自助入口”让他进入客户的售卖页面。但是这样用户体验不好，客户本来不需要登陆的，你给他看一个登录页可能会造成困惑，可能需要频繁求教工作人员才知道怎么用，会降低整体的工作效率，所以产品经理并不接受这个，要求客户一进来就需要看到客户的售卖页面。 而且从技术角度考虑，现在我们是一个if...else...隐藏用户和设置就行了，那万一以后两个界面差异变大，客户界面要求更花哨的效果，就不是简单的一个if...else...能搞定的了。所以最后我们决定部署两个站点，柜员界面和客户界面单独部署到两个域名上。 组件重复 既然是两个站点，考虑到项目的可扩展性，我们创建了两个项目。但是这两个项目的UI在目前阶段是如此相似，如果我们写两套代码，势必会有很多组件是重复的，比较典型的就是上面的商品卡片，购物车组件等。其实除了上面可以看到这些会重复外，我们往深入想，交个水费，我们肯定还需要用户输入姓名，卡号之类的信息，所以点了水费的卡片后肯定会有一个输入信息的表单，而且这个表单在柜员界面和客户界面基本是一样的，除了水费表单外，还有电费表单，罚单表单等等，所以可以预见重复的组件会非常多。 作为一个有追求的工程师，这种重复组件肯定不能靠CV大法来解决，我们得想办法让这些组件可以复用。那组件怎么复用呢？提个公共组件库嘛，相信很多朋友都会这么想。我们也是这么想的，但是公共组件库有多种组织方式，我们主要考虑了这么几种： 单独NPM包 再创建一个项目，这个项目专门放这些可复用的组件，类似于我们平时用的antd之类的，创建好后发布到公司的私有NPM仓库上，使用的时候直接这样： import { Cart } from 'common-components'; 但是，我们需要复用的这些组件跟antd组件有一个本质上的区别：我们需要复用的是业务组件，而不是单纯的UI组件。antdUI组件库为了保证通用性，基本不带业务属性，样式也是开放的。但是我这里的业务组件不仅仅是几个按钮，几个输入框，而是一个完整的表单，包括前端验证逻辑都需要复用，所以我需要复用的组件其实是跟业务强绑定的。因为他是跟业务强绑定的，即使我将它作为一个单独的NPM包发布出去，公司的其他项目也用不了。一个不能被其他项目共享的NPM包，始终感觉有点违和呢。 git submodule 另一个方案是git submodule，我们照样为这些共享组件创建一个新的Git项目，但是不发布到NPM仓库去骚扰别人，而是直接在我们主项目以git submodule的方式引用他。git submodule的基本使用方法网上有很多，我这里就不啰嗦了，主要说几个缺点，也是我们没采用他的原因： 本质上submodule和主项目是两个不同的git repo，所以你需要为每个项目创建一套脚手架(代码规范，发布脚本什么的)。 submodule其实只是主项目保存了一个对子项目的依赖链接，说明了当前版本的主项目依赖哪个版本的子项目，你需要小心的使用git submodule update来管理这种依赖关系。如果没有正确使用git submodule update而搞乱了版本的依赖关系，那就呵呵了。。。 发布的时候需要自己小心处理依赖关系，先发子项目，子项目好了再发布主项目。 mono-repo mono-repo是现在越来越流行的一种项目管理方式了，与之相对的叫multi-repo。multi-repo就是多个仓库，上面的git submodule其实就是multi-repo的一种方式，主项目和子项目都是单独的git仓库，也就构成了多个仓库。而mono-repo就是一个大仓库，多个项目都放在一个git仓库里面。现在很多知名开源项目都是采用的mono-repo的组织方式，比如Babel，React ,Jest, create-react-app, react-router等等。mono-repo特别适合联系紧密的多个项目，比如本文面临的这种情况，下面我们就进入本文的主题，认真看下mono-repo。 mono-repo 其实我之前写react-router源码解析的时候就提到过mono-repo，当时就说有机会单独写一篇mono-repo的文章，本文也算是把坑填上了。所以我们先从react-router的源码结构入手，来看下mono-repo的整体情况，下图就是react-router的源码结构： 我们发现他有个packages文件夹，里面有四个项目： react-router：是React-Router的核心库，处理一些共用的逻辑 react-router-config：是React-Router的配置处理库 react-router-dom：浏览器上使用的库，会引用react-router核心库 react-router-native：支持React-Native的路由库，也会引用react-router核心库 这四个项目都是为react的路由管理服务的，在业务上有很强的关联性，完成一个功能可能需要多个项目配合才能完成。比如修某个BUG需要同时改react-router-dom和react-router的代码，如果他们在不同的Git仓库，需要在两个仓库里面分别修改，提交，打包，测试，然后还要修改彼此依赖的版本号才能正常工作。但是使用了mono-repo，因为他们代码都在同一个Git仓库，我们在一个commit里面就可以修改两个项目的代码，然后统一打包，测试，发布，如果我们使用了lerna管理工具，版本号的依赖也是自动更新的，实在是方便太多了。 lerna lerna是最知名的mono-repo的管理工具，今天我们就要用它来搭建前面提到的共享业务组件的项目，我们目标的项目结构是这个样子的： mono-repo-demo/ --- 主项目，这是一个Git仓库 package.json packages/ common/ --- 共享的业务组件 package.json admin-site/ --- 柜员网站项目 package.json customer-site/ --- 客户网站项目 package.json lerna init lerna初始化很简单，先创建一个空的文件夹，然后运行： npx lerna init 这行命令会帮我创建一个空的packages文件夹，一个package.json和lerna.json，整个结构长这样： package.json中有一点需要注意，他的private必须设置为true，因为mono-repo本身的这个Git仓库并不是一个项目，他是多个项目，所以他自己不能直接发布，发布的应该是packages/下面的各个子项目。 \"private\": true, lerna.json初始化长这样： { \"packages\": [ \"packages/*\" ], \"version\": \"0.0.0\" } packages字段就是标记你子项目的位置，默认就是packages/文件夹，他是一个数组，所以是支持多个不同位置的。另外一个需要特别注意的是version字段，这个字段有两个类型的值，一个是像上面的0.0.0这样一个具体版本号，还可以是independent这个关键字。如果是0.0.0这种具体版本号，那lerna管理的所有子项目都会有相同的版本号----0.0.0，如果你设置为independent，那各个子项目可以有自己的版本号，比如子项目1的版本号是0.0.0，子项目2的版本号可以是0.1.0。 创建子项目 现在我们的packages/目录是空的，根据我们前面的设想，我们需要创建三个项目： common：共享的业务组件，本身不需要运行，放各种组件就行了。 admin-site：柜员站点，需要能够运行，使用create-react-app创建吧 customer-site：客户站点，也需要运行，还是使用create-react-app创建 创建子项目可以使用lerna的命令来创建： lerna create 也可以自己手动创建文件夹，这里common子项目我就用lerna命令创建吧，lerna create common，运行后common文件夹就出现在packages下面了： 这个是使用lerna create默认生成的目录结构，__test__文件夹下面放得是单元测试内容，lib下面放得是代码。由于我是准备用它来放共享组件的，所以我把目录结构调整了，默认生成的两个文件夹都删了，新建了一个components文件夹： 另外两个可运行站点都用create-react-app创建了，在packages文件夹下运行： npx create-react-app admin-site; npx create-react-app customer-site; 几个项目都创建完后，整个项目结构是这样的： 按照mono-repo的惯例，这几个子项目的名称最好命名为@/，这样当别人引用你的时候，你的这几个项目都可以在node_modules的同一个目录下面，目录名字就是@，所以我们手动改下三个子项目package.json里面的name为： @mono-repo-demo/admin-site @mono-repo-demo/common @mono-repo-demo/customer-site lerna bootstrap 上面的图片可以看到，packages/下面的每个子项目有自己的node_modules，如果将它打开，会发现很多重复的依赖包，这会占用我们大量的硬盘空间。lerna提供了另一个强大的功能：将子项目的依赖包都提取到最顶层，我们只需要先删除子项目的node_modules再跑下面这行命令就行了： lerna bootstrap --hoist 删除已经安装的子项目node_modules可以手动删，也可以用这个命令： lerna clean yarn workspace lerna bootstrap --hoist虽然可以将子项目的依赖提升到顶层，但是他的方式比较粗暴：先在每个子项目运行npm install，等所有依赖都安装好后，将他们移动到顶层的node_modules。这会导致一个问题，如果多个子项目依赖同一个第三方库，但是需求的版本不同怎么办？比如我们三个子项目都依赖antd，但是他们的版本不完全一样： // admin-site \"antd\": \"3.1.0\" // customer-site \"antd\": \"3.1.0\" // common \"antd\": \"4.9.4\" 这个例子中admin-site和customer-site需要的antd版本都是3.1.0，但是common需要的版本却是4.9.4，如果使用lerna bootstrap --hoist来进行提升，lerna会提升用的最多的版本，也就是3.1.0到顶层，然后把子项目的node_modules里面的antd都删了。也就是说common去访问antd的话，也会拿到3.1.0的版本，这可能会导致common项目工作不正常。 这时候就需要介绍yarn workspace 了，他可以解决前面说的版本不一致的问题，lerna bootstrap --hoist会把所有子项目用的最多的版本移动到顶层，而yarn workspace 则会检查每个子项目里面依赖及其版本，如果版本不一样则会留在子项目自己的node_modules里面，只有完全一样的依赖才会提升到顶层。 还是以上面这个antd为例，使用yarn workspace的话，会把admin-site和customer-site的3.1.0版本移动到顶层，而common项目下会保留自己4.9.4的antd，这样每个子项目都可以拿到自己需要的依赖了。 yarn workspace使用也很简单，yarn 1.0以上的版本默认就是开启workspace的，所以我们只需要在顶层的package.json加一个配置就行： // 顶层package.json { \"workspaces\": [ \"packages/*\" ] } 然后在lerna.json里面指定npmClient为yarn，并将useWorkspaces设置为true： // lerna.json { \"npmClient\": \"yarn\", \"useWorkspaces\": true } 使用了yarn workspace，我们就不用lerna bootstrap来安装依赖了，而是像以前一样yarn install就行了，他会自动帮我们提升依赖，这里的yarn install无论在顶层运行还是在任意一个子项目运行效果都是一样的。 启动子项目 现在我们建好了三个子项目，要启动CRA子项目，可以去那个目录下运行yarn start，但是频繁切换文件夹实在是太麻烦了。其实有了lerna的帮助我们可以直接在顶层运行，这需要用到lerna的这个功能： lerna run [script] 比如我们在顶层运行了lerna run start，这相当于去每个子项目下面都去执行yarn run start或者npm run start，具体是yarn还是npm，取决于你在lerna.json里面的这个设置： \"npmClient\": \"yarn\" 如果我只想在其中一个子项目运行命令，应该怎么办呢？加上--scope就行了，比如我就在顶层的package.json里面加了这么一行命令： // 顶层package.json { \"scripts\": { \"start:aSite\": \"lerna --scope @mono-repo-demo/admin-site run start\" } } 所以我们可以直接在顶层运行yarn start:aSite，这会启动前面说的管理员站点，他其实运行的命令还是lerna run start，然后加了--scope来指定在管理员子项目下运行，@mono-repo-demo/admin-site就是我们管理员子项目的名字，是定义在这个子项目的package.json里面的： // 管理员子项目package.json { \"name\": \"@mono-repo-demo/admin-site\" } 然后我们实际运行下yarn start:aSite吧： 看到了我们熟悉的CRA转圈圈，说明到目前为止我们的配置还算顺利，哈哈~ 创建公共组件 现在项目基本结构已经有了，我们建一个公共组件试一下效果。我们就用antd创建一个交水费的表单吧，也很简单，就一个姓名输入框，一个查询按钮。 // packages/common/components/WaterForm.js import { Form, Input, Button } from 'antd'; const layout = { labelCol: { span: 8, }, wrapperCol: { span: 16, }, }; const tailLayout = { wrapperCol: { offset: 8, span: 16, }, }; const WaterForm = () => { const onFinish = (values) => { console.log('Success:', values); }; const onFinishFailed = (errorInfo) => { console.log('Failed:', errorInfo); }; return ( 查询 ); }; export default WaterForm; 引入公共组件 这个组件写好了，我们就在admin-site里面引用下他，要引用上面的组件，我们需要先在admin-site的package.json里面将这个依赖加上，我们可以去手动修改他，也可以使用lerna命令： lerna add @mono-repo-demo/common --scope @mono-repo-demo/admin-site 这个命令效果跟你手动改package.json是一样的： 然后我们去把admin-site默认的CRA圈圈改成这个水费表单吧： 然后再运行下： 嗯？报错了。。。如果我说这个错误是我预料之中的，你信吗😜 共享脚手架 仔细看下上面的错误，是报在WaterForm这个组件里面的，错误信息是说：jsx语法不支持，最后两行还给了个建议，叫我们引入babel来编译。这些都说明了一个同问题：babel的配置对common子项目没有生效。这其实是预料之中的，我们的admin-site之所以能跑起来是因为CRA帮我们配置好了这些脚手架，而common这个子项目并没有配置这些脚手架，自然编译不了。 我们这几个子项目都是React的，其实都可以共用一套脚手架，所以我的方案是：将CRA的脚手架全部eject出来，然后手动挪到顶层，让三个子项目共享。 首先我们到admin-site下面运行： yarn eject 这个命令会将CRA的config文件夹和scripts文件夹弹出来，同时将他们的依赖添加到admin-site的package.json里面。所以我们要干的就是手动将config文件夹和scripts文件夹移动到顶层，然后将CRA添加到package.json的依赖也移到最顶层，具体CRA改了package.json里面的哪些内容可以通过git看出来的。移动过后的项目结构长这样： 注意CRA项目的启动脚本在scripts文件夹里面，所以我们需要稍微修改下admin-site的启动命令： // admin-site package.json { \"scripts\": \"node ../../scripts/start.js\", } 现在我们使用yarn start:aSite仍然会报错，所以我们继续修改babel的设置。 首先在config/paths里面添加上我们packages的路径并export出去： 然后修改webpacka配置，在babel-loader的include路径里面添加上这个路径： 现在再运行下我们的项目就正常了： 最后别忘了，还有我们的customer-site哦，这个处理起来就简单了，因为前面我们已经调好了整个主项目的结构，我们可以将customer-site的其他依赖都删了，只保留@mono-repo-demo/common，然后调整下启动脚本就行了： 这样客户站点也可以引入公共组件并启动了。 发布 最后要注意的一点是，当我们修改完成后，需要发布了，一定要使用lerna publish，他会自动帮我更新依赖的版本号。比如我现在稍微修改了一下水费表单，然后提交： 现在我试着发布一下，运行 lerna publish 运行后，他会让你选择新的版本号： 我这里选择一个minor，也就是版本号从0.0.0变成0.1.0,然后lerna会自动更新相关的依赖版本，包括： lerna.json自己版本号升为0.1.0： common的版本号变为0.1.0： admin-site的版本号也变为0.1.0，同时更新依赖的common为0.1.0： customer-site的变化跟admin-site是一样的。 independent version 上面这种发布策略，我们修改了common的版本，admin-site的版本也变成了一样的，按理来说，这个不是必须的，admin-site只是更新依赖的common版本，自己的版本不一定是升级一个minor，也许只是一个patch。这种情况下，admin-site的版本要不要跟着变，取决于lerna.json里面的version配置，前面说过了，如果它是一个固定的指，那所有子项目版本会保持一致，所以admin-site版本会跟着变，我们将它改成independent就会不一样了。 // lerna.json { \"version\": \"independent\" } 然后我再改下common再发布试试： 在运行下lerna publish，我们发现他会让你自己一个一个来选子项目的版本，我这里就可以选择将common升级为0.2.0，而admin-site只是依赖变了，就可以升级为0.1.1: 具体采用哪种策略，是每个子项目版本都保持一致还是各自版本独立，大家可以根据自己的项目情况决定。 总结 这个mono-repo工程我已经把代码清理了一下，上传到了GitHub，如果你刚好需要一个mono-repo + react的项目模板，直接clone吧：https://github.com/dennis-jiang/mono-repo-demo 下面我们再来回顾下本文的要点： 事情的起源是我们接到了一个外国人交水电费并能卖东西的需求，有柜员端和客户自助端。 经过分析，我们决定将柜员端和客户自助端部署为两个站点。 为了这两个站点，我们新建了两个项目，这样扩展性更好。 这两个项目有很多长得一样的业务组件，我们需要复用他们。 为了复用这些业务组件，我们引入了mono-repo的架构来进行项目管理，mono-repo特别适合联系紧密的多个项目。 mono-repo最出名的工具是lerna。 lerna可以自动管理各个项目之间的依赖以及node_modules。 使用lerna bootstrap --hoist可以将子项目的node_modules提升到顶层，解决node_modules重复的问题。 但是lerna bootstrap --hoist在提升时如果遇到各个子项目引用的依赖版本不一致，会提升使用最多的版本，从而导致少数派那个找不到正确的依赖，发生错误。 为了解决提升时版本冲突的问题，我们引入了yarn workspace，他也会提升用的最多的版本，但是会为少数派保留自己的依赖在自己的node_modules下面。 我们示例中两个CRA项目都有自己的脚手架，而common没有脚手架，我们调整了脚手架，将它挪到了最顶层，从而三个项目可以共享。 发布的时候使用lerna publish，他会自动更新内部依赖，并更新各个子项目自己的版本号。 子项目的版本号规则可以在lerna.json里面配置，如果配置为固定版本号，则各个子项目保持一致的版本，如果配置为independent关键字，各个子项目可以有自己不同的版本号。 参考资料 Lerna官网：https://lerna.js.org/ Yarn workspace: https://classic.yarnpkg.com/en/docs/workspaces/ "},"Articles/Engineering/mini-webpack.html":{"url":"Articles/Engineering/mini-webpack.html","title":"手写webpack","keywords":"","body":"手写一个webpack，看看AST怎么用 本文开始我会围绕webpack和babel写一系列的工程化文章，这两个工具我虽然天天用，但是对他们的原理理解的其实不是很深入，写这些文章的过程其实也是我深入学习的过程。由于webpack和babel的体系太大，知识点众多，不可能一篇文章囊括所有知识点，目前我的计划是从简单入手，先实现一个最简单的可以运行的webpack，然后再看看plugin, loader和tree shaking等功能。目前我计划会有这些文章： 手写最简webpack，也就是本文 webpack的plugin实现原理 webpack的loader实现原理 webpack的tree shaking实现原理 webpack的HMR实现原理 babel和ast原理 所有文章都是原理或者源码解析，欢迎关注~ 注意：本文主要讲webpack原理，在实现时并不严谨，而且只处理了import和export的default情况，如果你想在生产环境使用，请自己添加其他情况的处理和边界判断。 为什么要用webpack 笔者刚开始做前端时，其实不知道什么webpack，也不懂模块化，都是html里面直接写script，引入jquery直接干。所以如果一个页面的JS需要依赖jquery和lodash，那html可能就长这样： 这样写会导致几个问题： 单独看index.js不能清晰的找到他到底依赖哪些外部库 script的顺序必须写正确，如果错了就会导致找不到依赖，直接报错 模块间通信困难，基本都靠往window上注入变量来暴露给外部 浏览器严格按照script标签来下载代码，有些没用到的代码也会下载下来 当前端规模变大，JS脚本会显得很杂乱，项目管理混乱 webpack的一个最基本的功能就是来解决上述的情况，允许在JS里面通过import或者require等关键字来显式申明依赖，可以引用第三方库，自己的JS代码间也可以相互引用，这样在实质上就实现了前端代码的模块化。由于历史问题，老版的JS并没有自己模块管理方案，所以社区提出了很多模块管理方案，比如ES2015的import，CommonJS的require，另外还有AMD，CMD等等。就目前我见到的情况来说，import因为已经成为ES2015标准，所以在客户端广泛使用，而require是Node.js的自带模块管理机制，也有很广泛的用途，而AMD和CMD的使用已经很少见了。 但是webpack作为一个开放的模块化工具，他是支持ES6，CommonJS和AMD等多种标准的，不同的模块化标准有不同的解析方法，本文只会讲ES6标准的import方案，这也是客户端JS使用最多的方案。 简单例子 按照业界惯例，我也用hello world作为一个简单的例子，但是我将这句话拆成了几部分，放到了不同的文件里面。 先来建一个hello.js，只导出一个简单的字符串： const hello = 'hello'; export default hello; 然后再来一个helloWorld.js，将hello和world拼成一句话，并导出拼接的这个方法： import hello from './hello'; const world = 'world'; const helloWorld = () => `${hello} ${world}`; export default helloWorld; 最后再来个index.js，将拼好的hello world插入到页面上去： import helloWorld from \"./helloWorld\"; const helloWorldStr = helloWorld(); function component() { const element = document.createElement(\"div\"); element.innerHTML = helloWorldStr; return element; } document.body.appendChild(component()); 现在如果你直接在html里面引用index.js是不能运行成功的，因为大部分浏览器都不支持import这种模块导入。而webpack就是来解决这个问题的，它会将我们模块化的代码转换成浏览器认识的普通JS来执行。 引入webpack 我们印象中webpack的配置很多，很麻烦，但那是因为我们需要开启的功能很多，如果只是解析转换import，配置起来非常简单。因为从webpack 2开始，就默认支持import了，不需要额外导入babel-loader之类的，当然如果你需要使用更高级的ES6+语法，还是需要导入babel-loader的。 先把依赖装上吧，这没什么好说的： // package.json { \"devDependencies\": { \"webpack\": \"^5.4.0\", \"webpack-cli\": \"^4.2.0\" }, } 为了使用方便，再加个build脚本吧： // package.json { \"scripts\": { \"build\": \"webpack\" }, } 最后再简单写下webpack的配置文件就好了： // webpack.config.js const path = require(\"path\"); module.exports = { mode: \"development\", devtool: 'source-map', entry: \"./src/index.js\", output: { filename: \"main.js\", path: path.resolve(__dirname, \"dist\"), }, }; 这个配置文件里面其实只要指定了入口文件entry和编译后的输出文件目录output就可以正常工作了，这里这个配置的意思是让webpack从./src/index.js开始编译，编译后的文件输出到dist/main.js这个文件里面。 这个配置文件上还有两个配置mode和devtool只是我用来方便调试编译后的代码的，mode指定用哪种模式编译，默认是production，会对代码进行压缩和混淆，不好读，所以我设置为development；而devtool是用来控制生成哪种粒度的source map，简单来说，想要更好调试，就要更好的，更清晰的source map，但是编译速度变慢；反之，想要编译速度快，就要选择粒度更粗，更不好读的source map，webpack提供了很多可供选择的source map，具体的可以看他的文档。 然后就可以在dist下面建个index.html来引用编译后的代码了： // index.html 运行下yarn build就会编译我们的代码，然后打开index.html就可以看到效果了。 深入原理 前面讲的这个例子很简单，一般也满足不了我们实际工程中的需求，但是对于我们理解原理却是一个很好的突破口，毕竟webpack这么庞大的一个体系，我们也不能一口吃个胖子，得一点一点来。 webpack把代码编译成了啥？ 为了弄懂他的原理，我们可以直接从编译后的代码入手，先看看他长啥样子，有的朋友可能一提到去看源码，心理就没底，其实我以前也是这样的。但是完全没有必要惧怕，他编译后的代码浏览器能够执行，那肯定就是普通的JS代码，不会藏着这么黑科技。 下面是编译完的代码截图： 虽然我们只有三个简单的JS文件，但是加上webpack自己的逻辑，编译后的文件还是有一百多行代码，所以即使我把具体逻辑折叠起来了，这个截图还是有点长，为了能够看清楚他的结构，我将它分成了4个部分，标记在了截图上，下面我们分别来看看这几个部分吧。 第一部分其实就是一个对象__webpack_modules__，这个对象里面有三个属性，属性名字是我们三个模块的文件路径，属性的值是一个函数，我们随便展开一个./src/helloWorld.js看下： 我们发现这个代码内容跟我们自己写的helloWorld.js非常像： 他只是在我们的代码前先调用了__webpack_require__.r和__webpack_require__.d，这两个辅助函数我们在后面会看到。 然后对我们的代码进行了一点修改，将我们的import关键字改成了__webpack_require__函数，并用一个变量_hello__WEBPACK_IMPORTED_MODULE_0__来接收了import进来的内容，后面引用的地方也改成了这个，其他跟这个无关的代码，比如const world = 'world';还是保持原样的。 这个__webpack_modules__对象存了所有的模块代码，其实对于模块代码的保存，在不同版本的webpack里面实现的方式并不一样，我这个版本是5.4.0，在4.x的版本里面好像是作为数组存下来，然后在最外层的立即执行函数里面以参数的形式传进来的。但是不管是哪种方式，都只是转换然后保存一下模块代码而已。 第二块代码的核心是__webpack_require__，这个代码展开，瞬间给了我一种熟悉感： 来看一下这个流程吧： 先定义一个变量__webpack_module_cache__作为加载了的模块的缓存 __webpack_require__其实就是用来加载模块的 加载模块时，先检查缓存中有没有，如果有，就直接返回缓存 如果缓存没有，就从__webpack_modules__将对应的模块取出来执行 __webpack_modules__就是上面第一块代码里的那个对象，取出的模块其实就是我们自己写的代码，取出执行的也是我们每个模块的代码 每个模块执行除了执行我们的逻辑外，还会将export的内容添加到module.exports上，这就是前面说的__webpack_require__.d辅助方法的作用。添加到module.exports上其实就是添加到了__webpack_module_cache__缓存上，后面再引用这个模块就直接从缓存拿了。 这个流程我太熟悉了，因为他简直跟Node.js的CommonJS实现思路一模一样，具体的可以看我之前写的这篇文章：深入Node.js的模块加载机制，手写require函数。 第三块代码其实就是我们前面看到过的几个辅助函数的定义，具体干啥的，其实他的注释已经写了： __webpack_require__.d：核心其实是Object.defineProperty，主要是用来将我们模块导出的内容添加到全局的__webpack_module_cache__缓存上。 __webpack_require__.o：其实就是Object.prototype.hasOwnProperty的一个简写而已。 __webpack_require__.r：这个方法就是给每个模块添加一个属性__esModule，来表明他是一个ES6的模块。 第四块就一行代码，调用__webpack_require__加载入口模块，启动执行。 这样我们将代码分成了4块，每块的作用都搞清楚，其实webpack干的事情就清晰了： 将import这种浏览器不认识的关键字替换成了__webpack_require__函数调用。 __webpack_require__在实现时采用了类似CommonJS的模块思想。 一个文件就是一个模块，对应模块缓存上的一个对象。 当模块代码执行时，会将export的内容添加到这个模块对象上。 当再次引用一个以前引用过的模块时，会直接从缓存上读取模块。 自己实现一个webpack 现在webpack到底干了什么事情我们已经清楚了，接下来我们就可以自己动手实现一个了。根据前面最终生成的代码结果，我们要实现的代码其实主要分两块： 遍历所有模块，将每个模块代码读取出来，替换掉import和export关键字，放到__webpack_modules__对象上。 整个代码里面除了__webpack_modules__和最后启动的入口是变化的，其他代码，像__webpack_require__，__webpack_require__.r这些方法其实都是固定的，整个代码结构也是固定的，所以完全可以先定义好一个模板。 使用AST解析代码 由于我们需要将import这种代码转换成浏览器能识别的普通JS代码，所以我们首先要能够将代码解析出来。在解析代码的时候，可以将它读出来当成字符串替换，也可以使用更专业的AST来解析。AST全称叫Abstract Syntax Trees，也就是抽象语法树，是一个将代码用树来表示的数据结构，一个代码可以转换成AST，AST又可以转换成代码，而我们熟知的babel其实就可以做这个工作。要生成AST很复杂，涉及到编译原理，但是如果仅仅拿来用就比较简单了，本文就先不涉及复杂的编译原理，而是直接将babel生成好的AST拿来使用。 注意：webpack源码解析AST并不是使用的babel，而是使用的acorn。webpack自己实现了一个JavascriptParser类，这个类里面用到了acorn。本文写作时采用了babel，这也是一个大家更熟悉的工具。 比如我先将入口文件读出来，然后用babel转换成AST可以直接这样写： const fs = require(\"fs\"); const parser = require(\"@babel/parser\"); const config = require(\"../webpack.config\"); // 引入配置文件 // 读取入口文件 const fileContent = fs.readFileSync(config.entry, \"utf-8\"); // 使用babel parser解析AST const ast = parser.parse(fileContent, { sourceType: \"module\" }); console.log(ast); // 把ast打印出来看看 上面代码可以将生成好的ast打印在控制台： 这虽然是一个完整的AST，但是看起来并不清晰，关键数据其实是body字段，这里的body也只是展示了类型名字。所以照着这个写代码其实不好写，这里推荐一个在线工具https://astexplorer.net/，可以很清楚的看到每个节点的内容： 从这个解析出来的AST我们可以看到，body主要有4块代码： ImportDeclaration：就是第一行的import定义 VariableDeclaration：第三行的一个变量申明 FunctionDeclaration：第五行的一个函数定义 ExpressionStatement：第十三行的一个普通语句 你如果把每个节点展开，会发现他们下面又嵌套了很多其他节点，比如第三行的VariableDeclaration展开后，其实还有个函数调用helloWorld()： 使用traverse遍历AST 对于这样一个生成好的AST，我们可以使用@babel/traverse来对他进行遍历和操作，比如我想拿到ImportDeclaration进行操作，就直接这样写： // 使用babel traverse来遍历ast上的节点 traverse(ast, { ImportDeclaration(path) { console.log(path.node); }, }); 上面代码可以拿到所有的import语句： 将import转换为函数调用 前面我们说了，我们的目标是将ES6的import： import helloWorld from \"./helloWorld\"; 转换成普通浏览器能识别的函数调用： var _helloWorld__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(\"./src/helloWorld.js\"); 为了实现这个功能，我们还需要引入@babel/types，这个库可以帮我们创建新的AST节点，所以这个转换代码写出来就是这样： const t = require(\"@babel/types\"); // 使用babel traverse来遍历ast上的节点 traverse(ast, { ImportDeclaration(p) { // 获取被import的文件 const importFile = p.node.source.value; // 获取文件路径 let importFilePath = path.join(path.dirname(config.entry), importFile); importFilePath = `./${importFilePath}.js`; // 构建一个变量定义的AST节点 const variableDeclaration = t.variableDeclaration(\"var\", [ t.variableDeclarator( t.identifier( `__${path.basename(importFile)}__WEBPACK_IMPORTED_MODULE_0__` ), t.callExpression(t.identifier(\"__webpack_require__\"), [ t.stringLiteral(importFilePath), ]) ), ]); // 将当前节点替换为变量定义节点 p.replaceWith(variableDeclaration); }, }); 上面这段代码我们用了很多@babel/types下面的API，比如t.variableDeclaration，t.variableDeclarator，这些都是用来创建对应的节点的，具体的API可以看这里。注意这个代码里面我有很多写死的地方，比如importFilePath生成逻辑，还应该处理多种后缀名的，还有最终生成的变量名_${path.basename(importFile)}__WEBPACK_IMPORTED_MODULE_0__，最后的数字我也是直接写了0，按理来说应该是根据不同的import顺序来生成的，但是本文主要讲webpack的原理，这些细节上我就没花过多时间了。 上面的代码其实是修改了我们的AST，修改后的AST可以用@babel/generator又转换为代码： const generate = require('@babel/generator').default; const newCode = generate(ast).code; console.log(newCode); 这个打印结果是： 可以看到这个结果里面import helloWorld from \"./helloWorld\";已经被转换为var __helloWorld__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(\"./src/helloWorld.js\");。 替换import进来的变量 前面我们将import语句替换成了一个变量定义，变量名字也改为了__helloWorld__WEBPACK_IMPORTED_MODULE_0__，自然要将调用的地方也改了。为了更好的管理，我们将AST遍历，操作以及最后的生成新代码都封装成一个函数吧。 function parseFile(file) { // 读取入口文件 const fileContent = fs.readFileSync(file, \"utf-8\"); // 使用babel parser解析AST const ast = parser.parse(fileContent, { sourceType: \"module\" }); let importFilePath = \"\"; // 使用babel traverse来遍历ast上的节点 traverse(ast, { ImportDeclaration(p) { // 跟之前一样的 }, }); const newCode = generate(ast).code; // 返回一个包含必要信息的新对象 return { file, dependcies: [importFilePath], code: newCode, }; } 然后启动执行的时候就可以调这个函数了 parseFile(config.entry); 拿到的结果跟之前的差不多： 好了，现在需要将使用import的地方也替换了，因为我们已经知道了这个地方是将它作为函数调用的，也就是要将 const helloWorldStr = helloWorld(); 转为这个样子： const helloWorldStr = (0,_helloWorld__WEBPACK_IMPORTED_MODULE_0__.default)(); 这行代码的效果其实跟_helloWorld__WEBPACK_IMPORTED_MODULE_0__.default()是一样的，为啥在前面包个(0, )，我也不知道，有知道的大佬告诉下我呗。 所以我们在traverse里面加一个CallExpression： traverse(ast, { ImportDeclaration(p) { // 跟前面的差不多，省略了 }, CallExpression(p) { // 如果调用的是import进来的函数 if (p.node.callee.name === importVarName) { // 就将它替换为转换后的函数名字 p.node.callee.name = `${importCovertVarName}.default`; } }, }); 这样转换后，我们再重新生成一下代码，已经像那么个样子了： 递归解析多个文件 现在我们有了一个parseFile方法来解析处理入口文件，但是我们的文件其实不止一个，我们应该依据模块的依赖关系，递归的将所有的模块都解析了。要实现递归解析也不复杂，因为前面的parseFile的依赖dependcies已经返回了： 我们创建一个数组存放文件的解析结果，初始状态下他只有入口文件的解析结果 根据入口文件的解析结果，可以拿到入口文件的依赖 解析所有的依赖，将结果继续加到解析结果数组里面 一直循环这个解析结果数组，将里面的依赖文件解析完 最后将解析结果数组返回就行 写成代码就是这样： function parseFiles(entryFile) { const entryRes = parseFile(entryFile); // 解析入口文件 const results = [entryRes]; // 将解析结果放入一个数组 // 循环结果数组，将它的依赖全部拿出来解析 for (const res of results) { const dependencies = res.dependencies; dependencies.map((dependency) => { if (dependency) { const ast = parseFile(dependency); results.push(ast); } }); } return results; } 然后就可以调用这个方法解析所有文件了： const allAst = parseFiles(config.entry); console.log(allAst); 看看解析结果吧： 这个结果其实跟我们最终需要生成的__webpack_modules__已经很像了，但是还有两块没有处理： 一个是import进来的内容作为变量使用，比如 import hello from './hello'; const world = 'world'; const helloWorld = () => `${hello} ${world}`; 另一个就是export语句还没处理 替换import进来的变量(作为变量调用) 前面我们已经用CallExpression处理过作为函数使用的import变量了，现在要处理作为变量使用的其实用Identifier处理下就行了，处理逻辑跟之前的CallExpression差不多： traverse(ast, { ImportDeclaration(p) { // 跟以前一样的 }, CallExpression(p) { // 跟以前一样的 }, Identifier(p) { // 如果调用的是import进来的变量 if (p.node.name === importVarName) { // 就将它替换为转换后的变量名字 p.node.name = `${importCovertVarName}.default`; } }, }); 现在再运行下，import进来的变量名字已经变掉了： 替换export语句 从我们需要生成的结果来看，export需要进行两个处理： 如果一个文件有export default，需要添加一个__webpack_require__.d的辅助方法调用，内容都是固定的，加上就行。 将export语句转换为普通的变量定义。 对应生成结果上的这两个： 要处理export语句，在遍历ast的时候添加ExportDefaultDeclaration就行了： traverse(ast, { ImportDeclaration(p) { // 跟以前一样的 }, CallExpression(p) { // 跟以前一样的 }, Identifier(p) { // 跟以前一样的 }, ExportDefaultDeclaration(p) { hasExport = true; // 先标记是否有export // 跟前面import类似的，创建一个变量定义节点 const variableDeclaration = t.variableDeclaration(\"const\", [ t.variableDeclarator( t.identifier(\"__WEBPACK_DEFAULT_EXPORT__\"), t.identifier(p.node.declaration.name) ), ]); // 将当前节点替换为变量定义节点 p.replaceWith(variableDeclaration); }, }); 然后再运行下就可以看到export语句被替换了： 然后就是根据hasExport变量判断在AST转换为代码的时候要不要加__webpack_require__.d辅助函数： const EXPORT_DEFAULT_FUN = ` __webpack_require__.d(__webpack_exports__, { \"default\": () => (__WEBPACK_DEFAULT_EXPORT__) });\\n `; function parseFile(file) { // 省略其他代码 // ...... let newCode = generate(ast).code; if (hasExport) { newCode = `${EXPORT_DEFAULT_FUN} ${newCode}`; } } 最后生成的代码里面export也就处理好了： 把__webpack_require__.r的调用添上吧 前面说了，最终生成的代码，每个模块前面都有个__webpack_require__.r的调用 这个只是拿来给模块添加一个__esModule标记的，我们也给他加上吧，直接在前面export辅助方法后面加点代码就行了： const ESMODULE_TAG_FUN = ` __webpack_require__.r(__webpack_exports__);\\n `; function parseFile(file) { // 省略其他代码 // ...... let newCode = generate(ast).code; if (hasExport) { newCode = `${EXPORT_DEFAULT_FUN} ${newCode}`; } // 下面添加模块标记代码 newCode = `${ESMODULE_TAG_FUN} ${newCode}`; } 再运行下看看，这个代码也加上了： 创建代码模板 到现在，最难的一块，模块代码的解析和转换我们其实已经完成了。下面要做的工作就比较简单了，因为最终生成的代码里面，各种辅助方法都是固定的，动态的部分就是前面解析的模块和入口文件。所以我们可以创建一个这样的模板，将动态的部分标记出来就行，其他不变的部分写死。这个模板文件的处理，你可以将它读进来作为字符串处理，也可以用模板引擎，我这里采用ejs模板引擎： // 模板文件，直接从webpack生成结果抄过来，改改就行 /******/ (() => { // webpackBootstrap /******/ \"use strict\"; // 需要替换的__TO_REPLACE_WEBPACK_MODULES__ /******/ var __webpack_modules__ = ({ { %> '' : ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => { }), }); // 省略中间的辅助方法 /************************************************************************/ /******/ // startup /******/ // Load entry module // 需要替换的__TO_REPLACE_WEBPACK_ENTRY /******/ __webpack_require__(''); /******/ // This entry module used 'exports' so it can't be inlined /******/ })() ; //# sourceMappingURL=main.js.map 生成最终的代码 生成最终代码的思路就是： 模板里面用__TO_REPLACE_WEBPACK_MODULES__来生成最终的__webpack_modules__ 模板里面用__TO_REPLACE_WEBPACK_ENTRY__来替代动态的入口文件 webpack代码里面使用前面生成好的AST数组来替换模板的__TO_REPLACE_WEBPACK_MODULES__ webpack代码里面使用前面拿到的入口文件来替代模板的__TO_REPLACE_WEBPACK_ENTRY__ 使用ejs来生成最终的代码 所以代码就是： // 使用ejs将上面解析好的ast传递给模板 // 返回最终生成的代码 function generateCode(allAst, entry) { const temlateFile = fs.readFileSync( path.join(__dirname, \"./template.js\"), \"utf-8\" ); const codes = ejs.render(temlateFile, { __TO_REPLACE_WEBPACK_MODULES__: allAst, __TO_REPLACE_WEBPACK_ENTRY__: entry, }); return codes; } 大功告成 最后将ejs生成好的代码写入配置的输出路径就行了： const codes = generateCode(allAst, config.entry); fs.writeFileSync(path.join(config.output.path, config.output.filename), codes); 然后就可以使用我们自己的webpack来编译代码，最后就可以像之前那样打开我们的html看看效果了： 总结 本文使用简单质朴的方式讲述了webpack的基本原理，并自己手写实现了一个基本的支持import和export的default的webpack。 下面再就本文的要点进行下总结： webpack最基本的功能其实是将JS的高级模块化语句，import和require之类的转换为浏览器能认识的普通函数调用语句。 要进行语言代码的转换，我们需要对代码进行解析。 常用的解析手段是AST，也就是将代码转换为抽象语法树。 AST是一个描述代码结构的树形数据结构，代码可以转换为AST，AST也可以转换为代码。 babel可以将代码转换为AST，但是webpack官方并没有使用babel，而是基于acorn自己实现了一个JavascriptParser。 本文从webpack构建的结果入手，也使用AST自己生成了一个类似的代码。 webpack最终生成的代码其实分为动态和固定的两部分，我们将固定的部分写入一个模板，动态的部分在模板里面使用ejs占位。 生成代码动态部分需要借助babel来生成AST，并对其进行修改，最后再使用babel将其生成新的代码。 在生成AST时，我们从配置的入口文件开始，递归的解析所有文件。即解析入口文件的时候，将它的依赖记录下来，入口文件解析完后就去解析他的依赖文件，在解析他的依赖文件时，将依赖的依赖也记录下来，后面继续解析。重复这种步骤，直到所有依赖解析完。 动态代码生成好后，使用ejs将其写入模板，以生成最终的代码。 如果要支持require或者AMD，其实思路是类似的，最终生成的代码也是差不多的，主要的差别在AST解析那一块。 参考资料 babel操作AST文档 webpack源码 webpack官方文档 "},"Articles/Engineering/tapable-usage.html":{"url":"Articles/Engineering/tapable-usage.html","title":"webpack核心模块tapable用法","keywords":"","body":"webpack核心模块tapable用法解析 前不久写了一篇webpack基本原理和AST用法的文章，本来想接着写webpack plugin的原理的，但是发现webpack plugin高度依赖tapable这个库，不清楚tapable而直接去看webpack plugin始终有点雾里看花的意思。所以就先去看了下tapable的文档和源码，发现这个库非常有意思，是增强版的发布订阅模式。发布订阅模式在源码世界实在是太常见了，我们已经在多个库源码里面见过了： redux的subscribe和dispatch Node.js的EventEmitter redux-saga的take和put 这些库基本都自己实现了自己的发布订阅模式，实现方式主要是用来满足自己的业务需求，而tapable并没有具体的业务逻辑，是一个专门用来实现事件订阅或者他自己称为hook(钩子)的工具库，其根本原理还是发布订阅模式，但是他实现了多种形式的发布订阅模式，还包含了多种形式的流程控制。 tapable暴露多个API，提供了多种流程控制方式，连使用都是比较复杂的，所以我想分两篇文章来写他的原理： 先看看用法，体验下他的多种流程控制方式 通过用法去看看源码是怎么实现的 本文就是讲用法的文章，知道了他的用法，大家以后如果有自己实现hook或者事件监听的需求，可以直接拿过来用，非常强大！ tapable是什么 tapable是webpack的核心模块，也是webpack团队维护的，是webpack plugin的基本实现方式。他的主要功能是为使用者提供强大的hook机制，webpack plugin就是基于hook的。 主要API 下面是官方文档中列出来的主要API，所有API的名字都是以Hook结尾的： const { SyncHook, SyncBailHook, SyncWaterfallHook, SyncLoopHook, AsyncParallelHook, AsyncParallelBailHook, AsyncSeriesHook, AsyncSeriesBailHook, AsyncSeriesWaterfallHook } = require(\"tapable\"); 这些API的名字其实就解释了他的作用，注意这些关键字：Sync, Async, Bail, Waterfall, Loop, Parallel, Series。下面分别来解释下这些关键字： Sync：这是一个同步的hook Async：这是一个异步的hook Bail：Bail在英文中的意思是保险，保障的意思，实现的效果是，当一个hook注册了多个回调方法，任意一个回调方法返回了不为undefined的值，就不再执行后面的回调方法了，就起到了一个“保险丝”的作用。 Waterfall：Waterfall在英语中是瀑布的意思，在编程世界中表示顺序执行各种任务，在这里实现的效果是，当一个hook注册了多个回调方法，前一个回调执行完了才会执行下一个回调，而前一个回调的执行结果会作为参数传给下一个回调函数。 Loop：Loop就是循环的意思，实现的效果是，当一个hook注册了回调方法，如果这个回调方法返回了true就重复循环这个回调，只有当这个回调返回undefined才执行下一个回调。 Parallel：Parallel是并行的意思，有点类似于Promise.all，就是当一个hook注册了多个回调方法，这些回调同时开始并行执行。 Series：Series就是串行的意思，就是当一个hook注册了多个回调方法，前一个执行完了才会执行下一个。 Parallel和Series的概念只存在于异步的hook中，因为同步hook全部是串行的。 下面我们分别来介绍下每个API的用法和效果。 同步API 同步API就是这几个： const { SyncHook, SyncBailHook, SyncWaterfallHook, SyncLoopHook, } = require(\"tapable\"); 前面说了，同步API全部是串行的，所以这几个的区别就在流程控制上。 SyncHook SyncHook是一个最基础的hook，其使用方法和效果接近我们经常使用的发布订阅模式，注意tapable导出的所有hook都是类，基本用法是这样的： const hook = new SyncHook([\"arg1\", \"arg2\", \"arg3\"]); 因为SyncHook是一个类，所以使用new来生成一个实例，构造函数接收的参数是一个数组[\"arg1\", \"arg2\", \"arg3\"]，这个数组有三项，表示生成的这个实例注册回调的时候接收三个参数。实例hook主要有两个实例方法： tap：就是注册事件回调的方法。 call：就是触发事件，执行回调的方法。 下面我们扩展下官方文档中小汽车加速的例子来说明下具体用法： const { SyncHook } = require(\"tapable\"); // 实例化一个加速的hook const accelerate = new SyncHook([\"newSpeed\"]); // 注册第一个回调，加速时记录下当前速度 accelerate.tap(\"LoggerPlugin\", (newSpeed) => console.log(\"LoggerPlugin\", `加速到${newSpeed}`) ); // 再注册一个回调，用来检测是否超速 accelerate.tap(\"OverspeedPlugin\", (newSpeed) => { if (newSpeed > 120) { console.log(\"OverspeedPlugin\", \"您已超速！！\"); } }); // 再注册一个回调，用来检测速度是否快到损坏车子了 accelerate.tap(\"DamagePlugin\", (newSpeed) => { if (newSpeed > 300) { console.log(\"DamagePlugin\", \"速度实在太快，车子快散架了。。。\"); } }); // 触发一下加速事件，看看效果吧 accelerate.call(500); 然后运行下看看吧，当加速事件出现的时候，会依次执行这三个回调： 上面这个例子主要就是用了tap和call这两个实例方法，其中tap接收两个参数，第一个是个字符串，并没有实际用处，仅仅是一个注释的作用，第二个参数就是一个回调函数，用来执行事件触发时的具体逻辑。 accelerate.tap(\"LoggerPlugin\", (newSpeed) => console.log(\"LoggerPlugin\", `加速到${newSpeed}`) ); 上述这种写法其实与webpack官方文档中对于plugin的介绍非常像了，因为webpack的plguin就是用tapable实现的，第一个参数一般就是plugin的名字： 而call就是简单的触发这个事件，在webpack的plguin中一般不需要开发者去触发事件，而是webpack自己在不同阶段会触发不同的事件，比如beforeRun, run等等，plugin开发者更多的会关注这些事件出现时应该进行什么操作，也就是在这些事件上注册自己的回调。 SyncBailHook 上面的SyncHook其实就是一个简单的发布订阅模式，SyncBailHook就是在这个基础上加了一点流程控制，前面我们说过了，Bail就是个保险，实现的效果是，前面一个回调返回一个不为undefined的值，就中断这个流程。比如我们现在将前面这个例子的SyncHook换成SyncBailHook，然后在检测超速的这个插件里面加点逻辑，当它超速了就返回错误，后面的DamagePlugin就不会执行了： const { SyncBailHook } = require(\"tapable\"); // 使用的是SyncBailHook // 实例化一个加速的hook const accelerate = new SyncBailHook([\"newSpeed\"]); accelerate.tap(\"LoggerPlugin\", (newSpeed) => console.log(\"LoggerPlugin\", `加速到${newSpeed}`) ); // 再注册一个回调，用来检测是否超速 // 如果超速就返回一个错误 accelerate.tap(\"OverspeedPlugin\", (newSpeed) => { if (newSpeed > 120) { console.log(\"OverspeedPlugin\", \"您已超速！！\"); return new Error('您已超速！！'); } }); accelerate.tap(\"DamagePlugin\", (newSpeed) => { if (newSpeed > 300) { console.log(\"DamagePlugin\", \"速度实在太快，车子快散架了。。。\"); } }); accelerate.call(500); 然后再运行下看看： 可以看到由于OverspeedPlugin返回了一个不为undefined的值，DamagePlugin被阻断，没有运行了。 SyncWaterfallHook SyncWaterfallHook也是在SyncHook的基础上加了点流程控制，前面说了，Waterfall实现的效果是将上一个回调的返回值作为参数传给下一个回调。所以通过call传入的参数只会传递给第一个回调函数，后面的回调接受都是上一个回调的返回值，最后一个回调的返回值会作为call的返回值返回给最外层： const { SyncWaterfallHook } = require(\"tapable\"); const accelerate = new SyncWaterfallHook([\"newSpeed\"]); accelerate.tap(\"LoggerPlugin\", (newSpeed) => { console.log(\"LoggerPlugin\", `加速到${newSpeed}`); return \"LoggerPlugin\"; }); accelerate.tap(\"Plugin2\", (data) => { console.log(`上一个插件是: ${data}`); return \"Plugin2\"; }); accelerate.tap(\"Plugin3\", (data) => { console.log(`上一个插件是: ${data}`); return \"Plugin3\"; }); const lastPlugin = accelerate.call(100); console.log(`最后一个插件是：${lastPlugin}`); 然后看下运行效果吧： SyncLoopHook SyncLoopHook是在SyncHook的基础上添加了循环的逻辑，也就是如果一个插件返回true就会一直执行这个插件，直到他返回undefined才会执行下一个插件： const { SyncLoopHook } = require(\"tapable\"); const accelerate = new SyncLoopHook([\"newSpeed\"]); accelerate.tap(\"LoopPlugin\", (newSpeed) => { console.log(\"LoopPlugin\", `循环加速到${newSpeed}`); return new Date().getTime() % 5 !== 0 ? true : undefined; }); accelerate.tap(\"LastPlugin\", (newSpeed) => { console.log(\"循环加速总算结束了\"); }); accelerate.call(100); 执行效果如下： 异步API 所谓异步API是相对前面的同步API来说的，前面的同步API的所有回调都是按照顺序同步执行的，每个回调内部也全部是同步代码。但是实际项目中，可能需要回调里面处理异步情况，也可能希望多个回调可以同时并行执行，也就是Parallel。这些需求就需要用到异步API了，主要的异步API就是这些： const { AsyncParallelHook, AsyncParallelBailHook, AsyncSeriesHook, AsyncSeriesBailHook, AsyncSeriesWaterfallHook } = require(\"tapable\"); 既然涉及到了异步，那肯定还需要异步的处理方式，tapable支持回调函数和Promise两种异步的处理方式。所以这些异步API除了用前面的tap来注册回调外，还有两个注册回调的方法：tapAsync和tapPromise，对应的触发事件的方法为callAsync和promise。下面分别来看下每个API吧： AsyncParallelHook AsyncParallelHook从前面介绍的命名规则可以看出，他是一个异步并行执行的Hook，我们先用tapAsync的方式来看下怎么用吧。 tapAsync和callAsync 还是那个小汽车加速的例子，只不过这个小汽车加速没那么快了，需要一秒才能加速完成，然后我们在2秒的时候分别检测是否超速和是否损坏，为了看出并行的效果，我们记录下整个过程从开始到结束的时间： const { AsyncParallelHook } = require(\"tapable\"); const accelerate = new AsyncParallelHook([\"newSpeed\"]); console.time(\"total time\"); // 记录起始时间 // 注意注册异步事件需要使用tapAsync // 接收的最后一个参数是done，调用他来表示当前任务执行完毕 accelerate.tapAsync(\"LoggerPlugin\", (newSpeed, done) => { // 1秒后加速才完成 setTimeout(() => { console.log(\"LoggerPlugin\", `加速到${newSpeed}`); done(); }, 1000); }); accelerate.tapAsync(\"OverspeedPlugin\", (newSpeed, done) => { // 2秒后检测是否超速 setTimeout(() => { if (newSpeed > 120) { console.log(\"OverspeedPlugin\", \"您已超速！！\"); } done(); }, 2000); }); accelerate.tapAsync(\"DamagePlugin\", (newSpeed, done) => { // 2秒后检测是否损坏 setTimeout(() => { if (newSpeed > 300) { console.log(\"DamagePlugin\", \"速度实在太快，车子快散架了。。。\"); } done(); }, 2000); }); accelerate.callAsync(500, () => { console.log(\"任务全部完成\"); console.timeEnd(\"total time\"); // 记录总共耗时 }); 上面代码需要注意的是，注册回调要使用tapAsync，而且回调函数里面最后一个参数会自动传入done，你可以调用他来通知tapable当前任务已经完成。触发任务需要使用callAsync，他最后也接收一个函数，可以用来处理所有任务都完成后需要执行的操作。所以上面的运行结果就是： 从这个结果可以看出，最终消耗的时间大概是2秒，也就是三个任务中最长的单个任务耗时，而不是三个任务耗时的总额，这就实现了Parallel并行的效果。 tapPromise和promise 现在都流行Promise，所以tapable也是支持的，执行效果是一样的，只是写法不一样而已。要用tapPromise，需要注册的回调返回一个promise，同时触发事件也需要用promise，任务运行完执行的处理可以直接使用then，所以上述代码改为： const { AsyncParallelHook } = require(\"tapable\"); const accelerate = new AsyncParallelHook([\"newSpeed\"]); console.time(\"total time\"); // 记录起始时间 // 注意注册异步事件需要使用tapPromise // 回调函数要返回一个promise accelerate.tapPromise(\"LoggerPlugin\", (newSpeed) => { return new Promise((resolve) => { // 1秒后加速才完成 setTimeout(() => { console.log(\"LoggerPlugin\", `加速到${newSpeed}`); resolve(); }, 1000); }); }); accelerate.tapPromise(\"OverspeedPlugin\", (newSpeed) => { return new Promise((resolve) => { // 2秒后检测是否超速 setTimeout(() => { if (newSpeed > 120) { console.log(\"OverspeedPlugin\", \"您已超速！！\"); } resolve(); }, 2000); }); }); accelerate.tapPromise(\"DamagePlugin\", (newSpeed) => { return new Promise((resolve) => { // 2秒后检测是否损坏 setTimeout(() => { if (newSpeed > 300) { console.log(\"DamagePlugin\", \"速度实在太快，车子快散架了。。。\"); } resolve(); }, 2000); }); }); // 触发事件使用promise，直接用then处理最后的结果 accelerate.promise(500).then(() => { console.log(\"任务全部完成\"); console.timeEnd(\"total time\"); // 记录总共耗时 }); 这段代码的逻辑和运行结果和上面那个是一样的，只是写法不一样： tapAsync和tapPromise混用 既然tapable支持这两种异步写法，那这两种写法可以混用吗？我们来试试吧： const { AsyncParallelHook } = require(\"tapable\"); const accelerate = new AsyncParallelHook([\"newSpeed\"]); console.time(\"total time\"); // 记录起始时间 // 来一个promise写法 accelerate.tapPromise(\"LoggerPlugin\", (newSpeed) => { return new Promise((resolve) => { // 1秒后加速才完成 setTimeout(() => { console.log(\"LoggerPlugin\", `加速到${newSpeed}`); resolve(); }, 1000); }); }); // 再来一个async写法 accelerate.tapAsync(\"OverspeedPlugin\", (newSpeed, done) => { // 2秒后检测是否超速 setTimeout(() => { if (newSpeed > 120) { console.log(\"OverspeedPlugin\", \"您已超速！！\"); } done(); }, 2000); }); // 使用promise触发事件 // accelerate.promise(500).then(() => { // console.log(\"任务全部完成\"); // console.timeEnd(\"total time\"); // 记录总共耗时 // }); // 使用callAsync触发事件 accelerate.callAsync(500, () => { console.log(\"任务全部完成\"); console.timeEnd(\"total time\"); // 记录总共耗时 }); 这段代码无论我是使用promise触发事件还是callAsync触发运行的结果都是一样的，所以tapable内部应该是做了兼容转换的，两种写法可以混用： 由于tapAsync和tapPromise只是写法上的不一样，我后面的例子就全部用tapAsync了。 AsyncParallelBailHook 前面已经看了SyncBailHook，知道带Bail的功能就是当一个任务返回不为undefined的时候，阻断后面任务的执行。但是由于Parallel任务都是同时开始的，阻断是阻断不了了，实际效果是如果有一个任务返回了不为undefined的值，最终的回调会立即执行，并且获取Bail任务的返回值。我们将上面三个任务执行时间错开，分别为1秒，2秒，3秒，然后在2秒的任务触发Bail就能看到效果了： const { AsyncParallelBailHook } = require(\"tapable\"); const accelerate = new AsyncParallelBailHook([\"newSpeed\"]); console.time(\"total time\"); // 记录起始时间 accelerate.tapAsync(\"LoggerPlugin\", (newSpeed, done) => { // 1秒后加速才完成 setTimeout(() => { console.log(\"LoggerPlugin\", `加速到${newSpeed}`); done(); }, 1000); }); accelerate.tapAsync(\"OverspeedPlugin\", (newSpeed, done) => { // 2秒后检测是否超速 setTimeout(() => { if (newSpeed > 120) { console.log(\"OverspeedPlugin\", \"您已超速！！\"); } // 这个任务的done返回一个错误 // 注意第一个参数是node回调约定俗成的错误 // 第二个参数才是Bail的返回值 done(null, new Error(\"您已超速！！\")); }, 2000); }); accelerate.tapAsync(\"DamagePlugin\", (newSpeed, done) => { // 3秒后检测是否损坏 setTimeout(() => { if (newSpeed > 300) { console.log(\"DamagePlugin\", \"速度实在太快，车子快散架了。。。\"); } done(); }, 3000); }); accelerate.callAsync(500, (error, data) => { if (data) { console.log(\"任务执行出错：\", data); } else { console.log(\"任务全部完成\"); } console.timeEnd(\"total time\"); // 记录总共耗时 }); 可以看到执行到任务2时，由于他返回了一个错误，所以最终的回调会立即执行，但是由于任务3之前已经同步开始了，所以他自己仍然会运行完，只是已经不影响最终结果了： AsyncSeriesHook AsyncSeriesHook是异步串行hook，如果有多个任务，这多个任务之间是串行的，但是任务本身却可能是异步的，下一个任务必须等上一个任务done了才能开始： const { AsyncSeriesHook } = require(\"tapable\"); const accelerate = new AsyncSeriesHook([\"newSpeed\"]); console.time(\"total time\"); // 记录起始时间 accelerate.tapAsync(\"LoggerPlugin\", (newSpeed, done) => { // 1秒后加速才完成 setTimeout(() => { console.log(\"LoggerPlugin\", `加速到${newSpeed}`); done(); }, 1000); }); accelerate.tapAsync(\"OverspeedPlugin\", (newSpeed, done) => { // 2秒后检测是否超速 setTimeout(() => { if (newSpeed > 120) { console.log(\"OverspeedPlugin\", \"您已超速！！\"); } done(); }, 2000); }); accelerate.tapAsync(\"DamagePlugin\", (newSpeed, done) => { // 2秒后检测是否损坏 setTimeout(() => { if (newSpeed > 300) { console.log(\"DamagePlugin\", \"速度实在太快，车子快散架了。。。\"); } done(); }, 2000); }); accelerate.callAsync(500, () => { console.log(\"任务全部完成\"); console.timeEnd(\"total time\"); // 记录总共耗时 }); 每个任务代码跟AsyncParallelHook是一样的，只是使用的Hook不一样，而最终效果的区别是：AsyncParallelHook所有任务同时开始，所以最终总耗时就是耗时最长的那个任务的耗时；AsyncSeriesHook的任务串行执行，下一个任务要等上一个任务完成了才能开始，所以最终总耗时是所有任务耗时的总和，上面这个例子就是1 + 2 + 2，也就是5秒： AsyncSeriesBailHook AsyncSeriesBailHook就是在AsyncSeriesHook的基础上加上了Bail的逻辑，也就是中间任何一个任务返回不为undefined的值，终止执行，直接执行最后的回调，并且将这个返回值传给最终的回调： const { AsyncSeriesBailHook } = require(\"tapable\"); const accelerate = new AsyncSeriesBailHook([\"newSpeed\"]); console.time(\"total time\"); // 记录起始时间 accelerate.tapAsync(\"LoggerPlugin\", (newSpeed, done) => { // 1秒后加速才完成 setTimeout(() => { console.log(\"LoggerPlugin\", `加速到${newSpeed}`); done(); }, 1000); }); accelerate.tapAsync(\"OverspeedPlugin\", (newSpeed, done) => { // 2秒后检测是否超速 setTimeout(() => { if (newSpeed > 120) { console.log(\"OverspeedPlugin\", \"您已超速！！\"); } // 这个任务的done返回一个错误 // 注意第一个参数是node回调约定俗成的错误 // 第二个参数才是Bail的返回值 done(null, new Error(\"您已超速！！\")); }, 2000); }); accelerate.tapAsync(\"DamagePlugin\", (newSpeed, done) => { // 2秒后检测是否损坏 setTimeout(() => { if (newSpeed > 300) { console.log(\"DamagePlugin\", \"速度实在太快，车子快散架了。。。\"); } done(); }, 2000); }); accelerate.callAsync(500, (error, data) => { if (data) { console.log(\"任务执行出错：\", data); } else { console.log(\"任务全部完成\"); } console.timeEnd(\"total time\"); // 记录总共耗时 }); 这个执行结果跟AsyncParallelBailHook的区别就是AsyncSeriesBailHook被阻断后，后面的任务由于还没开始，所以可以被完全阻断，而AsyncParallelBailHook后面的任务由于已经开始了，所以还会继续执行，只是结果已经不关心了。 AsyncSeriesWaterfallHook Waterfall的作用是将前一个任务的结果传给下一个任务，其他的跟AsyncSeriesHook一样的，直接来看代码吧： const { AsyncSeriesWaterfallHook } = require(\"tapable\"); const accelerate = new AsyncSeriesWaterfallHook([\"newSpeed\"]); console.time(\"total time\"); // 记录起始时间 accelerate.tapAsync(\"LoggerPlugin\", (newSpeed, done) => { // 1秒后加速才完成 setTimeout(() => { console.log(\"LoggerPlugin\", `加速到${newSpeed}`); // 注意done的第一个参数会被当做error // 第二个参数才是传递给后面任务的参数 done(null, \"LoggerPlugin\"); }, 1000); }); accelerate.tapAsync(\"Plugin2\", (data, done) => { setTimeout(() => { console.log(`上一个插件是: ${data}`); done(null, \"Plugin2\"); }, 2000); }); accelerate.tapAsync(\"Plugin3\", (data, done) => { setTimeout(() => { console.log(`上一个插件是: ${data}`); done(null, \"Plugin3\"); }, 2000); }); accelerate.callAsync(500, (error, data) => { console.log(\"最后一个插件是:\", data); console.timeEnd(\"total time\"); // 记录总共耗时 }); 运行效果如下： 总结 tapable是webpack实现plugin的核心库，他为webpack提供了多种事件处理和流程控制的Hook。 这些Hook主要有同步(Sync)和异步(Async)两种，同时还提供了阻断(Bail)，瀑布(Waterfall)，循环(Loop)等流程控制，对于异步流程还提供了并行(Paralle)和串行(Series)两种控制方式。 tapable其核心原理还是事件的发布订阅模式，他使用tap来注册事件，使用call来触发事件。 异步hook支持两种写法：回调和Promise，注册和触发事件分别使用tapAsync/callAsync和tapPromise/promise。 异步hook使用回调写法的时候要注意，回调函数的第一个参数默认是错误，第二个参数才是向外传递的数据，这也符合node回调的风格。 这篇文章主要讲述了tapable的用法，后面我会写一篇文章来分析他的源码，点个关注不迷路，哈哈~ "},"Articles/Engineering/tapable-source-code.html":{"url":"Articles/Engineering/tapable-source-code.html","title":"webpack核心模块tapable源码解析","keywords":"","body":"webpack核心模块tapable源码解析 上一篇文章我写了tapable的基本用法，我们知道他是一个增强版版的发布订阅模式，本文想来学习下他的源码。tapable的源码我读了一下，发现他的抽象程度比较高，直接扎进去反而会让人云里雾里的，所以本文会从最简单的SyncHook和发布订阅模式入手，再一步一步抽象，慢慢变成他源码的样子。 SyncHook的基本实现 上一篇文章已经讲过SyncHook的用法了，我这里就不再展开了，他使用的例子就是这样子： const { SyncHook } = require(\"tapable\"); // 实例化一个加速的hook const accelerate = new SyncHook([\"newSpeed\"]); // 注册第一个回调，加速时记录下当前速度 accelerate.tap(\"LoggerPlugin\", (newSpeed) => console.log(\"LoggerPlugin\", `加速到${newSpeed}`) ); // 再注册一个回调，用来检测是否超速 accelerate.tap(\"OverspeedPlugin\", (newSpeed) => { if (newSpeed > 120) { console.log(\"OverspeedPlugin\", \"您已超速！！\"); } }); // 触发一下加速事件，看看效果吧 accelerate.call(500); 其实这种用法就是一个最基本的发布订阅模式，我之前讲发布订阅模式的文章讲过，我们可以仿照那个很快实现一个SyncHook： class SyncHook { constructor(args = []) { this._args = args; // 接收的参数存下来 this.taps = []; // 一个存回调的数组 } // tap实例方法用来注册回调 tap(name, fn) { // 逻辑很简单，直接保存下传入的回调参数就行 this.taps.push(fn); } // call实例方法用来触发事件，执行所有回调 call(...args) { // 逻辑也很简单，将注册的回调一个一个拿出来执行就行 const tapsLength = this.taps.length; for(let i = 0; i 这段代码非常简单，是一个最基础的发布订阅模式，使用方法跟上面是一样的，将SyncHook从tapable导出改为使用我们自己的： // const { SyncHook } = require(\"tapable\"); const { SyncHook } = require(\"./SyncHook\"); 运行效果是一样的： 注意： 我们构造函数里面传入的args并没有用上，tapable主要是用它来动态生成call的函数体的，在后面讲代码工厂的时候会看到。 SyncBailHook的基本实现 再来一个SyncBailHook的基本实现吧，SyncBailHook的作用是当前一个回调返回不为undefined的值的时候，阻止后面的回调执行。基本使用是这样的： const { SyncBailHook } = require(\"tapable\"); // 使用的是SyncBailHook const accelerate = new SyncBailHook([\"newSpeed\"]); accelerate.tap(\"LoggerPlugin\", (newSpeed) => console.log(\"LoggerPlugin\", `加速到${newSpeed}`) ); // 再注册一个回调，用来检测是否超速 // 如果超速就返回一个错误 accelerate.tap(\"OverspeedPlugin\", (newSpeed) => { if (newSpeed > 120) { console.log(\"OverspeedPlugin\", \"您已超速！！\"); return new Error('您已超速！！'); } }); // 由于上一个回调返回了一个不为undefined的值 // 这个回调不会再运行了 accelerate.tap(\"DamagePlugin\", (newSpeed) => { if (newSpeed > 300) { console.log(\"DamagePlugin\", \"速度实在太快，车子快散架了。。。\"); } }); accelerate.call(500); 他的实现跟上面的SyncHook也非常像，只是call在执行的时候不一样而已，SyncBailHook需要检测每个回调的返回值，如果不为undefined就终止执行后面的回调，所以代码实现如下： class SyncBailHook { constructor(args = []) { this._args = args; this.taps = []; } tap(name, fn) { this.taps.push(fn); } // 其他代码跟SyncHook是一样的，就是call的实现不一样 // 需要检测每个返回值，如果不为undefined就终止执行 call(...args) { const tapsLength = this.taps.length; for(let i = 0; i 然后改下SyncBailHook从我们自己的引入就行： // const { SyncBailHook } = require(\"tapable\"); const { SyncBailHook } = require(\"./SyncBailHook\"); 运行效果是一样的： 抽象重复代码 现在我们只实现了SyncHook和SyncBailHook两个Hook而已，上一篇讲用法的文章里面总共有9个Hook，如果每个Hook都像前面这样实现也是可以的。但是我们再仔细看下SyncHook和SyncBailHook两个类的代码，发现他们除了call的实现不一样，其他代码一模一样，所以作为一个有追求的工程师，我们可以把这部分重复的代码提出来作为一个基类：Hook类。 Hook类需要包含一些公共的代码，call这种不一样的部分由各个子类自己实现。所以Hook类就长这样： const CALL_DELEGATE = function(...args) { this.call = this._createCall(); return this.call(...args); }; // Hook是SyncHook和SyncBailHook的基类 // 大体结构是一样的，不一样的地方是call // 不同子类的call是不一样的 // tapable的Hook基类提供了一个抽象接口compile来动态生成call函数 class Hook { constructor(args = []) { this._args = args; this.taps = []; // 基类的call初始化为CALL_DELEGATE // 为什么这里需要这样一个代理，而不是直接this.call = _createCall() // 等我们后面子类实现了再一起讲 this.call = CALL_DELEGATE; } // 一个抽象接口compile // 由子类实现，基类compile不能直接调用 compile(options) { throw new Error(\"Abstract: should be overridden\"); } tap(name, fn) { this.taps.push(fn); } // _createCall调用子类实现的compile来生成call方法 _createCall() { return this.compile({ taps: this.taps, args: this._args, }); } } 官方对应的源码看这里：https://github.com/webpack/tapable/blob/master/lib/Hook.js 子类SyncHook实现 现在有了Hook基类，我们的SyncHook就需要继承这个基类重写，tapable在这里继承的时候并没有使用class extends，而是手动继承的： const Hook = require('./Hook'); function SyncHook(args = []) { // 先手动继承Hook const hook = new Hook(args); hook.constructor = SyncHook; // 然后实现自己的compile函数 // compile的作用应该是创建一个call函数并返回 hook.compile = function(options) { // 这里call函数的实现跟前面实现是一样的 const { taps } = options; const call = function(...args) { const tapsLength = taps.length; for(let i = 0; i 注意：我们在基类Hook构造函数中初始化this.call为CALL_DELEGATE这个函数，这是有原因的，最主要的原因是确保this的正确指向。思考一下假如我们不用CALL_DELEGATE，而是直接this.call = this._createCall()会发生什么？我们来分析下这个执行流程： 用户使用时，肯定是使用new SyncHook()，这时候会执行const hook = new Hook(args); new Hook(args)会去执行Hook的构造函数，也就是会运行this.call = this._createCall() 这时候的this指向的是基类Hook的实例，this._createCall()会调用基类的this.compile() 由于基类的complie函数是一个抽象接口，直接调用会报错Abstract: should be overridden。 那我们采用this.call = CALL_DELEGATE是怎么解决这个问题的呢？ 采用this.call = CALL_DELEGATE后，基类Hook上的call就只是被赋值为一个代理函数而已，这个函数不会立马调用。 用户使用时，同样是new SyncHook()，里面会执行Hook的构造函数 Hook构造函数会给this.call赋值为CALL_DELEGATE，但是不会立即执行。 new SyncHook()继续执行，新建的实例上的方法hook.complie被覆写为正确方法。 当用户调用hook.call的时候才会真正执行this._createCall()，这里面会去调用this.complie() 这时候调用的complie已经是被正确覆写过的了，所以得到正确的结果。 子类SyncBailHook的实现 子类SyncBailHook的实现跟上面SyncHook的也是非常像，只是hook.compile实现不一样而已： const Hook = require('./Hook'); function SyncBailHook(args = []) { // 基本结构跟SyncHook都是一样的 const hook = new Hook(args); hook.constructor = SyncBailHook; // 只是compile的实现是Bail版的 hook.compile = function(options) { const { taps } = options; const call = function(...args) { const tapsLength = taps.length; for(let i = 0; i 抽象代码工厂 上面我们通过对SyncHook和SyncBailHook的抽象提炼出了一个基类Hook，减少了重复代码。基于这种结构子类需要实现的就是complie方法，但是如果我们将SyncHook和SyncBailHook的complie方法拿出来对比下： SyncHook: hook.compile = function(options) { const { taps } = options; const call = function(...args) { const tapsLength = taps.length; for(let i = 0; i SyncBailHook： hook.compile = function(options) { const { taps } = options; const call = function(...args) { const tapsLength = taps.length; for(let i = 0; i 我们发现这两个complie也非常像，有大量重复代码，所以tapable为了解决这些重复代码，又进行了一次抽象，也就是代码工厂HookCodeFactory。HookCodeFactory的作用就是用来生成complie返回的call函数体，而HookCodeFactory在实现时也采用了Hook类似的思路，也是先实现了一个基类HookCodeFactory，然后不同的Hook再继承这个类来实现自己的代码工厂，比如SyncHookCodeFactory。 创建函数的方法 在继续深入代码工厂前，我们先来回顾下JS里面创建函数的方法。一般我们会有这几种方法： 函数申明 function add(a, b) { return a + b; } 函数表达式 const add = function(a, b) { return a + b; } 但是除了这两种方法外，还有种不常用的方法：使用Function构造函数。比如上面这个函数使用构造函数创建就是这样的： const add = new Function('a', 'b', 'return a + b;'); 上面的调用形式里，最后一个参数是函数的函数体，前面的参数都是函数的形参，最终生成的函数跟用函数表达式的效果是一样的，可以这样调用： add(1, 2); // 结果是3 注意：上面的a和b形参放在一起用逗号隔开也是可以的： const add = new Function('a, b', 'return a + b;'); // 这样跟上面的效果是一样的 当然函数并不是一定要有参数，没有参数的函数也可以这样创建： const sayHi = new Function('alert(\"Hello\")'); sayHi(); // Hello 这样创建函数和前面的函数申明和函数表达式有什么区别呢？使用Function构造函数来创建函数最大的一个特征就是，函数体是一个字符串，也就是说我们可以动态生成这个字符串，从而动态生成函数体。因为SyncHook和SyncBailHook的call函数很像，我们可以像拼一个字符串那样拼出他们的函数体，为了更简单的拼凑，tapable最终生成的call函数里面并没有循环，而是在拼函数体的时候就将循环展开了，比如SyncHook拼出来的call函数的函数体就是这样的： \"use strict\"; var _x = this._x; var _fn0 = _x[0]; _fn0(newSpeed); var _fn1 = _x[1]; _fn1(newSpeed); 上面代码的_x其实就是保存回调的数组taps，这里重命名为_x，我想是为了节省代码大小吧。这段代码可以看到，_x，也就是taps里面的内容已经被展开了，是一个一个取出来执行的。 而SyncBailHook最终生成的call函数体是这样的： \"use strict\"; var _x = this._x; var _fn0 = _x[0]; var _result0 = _fn0(newSpeed); if (_result0 !== undefined) { return _result0; ; } else { var _fn1 = _x[1]; var _result1 = _fn1(newSpeed); if (_result1 !== undefined) { return _result1; ; } else { } } 这段生成的代码主体逻辑其实跟SyncHook是一样的，都是将_x展开执行了，他们的区别是SyncBailHook会对每次执行的结果进行检测，如果结果不是undefined就直接return了，后面的回调函数就没有机会执行了。 创建代码工厂基类 基于这个目的，我们的代码工厂基类应该可以生成最基本的call函数体。我们来写个最基本的HookCodeFactory吧，目前他只能生成SyncHook的call函数体： class HookCodeFactory { constructor() { // 构造函数定义两个变量 this.options = undefined; this._args = undefined; } // init函数初始化变量 init(options) { this.options = options; this._args = options.args.slice(); } // deinit重置变量 deinit() { this.options = undefined; this._args = undefined; } // args用来将传入的数组args转换为New Function接收的逗号分隔的形式 // ['arg1', 'args'] ---> 'arg1, arg2' args() { return this._args.join(\", \"); } // setup其实就是给生成代码的_x赋值 setup(instance, options) { instance._x = options.taps.map(t => t); } // create创建最终的call函数 create(options) { this.init(options); let fn; // 直接将taps展开为平铺的函数调用 const { taps } = options; let code = ''; for (let i = 0; i 上面代码最核心的其实就是create函数，这个函数会动态创建一个call函数并返回，所以SyncHook可以直接使用这个factory创建代码了： // SyncHook.js const Hook = require('./Hook'); const HookCodeFactory = require(\"./HookCodeFactory\"); const factory = new HookCodeFactory(); // COMPILE函数会去调用factory来生成call函数 const COMPILE = function(options) { factory.setup(this, options); return factory.create(options); }; function SyncHook(args = []) { const hook = new Hook(args); hook.constructor = SyncHook; // 使用HookCodeFactory来创建最终的call函数 hook.compile = COMPILE; return hook; } SyncHook.prototype = null; 让代码工厂支持SyncBailHook 现在我们的HookCodeFactory只能生成最简单的SyncHook代码，我们需要对他进行一些改进，让他能够也生成SyncBailHook的call函数体。你可以拉回前面再仔细观察下这两个最终生成代码的区别： SyncBailHook需要对每次执行的result进行处理，如果不为undefined就返回 SyncBailHook生成的代码其实是if...else嵌套的，我们生成的时候可以考虑使用一个递归函数 为了让SyncHook和SyncBailHook的子类代码工厂能够传入差异化的result处理，我们先将HookCodeFactory基类的create拆成两部分，将代码拼装的逻辑单独拆成一个函数： class HookCodeFactory { // ... // 省略其他一样的代码 // ... // create创建最终的call函数 create(options) { this.init(options); let fn; // 拼装代码头部 const header = ` \"use strict\"; var _x = this._x; `; // 用传进来的参数和函数体创建一个函数出来 fn = new Function(this.args(), header + this.content()); // 注意这里的content函数并没有在基类HookCodeFactory实现，而是子类实现的 this.deinit(); return fn; } // 拼装函数体 // callTapsSeries也没在基类调用，而是子类调用的 callTapsSeries() { const { taps } = this.options; let code = ''; for (let i = 0; i 上面代码里面要特别注意create函数里面生成函数体的时候调用的是this.content，但是this.content并没与在基类实现，这要求子类在使用HookCodeFactory的时候都需要继承他并实现自己的content函数，所以这里的content函数也是一个抽象接口。那SyncHook的代码就应该改成这样： // SyncHook.js // ... 省略其他一样的代码 ... // SyncHookCodeFactory继承HookCodeFactory并实现content函数 class SyncHookCodeFactory extends HookCodeFactory { content() { return this.callTapsSeries(); // 这里的callTapsSeries是基类的 } } // 使用SyncHookCodeFactory来创建factory const factory = new SyncHookCodeFactory(); const COMPILE = function (options) { factory.setup(this, options); return factory.create(options); }; 注意这里：子类实现的content其实又调用了基类的callTapsSeries来生成最终的函数体。所以这里这几个函数的调用关系其实是这样的： 那这样设计的目的是什么呢？为了让子类content能够传递参数给基类callTapsSeries，从而生成不一样的函数体。我们马上就能在SyncBailHook的代码工厂上看到了。 为了能够生成SyncBailHook的函数体，我们需要让callTapsSeries支持一个onResult参数，就是这样： class HookCodeFactory { // ... 省略其他相同的代码 ... // 拼装函数体，需要支持options.onResult参数 callTapsSeries(options) { const { taps } = this.options; let code = ''; let i = 0; const onResult = options && options.onResult; // 写一个next函数来开启有onResult回调的函数体生成 // next和onResult相互递归调用来生成最终的函数体 const next = () => { if(i >= taps.length) return ''; const result = `_result${i}`; const code = ` var _fn${i} = _x[${i}]; var ${result} = _fn${i}(${this.args()}); ${onResult(i++, result, next)} `; return code; } // 支持onResult参数 if(onResult) { code = next(); } else { // 没有onResult参数的时候，即SyncHook跟之前保持一样 for(; i 然后我们的SyncBailHook的代码工厂在继承工厂基类的时候需要传一个onResult参数，就是这样： const Hook = require('./Hook'); const HookCodeFactory = require(\"./HookCodeFactory\"); // SyncBailHookCodeFactory继承HookCodeFactory并实现content函数 // content里面传入定制的onResult函数，onResult回去调用next递归生成嵌套的if...else... class SyncBailHookCodeFactory extends HookCodeFactory { content() { return this.callTapsSeries({ onResult: (i, result, next) => `if(${result} !== undefined) {\\nreturn ${result};\\n} else {\\n${next()}}\\n`, }); } } // 使用SyncHookCodeFactory来创建factory const factory = new SyncBailHookCodeFactory(); const COMPILE = function (options) { factory.setup(this, options); return factory.create(options); }; function SyncBailHook(args = []) { // 基本结构跟SyncHook都是一样的 const hook = new Hook(args); hook.constructor = SyncBailHook; // 使用HookCodeFactory来创建最终的call函数 hook.compile = COMPILE; return hook; } 现在运行下代码，效果跟之前一样的，大功告成~ 其他Hook的实现 到这里，tapable的源码架构和基本实现我们已经弄清楚了，但是本文只用了SyncHook和SyncBailHook做例子，其他的，比如AsyncParallelHook并没有展开讲。因为AsyncParallelHook之类的其他Hook的实现思路跟本文是一样的，比如我们可以先实现一个独立的AsyncParallelHook类： class AsyncParallelHook { constructor(args = []) { this._args = args; this.taps = []; } tapAsync(name, task) { this.taps.push(task); } callAsync(...args) { // 先取出最后传入的回调函数 let finalCallback = args.pop(); // 定义一个 i 变量和 done 函数，每次执行检测 i 值和队列长度，决定是否执行 callAsync 的最终回调函数 let i = 0; let done = () => { if (++i === this.taps.length) { finalCallback(); } }; // 依次执行事件处理函数 this.taps.forEach(task => task(...args, done)); } } 然后对他的callAsync函数进行抽象，将其抽象到代码工厂类里面，使用字符串拼接的方式动态构造出来就行了，整体思路跟前面是一样的。具体实现过程可以参考tapable源码： Hook类源码 SyncHook类源码 SyncBailHook类源码 HookCodeFactory类源码 总结 下面再对本文的思路进行一个总结： tapable的各种Hook其实都是基于发布订阅模式。 各个Hook自己独立实现其实也没有问题，但是因为都是发布订阅模式，会有大量重复代码，所以tapable进行了几次抽象。 第一次抽象是提取一个Hook基类，这个基类实现了初始化和事件注册等公共部分，至于每个Hook的call都不一样，需要自己实现。 第二次抽象是每个Hook在实现自己的call的时候，发现代码也有很多相似之处，所以提取了一个代码工厂，用来动态生成call的函数体。 总体来说，tapable的代码并不难，但是因为有两次抽象，整个代码架构显得不那么好读，经过本文的梳理后，应该会好很多了。 参考资料 tapable用法介绍：https://juejin.cn/post/6939794845053485093 tapable源码地址：https://github.com/webpack/tapable "},"Articles/DataStructureAndAlgorithm/DataStructureAndAlgorithm.html":{"url":"Articles/DataStructureAndAlgorithm/DataStructureAndAlgorithm.html","title":"数据结构和算法","keywords":"","body":"本章节包括如下内容： 排序算法 链表 贪心算法 动态规划 HTTPS和RSA 三层商品选项优化 "},"Articles/DataStructureAndAlgorithm/Sorting.html":{"url":"Articles/DataStructureAndAlgorithm/Sorting.html","title":"排序算法","keywords":"","body":"排序是很常见也很经典的问题，下面讲几种排序算法： 冒泡排序 冒泡排序是最好理解的一种算法，以升序排序为例，即最小的在前面，对数组进行一次遍历，如果相邻的两个数前面的比后面的大，则交换他们的位置，第一次遍历会将最大的数字排到最后去，第二次遍历会将第二大的数字排到倒数第二的位置。。。以此类推，遍历n-1遍整个数组就有序了。详细解说参考https://www.runoob.com/w3cnote/bubble-sort.html: 下面我们自己来实现一遍代码： const array = [1, 3, 2, 6, 4, 5, 9, 8, 7]; const sort = (arr) => { let result = [...arr]; let temp; for(let i = 0; i result[j + 1]){ temp = result[j]; result[j] = result[j + 1]; result[j + 1] = temp; } } } return result; } const newArr = sort(array); console.log(newArr); // [1, 2, 3, 4, 5, 6, 7, 8, 9] 插入排序 会打扑克的同学应该很熟悉这个排序法，每次摸牌的时候都去手里面已经排好序的牌里面比较下，找到它的位置，插入进去。这个查找可以使用二分查找，所以更快。具体分析看这里：https://www.runoob.com/w3cnote/insertion-sort.html const array = [1, 3, 2, 6, 4, 5, 9, 8, 7]; const sort = (arr) => { let result = [...arr]; let temp; for(let i = 0; i result[j] && j>=0){ temp = result[j - 1]; result[j - 1] = result[j]; result[j] = temp; j--; } } return result; } const newArr = sort(array); console.log(newArr); // [1, 2, 3, 4, 5, 6, 7, 8, 9] // 二分查找版 const array = [1, 3, 2, 6, 4, 5, 9, 8, 7]; const sort = (arr) => { let result = [...arr]; let i = 0; let length = result.length; for(i; i = left; j--){ result[j+1] = result[j]; } // 最后将当前值插入到正确位置 result[left] = current; } return result; } const newArr = sort(array); console.log(newArr); // [1, 2, 3, 4, 5, 6, 7, 8, 9] 快速排序 快速排序是一个效率很高而且面试中经常出现的排序，他的平均时间复杂度是O(nlogn)O(nlogn)O(nlogn)，最差时间复杂度是O(n2)O(n^2)O(n​2​​)。他的核心思想是选定一个基准值x，将比x小的值放到左边，比x大的值放到右边。假设我们有如下数组： const a = [3, 6, 2, 1, 4, 5, 9, 8, 7]; 我们每次都取数组的第一个值为x，然后将比他小的放到左边，大的放到右边。这里我们的第一个值3，经过这么一次运算后，我们期望的目标是得到类似这样一个数组： const a = [2, 1, 3, 6, 4, 5, 9, 8, 7]; 注意这个数组，3左边的都比3小，3右边的都比3大，左右两边里面的顺序可能是不对的，但是3本身的位置是对的。怎么来实现这个呢？我们用x把3暂存下来，然后使用两个指针i,j分别指向数组最开始和最后面。初始状态x = 3, i = 0, j = 8。 0 1 2 3 4 5 6 7 8 3 6 2 1 4 5 9 8 7 我们暂存了a[0]，就相当于把a[0]挖出来了，需要找一个数填进去。我们从后往前找，找一个比3小的数，我们发现a[3]是1(j=3)，比3小，将它填到a[0]的坑里。注意，这时候i=0, j=3。 0 1 2 3 4 5 6 7 8 1 6 2 1 4 5 9 8 7 a[3]被填到了a[0]的位置，相当于a[3]又被挖出来了，又需要找一个数来填充。这次我们从前往后找，找一个比x大的数，我们发现a[1]是6(i=1)，比x大，将它填到a[3]的位置。注意，这时候i=1, j=3。 0 1 2 3 4 5 6 7 8 1 6 2 6 4 5 9 8 7 这时候a[1]被填到了a[3]的位置，相当于a[1]又被挖出来了，又可以继续填充数字，我们继续从j的位置往前找一个小的。我们发现a[2]比3小，我们将a[2]填充到a[1]的位置。注意，这时候i=1, j=2; 0 1 2 3 4 5 6 7 8 1 2 2 6 4 5 9 8 7 a[2]填充到了a[1]，a[2]又空了，我们继续从前往后找一个大的数字填充进去，i开始自增，但是他自增一个之后就不小于j了。这说明我们整个数组已经遍历完了，循环结束。注意，i自增一次后不小于j，触发循环结束条件，此时i = 2。 而这时候的i就是我们最开始缓存的x应该在的位置，我们将x放入a[i]。 0 1 2 3 4 5 6 7 8 1 2 3 6 4 5 9 8 7 至此，一次遍历就找到了基准值应该在的位置，并且调整了数组，让基准值左边的数都比他小，右边的都比他大。我们来实现下这个方法。 const partition = (arr) => { let x = arr[0]; let length = arr.length; let i = 0; let j = length - 1; while(i x) { j--; } // 找到了，将值填入坑里, a[j]又变成了坑 if(i 在前面思路的基础上继续递归的对基准值左右两边调用这个调整方法，就能将数组的每个数字都放到正确的位置上，这就是快速排序，这种思想叫分治法。前面调整数组的方法我们需要进行微调，让他接受开始位置和结束位置并返回基准值的位置。 const partition = (arr, left, right) => { let x = arr[left]; let i = left; let j = right; while(i x) { j--; } // 找到了，将值填入坑里, a[j]又变成了坑 if(i { const length = arr.length; const start = left || 0; const end = right !== undefined ? right : length - 1; if(start 归并排序 归并排序比快速排序好理解，时间复杂度也是O(nlogn)O(nlogn)O(nlogn)，采用的思想也是分治法。假设我们已经有两个有序数组。 const a = [1 ,2, 6, 8]; const b = [3, 4, 9]; 我们现在写一个方法来得到a跟b组合后的有序数组，这个方法很简单，用两个指针i,j分别指向两个数组，然后开始遍历，比较a[i]和a[j]的大小，将小的那个放入新的有序数组。当任意一个数组遍历完，循环结束，将剩下的值全部放入新的有序数组: const merge = (arr1, arr2) => { const length1 = arr1.length; const length2 = arr2.length; const newArr = []; let i = 0; let j = 0; while(i 然后我们递归的将待排序数组分成左右两个数组，一直分到数组只含有一个元素为止，因为数组只含有一个元素，我们就可以认为他是有序的。 const mergeSort = (arr) => { const length = arr.length; if(length "},"Articles/DataStructureAndAlgorithm/LinkedList.html":{"url":"Articles/DataStructureAndAlgorithm/LinkedList.html","title":"链表","keywords":"","body":"链表是一种很常见的数据结构，React的Fiber也是采用链表树的数据结构来解决主线程阻塞的问题。它有一个头结点以及多个普通节点组成，每个节点有自己的值，还有一个next属性指向下一个节点，最后一个节点的next为null。链表就通过next将一个个节点连接起来的。 一个典型的JS链表如下： const NodeD = { value: 4, next: null }; const NodeC = { value: 3, next: NodeD }; const NodeB = { value: 2, next: NodeC }; const NodeA = { value: 1, next: NodeB }; const LinkedList = { head: NodeA }; 遍历链表 遍历链表是一个很简单的操作，从head开始，通过next一个一个往下走就行，下面我们来实现一下： // 遍历方法还接收一个参数作为回调，可以用来对每个值进行处理 const traversal = (linkedList, callback) => { const headNode = linkedList.head; let currentNode = headNode; while(currentNode.next) { callback(currentNode.value); currentNode = currentNode.next; } // 处理最后一个节点的值 callback(currentNode.value); } // 测试一下 let total = 0; const sum = (value) => total = total + value; traversal(LinkedList, sum); console.log(total); 链表有环 如果我们最后一个节点的next不是null，而是指向第一个节点，我们上面的遍历代码就会陷入死循环。那怎么来判断是不是有环呢？方法其实跟深拷贝处理循环引用很像: const hasCycle = (linkedList) => { const map = new WeakMap(); const headNode = linkedList.head; let current = headNode; while(current.next){ const exist = map.get(current); if(exist) return true; map.set(current, current.value); current = current.next; } return false; } // 用这个方法检测下前面的链表 console.log(hasCycle(LinkedList)); // false // 来检测一个有环的 const NodeB2 = { value: 2, }; const NodeA2 = { value: 1, next: NodeB2 }; NodeB2.next = NodeA2; const LinkedList2 = { head: NodeA2 }; console.log(hasCycle(LinkedList2)); // true 上面的检测方法需要一个map来记录所有遍历过的对象，所以空间复杂度是O(n)，还有一个算法可以将空间复杂度降到O(1)。我们可以用两个指针来同时遍历链表，第一个指针的前进速度是1，第二个指针的前进速度是2，如果有环，他们肯定可以相遇： const hasCycle2 = (linkedList) => { const headNode = linkedList.head; let pointer1 = headNode; let pointer2 = headNode; while(pointer1.next){ // pointer2跑得快，会先到尾部 // 如果他到尾部了，说明没环 if(!pointer2.next || !pointer2.next.next) { return false; } if(pointer1 === pointer2) { return ture; } pointer1 = pointer1.next; pointer2 = pointer2.next.next; } return false; } 未完待续。。。 "},"Articles/DataStructureAndAlgorithm/Greedy.html":{"url":"Articles/DataStructureAndAlgorithm/Greedy.html","title":"贪心算法","keywords":"","body":"贪心算法是一种很常见的算法思想，而且很好理解，因为它符合人们一般的思维习惯。下面我们由浅入深的来讲讲贪心算法。 找零问题 我们先来看一个比较简单的问题： 假设你是一个商店老板，你需要给顾客找零n元钱，你手上有的钱的面值为：100元，50元，20元，5元，1元。请问如何找零使得所需要的钱币数量最少？ 例子：你需要找零126元，则所需钱币数量最少的方案为100元1找，20元1张，5元1张，1元1张。 这个问题在生活中很常见，买东西的时候经常会遇到，那我们一般是怎么思考的呢？假设我们需要找零126元，我们先看看能找的最大面值是多少，我们发现126比100大，那肯定可以找一张100块，然后剩下26元，再看26能匹配的最大面值是多少，发现是20，那找一张20的，还剩6块，同样的思路，找一张5块的和1块的。这其实就是贪心算法的思想，每次都很贪心的去找最大的匹配那个值，然后再找次大的。这个算法代码也很好写： const allMoney = [100, 50, 20, 5, 1]; // 表示我们手上有的面值 function changeMoney(n, allMoney) { const length = allMoney.length; const result = []; // 存储结果的数组，每项表示对应面值的张数 for(let i = 0; i = allMoney[i]) { // 如果需要找的钱比面值大，那就可以找，除一下看看能找几张 result[i] = parseInt(n / allMoney[i]); n = n - result[i] * allMoney[i]; // 更新剩下需要找的钱 } else { // 否则不能找 result[i] = 0; } } return result; } const result = changeMoney(126, allMoney); console.log(result); // [1, 0, 1, 1, 1] 贪心算法 上面的找零问题就是贪心算法，每次都去贪最大面值的，发现贪不了了，再去贪次大的。从概念上讲，贪心算法是： 从上面的定义可以看出，并不是所有问题都可以用贪心算法来求解的，因为它每次拿到的只是局部最优解，局部最优解组合起来并不一定是全局最优解。下面我们来看一个这样的例子： 背包问题 背包问题也是一个很经典的算法问题，题目如下： 有一个小偷，他进到了一个店里要偷东西，店里有很多东西，每个东西的价值是v，每个东西的重量是w。但是小偷只有一个背包，他背包总共能承受的重量是W。请问怎么拿东西能让他拿到的价值最大？ 其实背包问题细分下来又可以分成两个问题：0-1背包和分数背包。 0-1背包：指的是对于某个商品来说，你要么不拿，要么全拿走，不能只拿一半或者只拿三分之二。可以将商品理解成金砖，你要么整块拿走，要么不拿，不能拿半块。 分数背包：分数背包就是跟0-1背包相反的，你可以只拿一部分，可以拿一半，也可以拿三分之二。可以将商品理解成金砂，可以只拿一部分。 下面来看个例子： 这个问题用我们平时的思维也很好想，要拿到总价值最大，那我们就贪呗，就拿最贵的，即价值除以重量的数最大的。但是每次都拿最贵的，是不是最后总价值最大呢？我们先假设上面的例子是0-1背包，最贵的是v1，然后是v2，v3。我们先拿v1, 背包还剩40，拿到总价值是60，然后拿v2，背包还剩20，拿到总价值是160。然后就拿不下了，因为v3的重量是30，我们背包只剩20了，装不下了。但是这个显然不是全局最优解，因为我们明显可以看出，如果我们拿v2，v3，背包刚好装满，总价值是220，这才是最优解。所以0-1背包问题不能用贪心算法。 但是分数背包可以用贪心，因为我们总是可以拿最贵的。我们先拿了v1, v2，发现v3装不下了，那就不装完了嘛，装三分之二就行了。下面我们用贪心来实现一个分数背包： const products = [ {id:1, v: 60, w: 10}, {id:2, v: 100, w: 20}, {id:3, v: 120, w: 30} ]; // 新建一个数组表示商品列表，每个商品加个id用于标识 function backpack(W, products) { const sortedProducts = products.sort((product1, product2) => { const price1 = product1.v / product1.w; const price2 = product2.v / product2.w; if(price1 > price2) { return -1; } else if(price1 = sortedProduct.w) { // 整个拿完 result.push({ id: sortedProduct.id, take: 1, // 拿的数量 }); W = W - sortedProduct.w; allValue = allValue + sortedProduct.v; } else if(W > 0) { // 只能拿一部分 result.push({ id: sortedProduct.id, take: W / sortedProduct.w, }); allValue = allValue + sortedProduct.v * (W / sortedProduct.w); W = 0; // 装满了 } else { // 不能拿了 result.push({ id: sortedProduct.id, take: 0, }); } } return {result: result, allValue: allValue}; } // 测试一下 const result = backpack(50, products); console.log(result); 运行结果： 0-1背包 前面讲过0-1背包不能用贪心求解，我们这里还是讲讲他怎么来求解吧。要解这个问题需要用到动态规划的思想，关于动态规划的思想，可以看看我这篇文章，如果你只想看看贪心算法，可以跳过这一部分。假设我们背包放了n个商品，W是我们背包的总容量，我们这时拥有的总价值是D(n,W)D(n, W)D(n,W)。我们考虑最后一步， 假如我们不放最后一个商品，则总价值为D(n−1,W)D(n-1, W)D(n−1,W) 假设我们放了最后一个商品，则总价值为最后一个商品加上前面已经放了的价值，表示为vn+D(n−1,W−wn)v_n + D(n-1, W-w_n)v​n​​+D(n−1,W−w​n​​)，这时候需要满足的条件是W>=wn W >= w_nW>=w​n​​，即最后一个要放得下。 我们要求的最大解其实就是上述两个方案的最大值，表示如下： D(n,W)=max(D(n−1,W),vn+D(n−1,W−wn)) D(n, W) = max(D(n-1, W), v_n + D(n-1, W-w_n)) D(n,W)=max(D(n−1,W),v​n​​+D(n−1,W−w​n​​)) 递归解法 有了递推公式，我们就可以用递归解法了： const products = [ {id:1, v: 60, w: 10}, {id:2, v: 100, w: 20}, {id:3, v: 120, w: 30} ]; // 新建一个数组表示商品列表，每个商品加个id用于标识 function backpack01(n, W, products) { if(n = products[n].w){ // 如果最后一个放得下 getLast = products[n].v + backpack01(n-1, W-products[n].w, products); } const result = Math.max(noLast, getLast); return result; } // 测试一下 const result = backpack01(products.length-1, 50, products); console.log(result); // 220 动态规划 递归的复杂度很高，我们用动态规划重写一下： const products = [ {id:1, v: 60, w: 10}, {id:2, v: 100, w: 20}, {id:3, v: 120, w: 30} ]; // 新建一个数组表示商品列表，每个商品加个id用于标识 function backpack01(W, products) { const d = []; // 初始化一个数组放计算中间值，其实为二维数组，后面填充里面的数组 const length = products.length; // i表示行，为商品个数，数字为 0 -- (length - 1) // j表示列，为背包容量，数字为 0 -- W for(let i = 0; i = products[i].w) { // 可以放下第一个商品 d[i][j] = products[i].v; } else { d[i][j] = 0; } } else { const noLast = d[i-1][j]; let getLast = 0; if(j >= products[i].w) { getLast = products[i].v + d[i-1][j - products[i].w]; } if(noLast > getLast) { d[i][j] = noLast; } else { d[i][j] = getLast; } } } } console.log(d); return d[length-1][W]; } // 测试一下 const result = backpack01(50, products); console.log(result); // 220 回溯最优解 为了能够输出最优解，我们需要将每个最后放入的商品记录下来，然后从最后往前回溯，将前面的代码改造如下： const products = [ {id:1, v: 60, w: 10}, {id:2, v: 100, w: 20}, {id:3, v: 120, w: 30} ]; // 新建一个数组表示商品列表，每个商品加个id用于标识 function backpack01(W, products) { const d = []; // 初始化一个数组放计算中间值，其实为二维数组，后面填充里面的数组 const res = []; // 记录每次放入的最后一个商品, 同样为二维数组 const length = products.length; // i表示行，为商品个数，数字为 0 -- (length - 1) // j表示列，为背包容量，数字为 0 -- W for(let i = 0; i = products[i].w) { // 可以放下第一个商品 d[i][j] = products[i].v; res[i][j] = products[i]; } else { d[i][j] = 0; res[i][j] = null; } } else { const noLast = d[i-1][j]; let getLast = 0; if(j >= products[i].w) { getLast = products[i].v + d[i-1][j - products[i].w]; } if(noLast > getLast) { d[i][j] = noLast; } else { d[i][j] = getLast; res[i][j] = products[i]; // 记录最后一个商品 } } } } // 回溯res, 得到最优解 let tempW = W; let tempI = length - 1; const bestSol = []; while (tempW > 0 && tempI >= 0) { const last = res[tempI][tempW]; bestSol.push(last); tempW = tempW - last.w; tempI = tempI - 1; } console.log(d); console.log(bestSol); return { totalValue: d[length-1][W], solution: bestSol } } // 测试一下 const result = backpack01(50, products); console.log(result); // 220 上面代码的输出： 数字拼接问题 再来看一个贪心算法的问题，加深下理解，这个问题如下： 这个问题看起来也不难，我们有时候也会遇到类似的问题，我们可以很直观的想到一个解法：看哪个数字的第一个数字大，把他排前面，比如32和94，把第一位是9的94放前面，得到9432，肯定比32放前面的3294大。这其实就是按照字符串大小来排序嘛，字符大的排前面，但是这种解法正确吗？我们再来看两个数字，假如我们有728和7286，按照字符序，7286排前面，得到7286728，但是这个值没有728放前面的7287286大。说明单纯的字符序是搞不定这个的，对于两个数字a,b，如果他们的长度一样，那按照字符序就没问题，如果他们长度不一样，这个解法就不一定对了，那怎么办呢？其实也简单，我们看看a+b和b+a拼成的数字，哪个大就行了。 假设 a = 728 b = 7286 字符串： a + b = \"7287286\" 字符串： b + a = \"7286728\" 比较下这两个字符串, a + b比较大，a放前面就行了, 反之放到后面 上述算法就是一个贪心，这里贪的是什么的？贪的是a + b的值，要大的那个。在实现的时候，可以自己写个冒泡，也可以直接用数组的sort方法: const nums = [32, 94, 128, 1286, 6, 71]; function getBigNum(nums) { nums.sort((a, b) => { const ab = `${a}${b}`; const ba = `${b}${a}`; if(ab > ba) { return -1; // ab大，a放前面 } else if (ab 活动选择问题 活动选择问题稍微难一点，也可以用贪心，但是需要贪的东西没前面的题目那么直观，我们先来看看题目： 这个问题应该这么思考：为了能尽量多的安排活动，我们在安排一个活动时，应该尽量给后面的活动多留时间，这样后面有机会可以安排更多的活动。换句话说就是，应该把结束时间最早的活动安排在第一个，再剩下的时间里面继续安排结束时间早的活动。这里的贪心其实贪的就是结束时间早的，这个结论其实可以用数学来证明的： 下面来实现下代码： const activities = [ {start: 1, end: 4}, {start: 3, end: 5}, {start: 0, end: 6}, {start: 5, end: 7}, {start: 3, end: 9}, {start: 5, end: 9}, {start: 6, end: 10}, {start: 8, end: 11}, {start: 8, end: 12}, {start: 2, end: 14}, {start: 12, end: 16}, ]; function chooseActivity(activities) { // 先按照结束时间从小到大排序 activities.sort((act1, act2) => { if(act1.end act2.end) { return 1; } return 0; }); const res = []; // 接收结果的数组 let lastEnd = 0; // 记录最后一个活动的结束时间 for(let i = 0; i = lastEnd) { res.push(act); lastEnd = act.end } } return res; } // 测试一下 const result = chooseActivity(activities); console.log(result); 上面代码的运行结果如下： 总结 贪心算法的重点就在一个贪字，要找到贪的对象，然后不断的贪，最后把目标贪完，输出最优解。要注意的是，每次贪的时候其实拿到的都只是局部最优解，局部最优解不一定组成全局最优解，比如0-1背包，对于这种问题是不能用贪心的，要用其他方法求解。 "},"Articles/DataStructureAndAlgorithm/DP.html":{"url":"Articles/DataStructureAndAlgorithm/DP.html","title":"动态规划","keywords":"","body":"动态规划是一种常用的算法思想，很多朋友觉得不好理解，其实不然，如果掌握了他的核心思想，并且多多练习还是可以掌握的。下面我们从几个例题由浅入深的来讲讲动态规划。 斐波拉契数列 首先我们来看看斐波拉契数列，这是一个大家都很熟悉的数列： // f = [1, 1, 2, 3, 5, 8] f(1) = 1; f(2) = 1; f(n) = f(n-1) + f(n -2); // n > 2 有了上面的公式，我们很容易写出计算f(n)的递归代码： function fibonacci_recursion(n) { if(n === 1 || n === 2) { return 1; } return fibonacci_recursion(n - 1) + fibonacci_recursion(n - 2); } const res = fibonacci_recursion(5); console.log(res); // 5 现在我们考虑一下上面的计算过程，计算f(5)的时候需要f(4)与f(3)的值，计算f(4)的时候需要f(3)与f(2)的值，这里f(3)就重复算了两遍。在我们已知f(1)和f(2)的情况下，我们其实只需要计算f(3)，f(4)，f(5)三次计算就行了，但是从下图可知，为了计算f(5)，我们总共计算了8次其他值，里面f(3), f(2), f(1)都有多次重复计算。如果n不是5，而是一个更大的数，计算次数更是指数倍增长，这个递归算法的时间复杂度是O(2n)O(2^n)O(2​n​​)。 非递归的斐波拉契数列 为了解决上面指数级的时间复杂度，我们不能用递归算法了，而要用一个普通的循环算法。应该怎么做呢？我们只需要加一个数组，里面记录每一项的值就行了，为了让数组与f(n)的下标相对应，我们给数组开头位置填充一个0： const res = [0, 1, 1]; f(n) = res[n]; 我们需要做的就是给res数组填充值，然后返回第n项的值就行了: function fibonacci_no_recursion(n) { const res = [0, 1, 1]; for(let i = 3; i 上面的方法就没有重复计算的问题，因为我们把每次的结果都存到一个数组里面了，计算f(n)的时候只需要将f(n-1)和f(n-2)拿出来用就行了，因为是从小往大算，所以f(n-1)和f(n-2)的值之前就算好了。这个算法的时间复杂度是O(n)，比O(2n)O(2^n)O(2​n​​)好的多得多。这个算法其实就用到了动态规划的思想。 动态规划 动态规划主要有如下两个特点 最优子结构：一个规模为n的问题可以转化为规模比他小的子问题来求解。换言之，f(n)可以通过一个比他规模小的递推式来求解，在前面的斐波拉契数列这个递推式就是f(n) = f(n-1) + f(n -2)。一般具有这种结构的问题也可以用递归求解，但是递归的复杂度太高。 子问题的重叠性：如果用递归求解，会有很多重复的子问题，动态规划就是修剪了重复的计算来降低时间复杂度。但是因为需要存储中间状态，空间复杂度是增加了。 其实动态规划的难点是归纳出递推式，在斐波拉契数列中，递推式是已经给出的，但是更多情况递推式是需要我们自己去归纳总结的。 钢条切割问题 先看看暴力穷举怎么做，以一个长度为5的钢条为例： 上图红色的位置表示可以下刀切割的位置，每个位置可以有切和不切两种状态，总共是24=162^4 = 162​4​​=16种，对于长度为n的钢条，这个情况就是2n−12^{n-1}2​n−1​​种。穷举的方法就不写代码了，下面直接来看递归的方法： 递归方案 还是以上面那个长度为5的钢条为例，假如我们只考虑切一刀的情况，这一刀的位置可以是1，2，3，4中的任意位置，那切割之后，左右两边的长度分别是： // [left, right]: 表示切了后左边，右边的长度 [1, 4]: 切1的位置 [2, 3]: 切2的位置 [3, 2]: 切3的位置 [4, 1]: 切4的位置 分成了左右两部分，那左右两部分又可以继续切，每部分切一刀，又变成了两部分，又可以继续切。这不就将一个长度为5的问题，分解成了4个小问题吗，那最优的方案就是这四个小问题里面最大的那个值，同时不要忘了我们也可以一刀都不切，这是第五个小问题，我们要的答案其实就是这5个小问题里面的最大值。写成公式就是，对于长度为n的钢条，最佳收益公式是： rnr_nr​n​​ : 表示我们求解的目标，长度为n的钢条的最大收益 pnp_np​n​​: 表示钢条完全不切的情况 r1+rn−1r_1 + r_{n-1}r​1​​+r​n−1​​: 表示切在1的位置，分为了左边为1，右边为n-1长度的两端，他们的和是这种方案的最优收益 我们的最大收益就是不切和切在不同情况的子方案里面找最大值 上面的公式已经可以用递归求解了： const p = [0, 1, 5, 8, 9, 10, 17, 17, 20, 24, 30]; // 下标表示钢条长度，值表示对应价格 function cut_rod(n) { if(n === 1) return 1; let max = p[n]; for(let i = 1; i max) { max = sum; } } return max; } cut_rod(9); // 返回 25 上面的公式还可以简化，假如我们长度9的最佳方案是切成2 3 2 2，用前面一种算法，第一刀将它切成2 7和5 4，然后两边再分别切最终都可以得到2 3 2 2，所以5 4方案最终结果和2 7方案是一样的，都会得到2 3 2 2，如果这两种方案，两边都继续切，其实还会有重复计算。那长度为9的切第一刀，左边的值肯定是1 -- 9，我们从1依次切过来，如果后面继续对左边的切割，那继续切割的那个左边值必定是我们前面算过的一个左边值。比如5 4切割成2 3 4，其实等价于第一次切成2 7，第一次如果是3 6,如果继续切左边，切为1 2 6，其实等价于1 8，都是前面切左边为1的时候算过的。所以如果我们左边依次是从1切过来的，那么就没有必要再切左边了，只需要切右边。所以我们的公式可以简化为： rn=max1=i=n(pi+rn−i) r_n = \\max_{1r​n​​=​1=i=n​max​​(pi+r​n−i​​) 继续用递归实现这个公式： const p = [0, 1, 5, 8, 9, 10, 17, 17, 20, 24, 30]; // 下标表示钢条长度，值表示对应价格 function cut_rod2(n) { if(n === 1) return 1; let max = p[n]; for(let i = 1; i max) { max = sum; } } return max; } cut_rod2(9); // 结果还是返回 25 上面的两个公式都是递归，复杂度都是指数级的，下面我们来讲讲动态规划的方案。 动态规划方案 动态规划方案的公式和前面的是一样的，我们用第二个简化了的公式： rn=max1=i=n(pi+rn−i) r_n = \\max_{1r​n​​=​1=i=n​max​​(pi+r​n−i​​) 动态规划就是不用递归，而是从底向上计算值，每次计算上面的值的时候，下面的值算好了，直接拿来用就行。所以我们需要一个数组来记录每个长度对应的最大收益。 const p = [0, 1, 5, 8, 9, 10, 17, 17, 20, 24, 30]; // 下标表示钢条长度，值表示对应价格 function cut_rod3(n) { let r = [0, 1]; // r数组记录每个长度的最大收益 for(let i = 2; i max) { max = sum; } } r[i] = max; } console.log(r); return r[n]; } cut_rod3(9); // 结果还是返回 25 我们还可以把r数组也打出来看下，这里面存的是每个长度对应的最大收益： r = [0, 1, 5, 8, 10, 13, 17, 18, 22, 25] 使用动态规划将递归的指数级复杂度降到了双重循环，即O(n2)O(n^2)O(n​2​​)的复杂度。 输出最佳方案 上面的动态规划虽然计算出来最大值，但是我们并不是知道这个最大值对应的切割方案是什么，为了知道这个方案，我们还需要一个数组来记录切割一次时左边的长度，然后在这个数组中回溯来找出切割方案。回溯的时候我们先取目标值对应的左边长度，然后右边剩下的长度又继续去这个数组找最优方案对应的左边切割长度。假设我们左边记录的数组是： leftLength = [0, 1, 2, 3, 2, 2, 6, 1, 2, 3] 我们要求长度为9的钢条的最佳切割方案： 1. 找到leftLength[9], 发现值为3，记录下3为一次切割 2. 左边切了3之后，右边还剩6，又去找leftLength[6]，发现值为6，记录下6为一次切割长度 3. 又切了6之后，发现还剩0，切完了，结束循环；如果还剩有钢条继续按照这个方式切 4. 输出最佳长度为[3, 6] 改造代码如下： const p = [0, 1, 5, 8, 9, 10, 17, 17, 20, 24, 30]; // 下标表示钢条长度，值表示对应价格 function cut_rod3(n) { let r = [0, 1]; // r数组记录每个长度的最大收益 let leftLength = [0, 1]; // 数组leftLength记录切割一次时左边的长度 let solution = []; for(let i = 2; i max) { max = sum; leftLength[i] = j; // 每次找到大的值，记录左边的长度 } } r[i] = max; } // 回溯寻找最佳方案 let tempN = n; while(tempN > 0) { let left = leftLength[tempN]; solution.push(left); tempN = tempN - left; } console.log(leftLength); // [0, 1, 2, 3, 2, 2, 6, 1, 2, 3] console.log(solution); // [3, 6] console.log(r); // [0, 1, 5, 8, 10, 13, 17, 18, 22, 25] return {max: r[n], solution: solution}; } cut_rod3(9); // {max: 25, solution: [3, 6]} 最长公共子序列（LCS） 上叙问题也可以用暴力穷举来求解，先列举出X字符串所有的子串，假设他的长度为m，则总共有2m2^m2​m​​种情况，因为对于X字符串中的每个字符都有留着和不留两种状态，m个字符的全排列种类就是2m2^m2​m​​种。那对应的Y字符串就有2n2^n2​n​​种子串, n为Y的长度。然后再遍历找出最长的公共子序列，这个复杂度非常高，我这里就不写了。 我们观察两个字符串，如果他们最后一个字符相同，则他们的LCS(最长公共子序列简写)就是两个字符串都去掉最后一个字符的LCS再加一。因为最后一个字符相同，所以最后一个字符是他们的子序列，把他去掉，子序列就少了一个，所以他们的LCS是他们去掉最后一个字符的字符串的LCS再加一。如果他们最后一个字符不相同，那他们的LCS就是X去掉最后一个字符与Y的LCS，或者是X与Y去掉最后一个字符的LCS，是他们两个中较长的那一个。写成数学公式就是： 看着这个公式，一个规模为(i, j)的问题转化为了规模为(i-1, j-1)的问题，这不就又可以用递归求解了吗？ 递归方案 公式都有了，不废话，直接写代码： function lcs(str1, str2) { let length1 = str1.length; let length2 = str2.length; if(length1 === 0 || length2 === 0) { return 0; } let shortStr1 = str1.slice(0, -1); let shortStr2 = str2.slice(0, -1); if(str1[length1 - 1] === str2[length2 - 1]){ return lcs(shortStr1, shortStr2) + 1; } else { let lcsShort2 = lcs(str1, shortStr2); let lcsShort1 = lcs(shortStr1, str2); return lcsShort1 > lcsShort2 ? lcsShort1 : lcsShort2; } } let result = lcs('ABBCBDE', 'DBBCD'); console.log(result); // 4 动态规划 递归虽然能实现我们的需求，但是复杂度是在太高，长一点的字符串需要的时间是指数级增长的。我们还是要用动态规划来求解，根据我们前面讲的动态规划原理，我们需要从小的往大的算，每算出一个值都要记下来。因为c(i, j)里面有两个变量，我们需要一个二维数组才能存下来。注意这个二维数组的行数是X的长度加一，列数是Y的长度加一，因为第一行和第一列表示X或者Y为空串的情况。代码如下： function lcs2(str1, str2) { let length1 = str1.length; let length2 = str2.length; // 构建一个二维数组 // i表示行号，对应length1 + 1 // j表示列号， 对应length2 + 1 // 第一行和第一列全部为0 let result = []; for(let i = 0; i result[i - 1][j] ? result[i][j - 1] : result[i - 1][j]; } } } console.log(result); return result[length1][length2] } let result = lcs2('ABCBDAB', 'BDCABA'); console.log(result); // 4 上面的result就是我们构造出来的二维数组，对应的表格如下，每一格的值就是c(i, j)，如果Xi=YjX_i = Y_jX​i​​=Y​j​​，则它的值就是他斜上方的值加一，如果Xi≠YiX_i \\neq Y_iX​i​​≠Y​i​​，则它的值是上方或者左方较大的那一个。 输出最长公共子序列 要输出LCS，思路还是跟前面切钢条的类似，把每一步操作都记录下来，然后再回溯。为了记录操作我们需要一个跟result二维数组一样大的二维数组，每个格子里面的值是当前值是从哪里来的，当然，第一行和第一列仍然是0。每个格子的值要么从斜上方来，要么上方，要么左方，所以： 1. 我们用1来表示当前值从斜上方来 2. 我们用2表示当前值从左方来 3. 我们用3表示当前值从上方来 看代码： function lcs3(str1, str2) { let length1 = str1.length; let length2 = str2.length; // 构建一个二维数组 // i表示行号，对应length1 + 1 // j表示列号， 对应length2 + 1 // 第一行和第一列全部为0 let result = []; let comeFrom = []; // 保存来历的数组 for(let i = 0; i result[i - 1][j]){ // 最后一个字符不同,值是左边的大 result[i][j] = result[i][j - 1]; comeFrom[i][j] = 2; } else { // 最后一个字符不同,值是上边的大 result[i][j] = result[i - 1][j]; comeFrom[i][j] = 3; } } } console.log(result); console.log(comeFrom); // 回溯comeFrom数组，找出LCS let pointerI = length1; let pointerJ = length2; let lcsArr = []; // 一个数组保存LCS结果 while(pointerI > 0 && pointerJ > 0) { console.log(pointerI, pointerJ); if(comeFrom[pointerI][pointerJ] === 1) { lcsArr.push(str1[pointerI - 1]); pointerI--; pointerJ--; } else if(comeFrom[pointerI][pointerJ] === 2) { pointerI--; } else if(comeFrom[pointerI][pointerJ] === 3) { pointerJ--; } } console.log(lcsArr); // [\"B\", \"A\", \"D\", \"B\"] //现在lcsArr顺序是反的 lcsArr = lcsArr.reverse(); return { length: result[length1][length2], lcs: lcsArr.join('') } } let result = lcs3('ABCBDAB', 'BDCABA'); console.log(result); // {length: 4, lcs: \"BDAB\"} 最短编辑距离 这是leetcode上的一道题目，题目描述如下： 这道题目的思路跟前面最长公共子序列非常像，我们同样假设第一个字符串是X=(x1,x2...xm)X=(x_1, x_2 ... x_m)X=(x​1​​,x​2​​...x​m​​),第二个字符串是Y=(y1,y2...yn)Y=(y_1, y_2 ... y_n)Y=(y​1​​,y​2​​...y​n​​)。我们要求解的目标为rrr, r[i][j]r[i][j]r[i][j]为长度为iii的XXX和长度为jjj的YYY的解。我们同样从两个字符串的最后一个字符开始考虑： 如果他们最后一个字符是一样的，那最后一个字符就不需要编辑了，只需要知道他们前面一个字符的最短编辑距离就行了，写成公式就是：如果Xi=YjXi = Y_jXi=Y​j​​，r[i][j]=r[i−1][j−1]r[i][j] = r[i-1][j-1]r[i][j]=r[i−1][j−1]。 如果他们最后一个字符是不一样的，那最后一个字符肯定需要编辑一次才行。那最短编辑距离就是XXX去掉最后一个字符与YYY的最短编辑距离，再加上最后一个字符的一次；或者是是YYY去掉最后一个字符与XXX的最短编辑距离，再加上最后一个字符的一次，就看这两个数字哪个小了。这里需要注意的是XXX去掉最后一个字符或者YYY去掉最后一个字符，相当于在YYY上进行插入和删除，但是除了插入和删除两个操作外，还有一个操作是替换，如果是替换操作，并不会改变两个字符串的长度，替换的时候，距离为r[i][j]=r[i−1][j−1]+1r[i][j]=r[i-1][j-1]+1r[i][j]=r[i−1][j−1]+1。最终是在这三种情况里面取最小值，写成数学公式就是：如果Xi≠YjXi \\neq Y_jXi≠Y​j​​，r[i][j]=min(r[i−1][j],r[i][j−1],r[i−1][j−1])+1r[i][j] = \\min(r[i-1][j], r[i][j-1],r[i-1][j-1]) + 1r[i][j]=min(r[i−1][j],r[i][j−1],r[i−1][j−1])+1。 最后就是如果XXX或者YYY有任意一个是空字符串，那为了让他们一样，就往空的那个插入另一个字符串就行了，最短距离就是另一个字符串的长度。数学公式就是：如果i=0i=0i=0，r[i][j]=jr[i][j] = jr[i][j]=j；如果j=0j=0j=0，r[i][j]=ir[i][j] = ir[i][j]=i。 上面几种情况总结起来就是 r[i][j]={j,if i=0i,if j=0r[i−1][j−1],if Xi=Yjmin(r[i−1][j],r[i][j−1],r[i−1][j−1])+1,if Xi≠Yj r[i][j]= \\begin{cases} j, & \\text{if}\\ i=0 \\\\ i, & \\text{if}\\ j=0 \\\\ r[i-1][j-1], & \\text{if}\\ X_i=Y_j \\\\ \\min(r[i-1][j], r[i][j-1], r[i-1][j-1]) + 1, & \\text{if} \\ X_i\\neq Y_j \\end{cases} r[i][j]=​⎩​⎪​⎪​⎪​⎨​⎪​⎪​⎪​⎧​​​j,​i,​r[i−1][j−1],​min(r[i−1][j],r[i][j−1],r[i−1][j−1])+1,​​​if i=0​if j=0​if X​i​​=Y​j​​​if X​i​​≠Y​j​​​​ 递归方案 老规矩，有了递推公式，我们先来写个递归： const minDistance = function(str1, str2) { const length1 = str1.length; const length2 = str2.length; if(!length1) { return length2; } if(!length2) { return length1; } const shortStr1 = str1.slice(0, -1); const shortStr2 = str2.slice(0, -1); const isLastEqual = str1[length1-1] === str2[length2-1]; if(isLastEqual) { return minDistance(shortStr1, shortStr2); } else { const shortStr1Cal = minDistance(shortStr1, str2); const shortStr2Cal = minDistance(str1, shortStr2); const updateCal = minDistance(shortStr1, shortStr2); const minShort = shortStr1Cal 动态规划 上面的递归方案提交到leetcode会直接超时，因为复杂度太高了，指数级的。还是上我们的动态规划方案吧，跟前面类似，需要一个二维数组来存放每次执行的结果。 const minDistance = function(str1, str2) { const length1 = str1.length; const length2 = str2.length; if(!length1) { return length2; } if(!length2) { return length1; } // i 为行，表示str1 // j 为列，表示str2 const r = []; for(let i = 0; i 上述代码因为是双重循环，所以时间复杂度是O(mn)O(mn)O(mn)。 总结 动态规划的关键点是要找出递推式，有了这个递推式我们可以用递归求解，也可以用动态规划。用递归时间复杂度通常是指数级增长，所以我们有了动态规划。动态规划的关键点是从小往大算，将每一个计算记过的值都记录下来，这样我们计算大的值的时候直接就取到前面计算过的值了。动态规划可以大大降低时间复杂度，但是增加了一个存计算结果的数据结构，空间复杂度会增加。这也算是一种用空间换时间的策略了。 "},"Articles/DataStructureAndAlgorithm/OptimizeVariations.html":{"url":"Articles/DataStructureAndAlgorithm/OptimizeVariations.html","title":"三层商品选项优化","keywords":"","body":"这段时间写了一堆源码解析，这篇文章想换换口味，跟大家分享一个我工作中遇到的案例。毕竟作为一个打工人，上班除了摸鱼看源码外，砖还是要搬的。本文会分享一个使用恰当的数据结构来进行性能优化，从而大幅提高响应速度的故事，提高有几百倍那么多。 事情是这样的，我现在供职一家外企，我们有一个给外国人用的线下卖货的APP，卖的商品有衣服，鞋子，可乐什么的。某天，产品经理找到我，提了一个需求：需要支持三层的产品选项。听到这个需求，我第一反应是我好像没有见到过三层的产品选项，毕竟我也是一个十来年的资深剁手党，一般的产品选项好像最多两层，比如下面是某电商APP一个典型的鞋子的选项： 这个鞋子就是两层产品选项，一个是颜色，一个是尺码，颜色总共有11种，尺码总共也是11种。为了验证我的直觉，我把我手机上所有的购物APP，啥淘宝，京东，拼多多，苏宁易购全部打开看了一遍。在我看过的商品中，没有发现一个商品有三层选项的，最多也就两层。 为什么没人做三层选项？ 一两家不做这个，可能是各家的需求不一样，但是大家都不做，感觉事情不对头。经过仔细分析后，我觉得不做三层选项可能有以下两个原因： 1. 这可能是个伪需求 上面这个鞋子有11种颜色，11种尺码，意味着这些选项后面对应的是11 * 11，总共121个商品。如果再来个第三层选项，假设第三层也有11个选项，那对应的商品总共就是11 * 11 * 11，也就是1331个商品，好多店铺总共可能都没有1331个商品。也就是说，第三层选项可能是个伪需求，用户并没有那么多选项放在第三层，还是以上面的鞋子为例，除了颜色，尺码外，非要再添一个层级，那只能是性别了，也就是男鞋和女鞋。对于男鞋和女鞋来说，版型，尺码这些很不一样，一般都不会放到一个商品下面，更常用的做法是分成两个商品，各自有自己的颜色和尺码。 2. 有性能问题 仅仅是加上第三层选项这个功能并没有什么难的，也就是多展示几个可以点击的按钮而已，点击逻辑跟两层选项并没有太大区别。但是细想下去，我发现了他有潜在的性能问题。以上面这双鞋子为例，我从后端API拿到的数据是这样的： const merchandise = { // variations存放的是所有选项 variations: [ { name: '颜色', values: [ { name: '限量版574海军蓝' }, { name: '限量版574白粉' }, // 下面还有9个 ] }, { name: '尺码', values: [ { name: '38' }, { name: '39' }, // 下面还有9个 ] }, ], // products数组存放的是所有商品 products: [ { id: 1, price: 208, // 与上面variations的对应关系在每个商品的variationMappings里面 variationMappings: [ { name: '颜色', value: '限量版574白粉' }, { name: '尺码', value: '38'}, ] }, // 下面还有一百多个产品 ] } 上面这个结构本身还是挺清晰的，merchandise.variations是一个数组，有几层选项，这个数组就有几个对象，每个对象的name就是当前层级的名字，values就是当前层级包含的选项，所以merchandise.variations可以直接拿来显示在UI上，将他们按照层级渲染成按钮就行。 上面图片中，用户选择了第一层的限量版574白粉，第二层的40，41等不存在的商品就自动灰掉了。用上面的数据结构可以做到这个功能，当用户选择限量版574白粉的时候，我们就去遍历merchandise.products这个数组，这个数组的一个项就是一个商品，这个商品上的variationMappings会有当前商品的颜色和尺码信息。对于我当前的项目来说，如果这个商品可以卖，他就会在merchandise.products这个数组里面，如果不可以卖，这个数组里面压根就不会有这个商品。比如上图的限量版574白粉，40码的组合就不会出现在merchandise.products里面，查找的时候找不到这个组合，那就会将它变为灰色，不可以点。 所以对于限量版574白粉，40这个鞋子来说，为了知道它需不需要灰掉，我需要整个遍历merchandise.products这个数组。按照前面说的11个颜色，11个尺码来说，最多会有121个商品，也就是最多查找121次。同样的要知道限量版574白粉，41这个商品可以不可以卖，又要整个遍历商品数组，11个尺码就需要将商品数组整个遍历11次。对于两层选项来说，11 * 11已经算比较多的了，每个尺码百来次运算可能还不会有严重的性能问题。但是如果再加一层选项，新加这层假如也有11个可选项，这复杂度瞬间就增加了一个指数，从O(n2)O(n^2)O(n​2​​)变成O(n3)O(n^3)O(n​3​​)！现在我们的商品总数是11 * 11 * 11，也就是1331个商品，假如第三层是性别，现在为了知道限量版574白粉，40，男性这个商品可不可以卖，我需要遍历1331个商品，如果遍历121个商品需要20ms，还比较流畅，那遍历1331个商品就需要220ms，这明显可以感觉到卡顿了，在某些硬件较差的设备上，这种卡顿会更严重，变得不可接受了。而且我们APP使用的技术是React Native，本身性能就比原生差，这样一来，用户可能就怒而卸载了！ 我拿着上述对需求的疑问，和对性能的担心找到了产品经理，发生了如下对话： 我：大佬，我发现市面上好像没有APP支持三层选项的，这个需求是不是有问题哦，而且三层选项相较于两层选项来说，复杂度是指数增长，可能会有性能问题，用户用起来会卡的。 产品经理：兄弟，你看的都是国内的APP，但是我们这个是给外国人用的，人家外国人就是习惯这么用，咱要想卖的出去就得满足他们的需求。太卡了肯定不行，性能问题，想办法解决嘛，这就是在UI上再加几个按钮，设计图都跟以前是一样的，给你两天时间够了吧~ 我：啊！？额。。。哦。。。 咱也不认识几个外国人，咱也不敢再问，都说了是用户需求，咱必须满足了产品才卖的出去，产品卖出去了咱才有饭吃，想办法解决吧！ 解决方案 看来这个需求是必须要做了，这个功能并不复杂，因为三层选项可以沿用两层选项的方案，继续去遍历商品数组，但是这个复杂度增长是指数级的，即从O(n2)O(n^2)O(n​2​​)变成O(n3)O(n^3)O(n​3​​)，用户用起来会卡。现在，我需要思考一下，有没有其他方案可以提高性能。经过仔细思考，我发现，这种指数级的复杂度增长是来自于我们整个数组的遍历，如果我能够找到一个方法不去遍历这个数组，立即就能找到限量版574白粉，40，男性对应的商品存不存在就好了。 这个具体的问题转换一下，其实就是：在一个数组中，通过特定的过滤条件，查找符合条件的一个项。嗯，查找，听起来蛮耳熟的，现在我之所以需要去遍历这个数组，是因为这些查找条件跟商品间没有一个直接的对应关系，如果我能建立一个直接的对应关系，不就可以一下就找到了吗？我想到了：查找树。假如我重组这些层级关系，将它们组织为一颗树，每个商品都对应树上的一个叶子节点，我可以将三层选项的查找复杂度从O(n3)O(n^3)O(n​3​​)降到O(1)O(1)O(1)。 两层查找树 为了说明白这个算法，我先简化这个问题，假设我们现在有两层选项，颜色和尺码，每层选项有两个可选项： 颜色：白色，红色 尺码：39，40 我们现在对应有4个商品： 一号商品：productId为1，白色，39码 二号商品：productId为2，白色，40码 三号商品：productId为3，红色，39码 四号商品：productId为4，红色，40码 如果按照最简单的做法，为了查找红色的39码鞋子存不存在，我们需要遍历所有的这四个商品，这时候的时间复杂度为O(n2)O(n^2)O(n​2​​)。但是如果我们构建像下面这样一颗树，可以将时间复杂度降到O(1)O(1)O(1)： 上面这颗树，我们忽略root节点，在本例中他并没有什么用，仅仅是一个树的入口，这棵树的第一层淡黄色节点是我们第一层选项颜色，第二层淡蓝色节点是我们的第二层选项尺码，只是每个颜色节点都会对应所有的尺码，这样我们最后第二层的叶子节点其实就对应了具体的商品。现在我们要查找红色的39码鞋子，只需要看图中红色箭头指向的节点上有没有商品就行了。 那这种数据结构在JS中该怎么表示呢？其实很简单，一个对象就行了，像这样： const tree = { \"颜色：白色\": { \"尺码：39\": { productId: 1 }, \"尺码：40\": { productId: 2 } }, \"颜色：红色\": { \"尺码：39\": { productId: 3 }, \"尺码：40\": { productId: 4 } } } 有了上面这个数据结构，我们要查找红色的39码直接取值tree[\"颜色：红色\"][\"尺码：39\"]就行了，这个复杂度瞬间就变为O(1)O(1)O(1)了。 三层查找树 理解了上面的两层查找树，要将它扩展到三层就简单了，直接再加一层就行了。假如我们现在第三层选项是性别，有两个可选项男和女，那我们的查找树就是这样子的： 对应的JS对象： const tree = { \"颜色：白色\": { \"尺码：39\": { \"性别：男\": { productId: 1 }, \"性别：女\": { productId: 2 }, }, \"尺码：40\": { \"性别：男\": { productId: 3 }, \"性别：女\": { productId: 4 }, } }, \"颜色：红色\": { \"尺码：39\": { \"性别：男\": { productId: 5 }, \"性别：女\": { productId: 6 }, }, \"尺码：40\": { \"性别：男\": { productId: 7 }, \"性别：女\": { productId: 8 }, } } } 同样的，假如我们要查找一个白色的，39码，男的鞋子，直接tree[\"颜色：白色\"][\"尺码：39\"][\"性别：男\"]就行了，这个时间复杂度也是O(1)O(1)O(1)。 写代码 上面算法都弄明白了，剩下的就是写代码了，我们主要需要写的代码就是用API返回的数据构建一个上面的tree这种结构就行了，一次遍历就可以做到。比如上面这个三层查找树对应的API返回的结构是这样的： const merchandise = { variations: [ { name: '颜色', values: [ { name: '白色' }, { name: '红色' }, ] }, { name: '尺码', values: [ { name: '39' }, { name: '40' }, ] }, { name: '性别', values: [ { name: '男' }, { name: '女' }, ] }, ], products: [ { id: 1, variationMappings: [ { name: '颜色', value: '白色' }, { name: '尺码', value: '39' }, { name: '性别', value: '男' } ] } // 下面还有7个商品，我就不重复了 ] } 为了将API返回的数据转换为我们的树形结构数据我们写一个方法： function buildTree(apiData) { const tree = {}; const { variations, products } = apiData; // 先用variations将树形结构构建出来，叶子节点默认值为null addNode(tree, 0); function addNode(root, deep) { const variationName = variations[deep].name; const variationValues = variations[deep].values; for (let i = 0; i 然后用上面的API测试数据运行下看下效果，发现构建出来的树完全符合我们的预期： 这就好了吗？ 现在我们有了一颗查找树，当用户选择红色，40码后，为了知道对应的男可不可以点，我们不需要去遍历所有的商品了，而是可以直接从这个结构上取值。但是这就大功告成了吗？并没有！再仔细看下我们构建出来的数据结构，层级关系是固定的，第一层是颜色，第二层是尺码，第三层是性别，而对应的商品是放在第三层性别上的。也就是说使用这个结构，用户必须严格按照，先选颜色，再选尺码，然后我们看看性别这里哪个该灰掉。如果他不按照这个顺序，比如他先选了性别男，然后选尺码40，这时候我们应该计算最后一个层级颜色哪些该灰掉。但是使用上面这个结构我们是算不出来的，因为我们并没有tree[\"性别：男\"][\"尺码：40\"]这个对象。 这怎么办呢？我们没有性别-尺码-颜色这种顺序的树，那我们就建一颗呗！这当然是个方法，但是用户还可能有其他的操作顺序呀，如果我们要覆盖用户所有可能的操作顺序，总共需要多少树呢？这其实是性别，尺码，颜色这三个变量的一个全排列，也就是A33A_3^3A​3​3​​，总共6颗树。像我这样的懒人，让我建6棵树，我实在懒得干。如果不建这么多树，需求又覆盖不了，怎么办呢，有没有偷懒的办法呢？如果我能在需求上动点手脚，是不是可以规避这个问题？带着这个思路，我想到了两点： 1. 给一个默认值。 用户打开商品详情页的时候，默认选中第一个可售商品。这样就相当于我们一开始就帮用户按照颜色-尺码-性别这个顺序选中了一个值，给了他一个默认的操作顺序。 2. 不提供取消功能，只能切换选项 如果提供取消功能，他将我们提供的颜色-尺码-性别默认选项取消掉，又可以选成性别-尺码-颜色了。不提供取消功能，只能通过选择其他选项来切换，只能从红色换成白色，而不能取消红色，其他的一样。这样我们就能永远保证颜色-尺码-性别这个顺序，用户操作只是只是每个层级选中的值不一样，层级顺序并不会变化，我们的查找树就一直有效了。而且我发现某些购物网站也不能取消选项，不知道他们是不是也遇到了类似的问题。 对需求做这两点修改并不会对用户体验造成多大影响，跟产品经理商量后，她也同意了。这样我就从需求上干掉了另外5棵树，偷懒成功！ 下面是三层选项跑起来的样子： 还有一件事 前面的方案我们解决了查找的性能问题，但是引入了一个新问题，那就是需要创建这颗查找树。创建这颗查找树还是需要对商品列表进行一次遍历，这是不可避免的，为了更顺滑的用户体验，我们应该尽量将这个创建过程隐藏在用户感知不到的地方。我这里是将它整合到了商品详情页的加载状态中，用户点击进入商品详情页，我们要去API取数据，不可避免的会有一个加载状态，会转个圈什么的。我将这个遍历过程也做到了这个转圈中，当API数据返回，并且查找树创建完成后，转圈才会结束。这在理论上会延长转圈的时间，但是本地的遍历再慢也会比网络请求快点，所以用户感知并不明显。当转圈结束后，所有数据都准备就绪了，用户操作都是O(1)O(1)O(1)的复杂度，做到了真正的丝般顺滑~ 为什么不让后端创建这棵树？ 上面的方案都是在前端创建这颗树，那有没有可能后端一开始返回的数据就是这样的，我直接拿来用就行，这样我又可以偷懒了~我还真去找过后端，可他给我说：“我也想偷懒！”开个玩笑，真是情况是，这个商品API是另一个团队维护的微服务，他们提供的数据不仅仅给我这一个终端APP使用，也给公司其他产品使用，所以要改返回结构涉及面太大，根本改不动。 封装代码 其实我们这个方案实现本身是比较独立的，其他人要是用的话，他也不关心你里面是棵树还是颗草，只要传入选择条件，能够返回正确的商品就行，所以我们可以将它封装成一个类。 class VariationSearchMap { constructor(apiData) { this.tree = this.buildTree(apiData); } // 这就是前面那个构造树的方法 buildTree(apiData) { const tree = {}; const { variations, products } = apiData; // 先用variations将树形结构构建出来，叶子节点默认值为null addNode(tree, 0); function addNode(root, deep) { const variationName = variations[deep].name; const variationValues = variations[deep].values; for (let i = 0; i 然后使用的时候直接new一下就行： const variationSearchMap = new VariationSearchMap(apiData); // new一个实例出来 // 然后就可以用这个实例进行搜索了 const searchCriteria = [ { name: '颜色', value: '红色' }, { name: '尺码', value: '40' }, { name: '性别', value: '女' } ]; const matchedProduct = variationSearchMap.findProductByVariationMappings(searchCriteria); console.log('matchedProduct', matchedProduct); // { productId: 8 } 总结 本文讲述了一个我工作中实际遇到的需求，分享了我的实现和优化思路，供大家参考。我的实现方案不一定完美，如果大家有更好的方案，欢迎在评论区讨论~ 下面再来回顾下本文的要点： 本文要实现的需求是一个商品的三层选项。 当用户选择了两层后，第三层选项应该自动计算出哪些能卖，哪些不能卖。 鉴于后端API返回选项和商品间没有直接的对应关系，为了找出能卖还是不能卖，我们需要遍历所有商品。 当总商品数量不多的时候，所有商品遍历可能不会产生明显的性能问题。 但是当选项增加到三层，商品数量的增加是指数级的，性能问题就会显现出来。 对于O(n3)O(n^3)O(n​3​​)这种写代码时就能预见的性能问题，我们不用等着报BUG了才处理，而是开发时直接就解决了。 本例要解决的是一个查找问题，所以我想到了建一颗树，直接将O(n3)O(n^3)O(n​3​​)的复杂度降到了O(1)O(1)O(1)。 但是一颗树并不能覆盖所有的用户操作，要覆盖所有的用户操作需要6棵树。 出于偷懒的目的，我跟产品经理商量，调整了需求和交互砍掉了5颗树。真实原因是树太多了，会占用更多的内存空间，也不好维护。有时候适当的调整需求和交互也可以达到优化性能的效果，性能优化可以将交互和技术结合起来思考。 这个树的搜索模块可以单独封装成一个类，外部使用者，不需要知道细节，直接调用接口查找就行。 前端会点数据结构还是有用的，本文这种场景下还很有必要。 "},"Articles/Summary/Summary.html":{"url":"Articles/Summary/Summary.html","title":"心得与总结","keywords":"","body":"本章节包括如下内容： 2020年终总结 写作技巧分享 "},"Articles/Summary/WritingSkills.html":{"url":"Articles/Summary/WritingSkills.html","title":"写作技巧分享","keywords":"","body":"为什么写作 在写作之前想清楚为什么写作非常重要！因为你最初的想法会决定你往哪个方向去写，写出的内容的质量怎么样。 我写作的原因很简单，就是我前端做了几年了，大部分时间都在写业务代码，技术上一直没有太大的突破，最多也就是换个框架，换个UI库，换来换去始终感觉似曾相识。为了不让几年工作经验成为“第一年工作经验的复制品”，我决定再深入，系统的学习下前端知识。所以对于我来说，写作是我的学习方法，我的首要目的是学习知识，写作带来的社区声望只是附带的，有了当然好，没有也没必要刻意去刷。 为学习而写 根据我的观察，社区上的作者写作目的主要分为两种：“为学习而写”与“为刷声望而写”。 大部分厉害的大佬其实都是“为学习而写”，就是他们看到什么好玩的，新奇的技术，去学习了，自然而然的总结出文章。或者觉得某个知识点大家很容易搞错，想输出自己的观点，帮大家避坑，就将自己的见解写成文章，这个过程作者虽然更多的是在输出内容，但是写作的过程其实也会强化作者自己的理解，其实也是一个学习方法。我个人认为“为学习而写”写出的文章才是正道，是社区良性发展的方向。 写什么 在这个“系统学习计划”开始之前，我其实没怎么写过技术文章，甚至都没怎么逛过技术社区。平时如果需要学习一个东西，比如学习React，那我会直接去它的官方网站，把它的文档全部读一遍，现在这些流行库的文档都写的很好，看一遍基本就能上手了。如果看完了还是不太知道怎么用，那就去公司看看有没有项目用过，公司没用过，就去GitHub上找找，然后抄抄改改就能上手了。这个过程一般也就几天，复杂的库最多也就一两周就能上手。使用的时候遇到问题就用Google搜，基本都会找到Stack Overflow上，答案拿过来一用就行。 前面几年我的工作模式基本都是这样的，这样应付工作也没啥问题，但是第一年是这样，第二年是这样，第n年还是这样。。。就成了“一年工作经验复用n年”，成了名副其实的“API工程师”，做项目没问题，问原理似曾相识，但是却说不太清楚。如果一直这样，技术就会一直原地踏步，在现单位很容易被替代，出去找工作也可能会四处碰壁，或者找来找去找到的始终跟当前的差不多，很难实现大的突破。 我感到，我碰到瓶颈了。我想突破这个瓶颈，但是我不知道怎么做！在没有具体方向的时候，就看看手上能做啥吧，从简单的，可见的开始做。于是，我决定，我要重头整理自己的知识框架，把那些只是似曾相似的技术，原理全部吃透，于是我从网上找了一份“前端知识架构图谱”，决定按照里面的提纲，全部重新学习一遍。只是我再次学习不能是简单的看看书，看看博客，看看视频就行了，这种事情我以前干过了，作为一个有几年工作经验的前端，我对自己有更高的要求：所有学过的知识点，必须自己全部写成文章进行巩固；所有框架的学习，必须学到原理或者源码层面！ 所以，“写什么”这个问题的答案已经有了：学习前端知识架构，将学习过程写成文章。 怎么写 上面说了，我其实并没有什么写作经验，我最近一次写作是大学论文，再往前就是高中作文了，写作水平其实不咋地。但是技术写作跟普通作文不一样，一般不需要华丽的辞藻，更重要的是要把问题讲清楚，看技术文章的读者需要的是学习技术知识，而不是看风花雪月，所以技术文章的逻辑，层级递进，由浅入深，好理解其实更重要。我刚开始时也不知道怎么写，也是在不断写作工程中，一边写，一边总结，整体来说，我自己的文章其实都分了好几个阶段： 就是记个笔记 有自己理解的知识点解析 深入源码，探究原理 从工作中总结 记个笔记 从小学开始，老师就会让大家记笔记，大家应该都会，这也是最简单的切入点。我刚开始的时候，不会写文章，写的基本都是笔记，比如各种CSS居中方案，这就是我在其他地方学的，然后把他记录下来，也就是个笔记而已。对于“CSS居中”这种问题来说，面试问烂了，网上资料也是一大堆，这篇文章也没什么出彩的地方，所以关注的人不多。其实对于“笔记型”来说，获取关注少是很容易理解的，因为你写的东西是笔记，也就是说你也是从其他地方学来的，整个文章的思路其实也是人家的，如果自己记笔记的水平不高，可能写出来的效果还不如原文章。 深入源码，探究原理 JS知识体系虽然庞大，但是终究是有限的，很快我就写了十几篇JS的文章，内容包含了内存管理，深浅拷贝，面向对象(原型链)，this指向，事件循环，变量类型，作用域等等。这些已经囊括了JS的主要知识点，JS上我已经很难找到新的写文章的点了。 于是我的文章内容开始转向我使用的框架，这几年我主要使用的React技术栈。于是我准备重新整理学习React技术栈，当然不是学习他的用法了，毕竟我用了几年了，用法早就熟悉了，这次我要学的是他们的源码和原理。源码和原理相对于JS知识和框架使用方法来说要难得多，受众也小的多，对于读者来说也很难产生直接的收益。因为读者可能看个JS知识点，出去面试就能应付大部分的JS面试了，除了些大厂外，也不是每个公司面试都会问源码，而且这些受欢迎的开源库是各位大牛努力写作的成果，里面汇聚了各种JS的高级用法，各种高级编程思想和设计模式，所以即使我尽量写得深入浅出，层层递进，相较于其他文章来说仍然会显得更加晦涩难读。所以这类文章在掘金获得的赞和阅读并不可观，我大量的源码解析都只有三四十个赞，这里面还有一半左右是我厚脸求朋友同事们点的(这点我后面在讲推广的时候会说)。 对于作者来说，写源码类文章需要去读框架源码，也会很花时间。我写一个JS知识点的文章，因为东西都是我熟悉的，可能几天就搞定了，写完了还会有上百的赞。但是一个复杂框架的源码解析，比如Express.js，我需要一点点的去读，去调试源码，成文可能需要两三周，写完后可能仍然只有三四十个赞。从社区声望增长这个角度来说，性价比极低！但是我一直没有放弃这类文章，甚至现在成了我主要的写作方向。为什么？因为人总要突破自己的舒适区，探索未知的领域，最终才能学习到东西，获得成长！这其实回到了文章开头就提出的问题：“你为什么要写技术文章？”对于我来说，这是我学习的途径，所以如果这个过程我能够学到东西，能够感受到成长，我就会坚持去做，即使他在其他方面性价比很低！另外我的源码类文章虽然在掘金反响不是很好，但是在其他平台，比如思否，还可以，所以其实也是有回报的。 好了，说了这么多为什么要写源码解析，现在来谈谈怎么写源码解析。前面说了，在我从事技术写作之前，我基本不懂源码，是名副其实的“API工程师”，那会儿我也是一提到源码就心慌，完全不知道从何下手。后来我忐忑的打破自己的心理障碍，多次尝试之后找到了一个看源码的套路。其实再🐂的框架或库本质也是JS代码，所以我们可以用一种简单质朴的方法去读，这其实也是大家经常在用的方法。想象这样一个场景，你们公司一个运行很久的项目出了点问题，你领导让你去调查下。由于这个项目你之前没有参与，现在贸然叫你去解决BUG，你是不是要先反复复现问题，然后找到相关的代码块，调试这些代码并找到BUG原因，然后将它修复。看源码的时候我们完全可以用类似的思路去看，先缩小范围，只看这个库的核心代码。比如Koa.js核心用法其实只有这么点： const Koa = require('koa'); const app = new Koa(); app.use(async ctx => { ctx.body = 'Hello World'; }); app.listen(3000); 你就把它当成你现在需要接手的老项目，为了弄懂他的运行逻辑，看看这段代码里面他暴露了哪些API，然后一个一个去调试下就行了。就上面这几行代码而言，其实只有三个API： Koa类 app.use实例方法 app.listen实例方法 花点时间去源码里面找到这三个API，并看看他们是怎么实现的，在看的时候，把主要逻辑剥离出来，自己实现一遍，同时把整个过程记录下来。 从工作中总结 其实很多公司都不是技术驱动的，技术只是实现业务的一个手段而已，这就造成很多公司的一个项目都是从另一个项目抄抄改改就能用，很多人(包括我)在这种环境下待久了，慢慢就成了“API工程师”，最熟悉的其实是CV大法。但是每个公司的业务其实在某方面都有自己一定的独到性，不然也活不下来，在实现这些比较复杂的业务时，有时候我们也会用一些比较有意思的方法，有时候我们可能花了很多时间去实现他，但是过后又慢慢淡忘了。其实对于这些有一定技术含量的工作，我们也可以总结下，然后写成文章，慢慢沉淀下来成为自己的技术。 "},"Articles/ResourcesSharing/ResourcesSharing.html":{"url":"Articles/ResourcesSharing/ResourcesSharing.html","title":"资源分享","keywords":"","body":"资源目录介绍 本目录列表主要分享一些学习资源，全部来源于网络，如果涉及到侵权或者隐私请联系我，及时删除。 为了方便广大热爱学习的朋友更好的进步，创建了这个分享资源的目录，主要包含前端后端等等一系列的资源课程，并且定期分享一些质量好的资源。请留下你们的star，谢谢。 在这里推荐一个资源大佬，如果需要更好的资源，请联系这个大佬，学习无止境，资源无国界。 在这里放上二维码-----> 资源选择池： 更多资源请看语雀-高清IT清单 "},"Articles/ResourcesSharing/FrontEnd.html":{"url":"Articles/ResourcesSharing/FrontEnd.html","title":"前端相关","keywords":"","body":" 前端资源相关的列表： "},"Articles/ResourcesSharing/BackEnd.html":{"url":"Articles/ResourcesSharing/BackEnd.html","title":"后端相关","keywords":"","body":" 后端资源相关的列表： "},"Articles/ResourcesSharing/TestAbout.html":{"url":"Articles/ResourcesSharing/TestAbout.html","title":"测试相关","keywords":"","body":" 测试资源相关的列表： "}}